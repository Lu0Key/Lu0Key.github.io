<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>洛七的摸鱼池塘</title>
    <link>https://Lu0key.github.io/</link>
    <description>Recent content on 洛七的摸鱼池塘</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 23 Mar 2021 14:52:40 +0800</lastBuildDate><atom:link href="https://Lu0key.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Leetcode 201 数字范围按位与</title>
      <link>https://Lu0key.github.io/post/leetcode-201-bitwise-and-of-numbers-range/</link>
      <pubDate>Tue, 23 Mar 2021 14:52:40 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/leetcode-201-bitwise-and-of-numbers-range/</guid>
      <description>数字范围按位与(Bitwise AND of Numbers Range) 给你两个整数 left 和 right ，表示区间 [left, right] ，返回此区间内所有数字 按位与 的结果（包含 left 、right 端点）。
示例 1：
输入：left = 5, right = 7 输出：4 示例 2：
输入：left = 0, right = 0 输出：0 示例 3：
输入：left = 1, right = 2147483647 输出：0 提示：
 0 &amp;lt;= left &amp;lt;= right &amp;lt;= 2^31 - 1  int rangeBitwiseAnd(int left, int right){ if(left == 0) return 0; int a = right; for(int i = left;i&amp;lt;right;i++){ a &amp;amp;=i; } return a; } 这样显然会超时</description>
    </item>
    
    <item>
      <title>Leetcode 560 和为K的子数组</title>
      <link>https://Lu0key.github.io/post/leetcode-560-subarray-sum-equals-k/</link>
      <pubDate>Tue, 23 Mar 2021 14:50:23 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/leetcode-560-subarray-sum-equals-k/</guid>
      <description>和为K的子数组(Subarray Sum Equals K) 给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数。
示例 1 :
输入:nums = [1,1,1], k = 2 输出: 2 , [1,1] 与 [1,1] 为两种不同的情况。 说明 :
 数组的长度为 [1, 20,000]。 数组中元素的范围是 [-1000, 1000] ，且整数 k 的范围是 [-1e7, 1e7]。  int subarraySum(int* nums, int numsSize, int k){ int count = 0; for(int i =0;i&amp;lt;numsSize;i++){ int sum = 0; for(int j=i;j&amp;lt;numsSize;j++){ sum+=nums[j]; if(sum == k){ count++; } } } return count; } O(n^2) 会超时哦</description>
    </item>
    
    <item>
      <title>Leetcode 1008 前序遍历构造二叉搜索树</title>
      <link>https://Lu0key.github.io/post/leetcode-1008-construct-binary-search-tree-from-preorder-traversal/</link>
      <pubDate>Tue, 23 Mar 2021 14:47:50 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/leetcode-1008-construct-binary-search-tree-from-preorder-traversal/</guid>
      <description>前序遍历构造二叉搜索树(Construct Binary Search Tree from Preorder Traversal) 返回与给定前序遍历 preorder 相匹配的二叉搜索树（binary search tree）的根结点。
(回想一下，二叉搜索树是二叉树的一种，其每个节点都满足以下规则，对于 node.left 的任何后代，值总 &amp;lt; node.val，而 node.right 的任何后代，值总 &amp;gt; node.val。此外，前序遍历首先显示节点 node 的值，然后遍历 node.left，接着遍历 node.right。）
题目保证，对于给定的测试用例，总能找到满足要求的二叉搜索树。
示例：
输入：[8,5,1,7,10,12] 输出：[8,5,10,1,7,null,12] 提示：
 1 &amp;lt;= preorder.length &amp;lt; = 100 1 &amp;lt;= preorder[i] &amp;lt;= 10^8 preorder 中的值互不相同  /** * Definition for a binary tree node. * struct TreeNode { * int val; * struct TreeNode *left; * struct TreeNode *right; * }; */ struct TreeNode* bstFromPreorderRanged(int* preorder, int start, int end){ if(start == end) return NULL; struct TreeNode* root = malloc(sizeof(struct TreeNode)); root-&amp;gt;val = preorder[start]; int i = start+1; while (i&amp;lt;end &amp;amp;&amp;amp; preorder[i]&amp;lt;root-&amp;gt;val){ i++; } root-&amp;gt;left = bstFromPreorderRanged(preorder, start+1, i); root-&amp;gt;right = bstFromPreorderRanged(preorder,i,end); return root; } struct TreeNode* bstFromPreorder(int* preorder, int preorderSize){ return bstFromPreorderRanged(preorder,0,preorderSize); } 提高效率</description>
    </item>
    
    <item>
      <title>Leetcode 33 搜索旋转排序数组</title>
      <link>https://Lu0key.github.io/post/leetcode-33-search-in-rotated-sorted-array/</link>
      <pubDate>Tue, 23 Mar 2021 14:44:28 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/leetcode-33-search-in-rotated-sorted-array/</guid>
      <description>搜索旋转排序数组(Search in Rotated Sorted Array) 整数数组 nums 按升序排列，数组中的值 互不相同 。
在传递给函数之前，nums 在预先未知的某个下标 k（0 &amp;lt;= k &amp;lt; nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。
给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的索引，否则返回 -1 。
示例 1：
输入：nums = [4,5,6,7,0,1,2], target = 0 输出：4 示例 2：
输入：nums = [4,5,6,7,0,1,2], target = 3 输出：-1 示例 3：
输入：nums = [1], target = 0 输出：-1 提示：</description>
    </item>
    
    <item>
      <title>Leetcode 64 最小路径和</title>
      <link>https://Lu0key.github.io/post/leetcode-64-minimum-path-sum/</link>
      <pubDate>Tue, 23 Mar 2021 14:41:59 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/leetcode-64-minimum-path-sum/</guid>
      <description>最小路径和(Minimum Path Sum) 给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。
说明： 每次只能向下或者向右移动一步。
示例 1： 输入：grid = [[1,3,1],[1,5,1],[4,2,1]] 输出：7 解释：因为路径 1→3→1→1→1 的总和最小。 示例 2：
输入：grid = [[1,2,3],[4,5,6]] 输出：12 提示：
 m == grid.length n == grid[i].length 1 &amp;lt;= m, n &amp;lt;= 200 0 &amp;lt;= grid[i][j] &amp;lt;= 100  int minPartialPathSum(int** grid,int** path,int ROWS,int COLS,int i,int j){ if (path[i][j]!=-1){ return path[i][j]; } int right = grid[i][j]; int down = grid[i][j]; if (i==ROWS-1&amp;amp;&amp;amp;j==COLS-1){ path[i][j] = grid[i][j]; return grid[i][j]; } if(j&amp;lt;COLS-1){ right +=minPartialPathSum(grid,path,ROWS,COLS,i,j+1); } if(i&amp;lt;ROWS-1){ down +=minPartialPathSum(grid,path,ROWS,COLS,i+1,j); } if (j==COLS-1){ path[i][j] = down; return down; } if (i==ROWS-1){ path[i][j] = right; return right; } int re = right&amp;lt;down?</description>
    </item>
    
    <item>
      <title>Leetcode 200 岛屿数量</title>
      <link>https://Lu0key.github.io/post/leetcode-200-number-of-islands/</link>
      <pubDate>Tue, 23 Mar 2021 14:39:02 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/leetcode-200-number-of-islands/</guid>
      <description>岛屿数量(Number of Islands) 给你一个由 &#39;1&#39;（陆地）和 &#39;0&#39;（水）组成的的二维网格，请你计算网格中岛屿的数量。
岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。
此外，你可以假设该网格的四条边均被水包围。
示例 1：
输入：grid = [ [&amp;quot;1&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;0&amp;quot;], [&amp;quot;1&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;0&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;0&amp;quot;], [&amp;quot;1&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;0&amp;quot;,&amp;quot;0&amp;quot;,&amp;quot;0&amp;quot;], [&amp;quot;0&amp;quot;,&amp;quot;0&amp;quot;,&amp;quot;0&amp;quot;,&amp;quot;0&amp;quot;,&amp;quot;0&amp;quot;] ] 输出：1 示例 2：
输入：grid = [ [&amp;quot;1&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;0&amp;quot;,&amp;quot;0&amp;quot;,&amp;quot;0&amp;quot;], [&amp;quot;1&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;0&amp;quot;,&amp;quot;0&amp;quot;,&amp;quot;0&amp;quot;], [&amp;quot;0&amp;quot;,&amp;quot;0&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;0&amp;quot;,&amp;quot;0&amp;quot;], [&amp;quot;0&amp;quot;,&amp;quot;0&amp;quot;,&amp;quot;0&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;1&amp;quot;] ] 输出：3 提示：
 m == grid.length n == grid[i].length 1 &amp;lt;= m, n &amp;lt;= 300 grid[i][j] 的值为 &#39;0&#39; 或 &#39;1&#39;  我们找到一个岛屿之后就把他清零，当所有数字都为0时，就表示结束了
const char WATER = &amp;#39;0&amp;#39;; const char LAND = &amp;#39;1&amp;#39;; const char NEW = &amp;#39;X&amp;#39;; const char USED = &amp;#39;O&amp;#39;; void floodFill(char** grid,int NUMBER_OF_ROWS,int NUMBER_OF_COLS,int i,int j){ if(i&amp;lt;0 || i&amp;gt;=NUMBER_OF_ROWS || j&amp;lt;0 || j&amp;gt;=NUMBER_OF_COLS||grid[i][j]!</description>
    </item>
    
    <item>
      <title>Leetcode 678 有效的括号字符串</title>
      <link>https://Lu0key.github.io/post/leetcode-678-valid-parenthesis-string/</link>
      <pubDate>Tue, 23 Mar 2021 14:30:43 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/leetcode-678-valid-parenthesis-string/</guid>
      <description>有效的括号字符串(Valid Parenthesis String) 给定一个只包含三种字符的字符串：（ ，） 和 *，写一个函数来检验这个字符串是否为有效字符串。有效字符串具有如下规则：
 任何左括号 ( 必须有相应的右括号 )。 任何右括号 ) 必须有相应的左括号 ( 。 左括号 ( 必须在对应的右括号之前 )。 * 可以被视为单个右括号 ) ，或单个左括号 ( ，或一个空字符串。 一个空字符串也被视为有效字符串。  示例 1:
输入: &amp;quot;()&amp;quot; 输出: True 示例 2:
输入: &amp;quot;(*)&amp;quot; 输出: True 示例 3:
输入: &amp;quot;(*))&amp;quot; 输出: True 注意:
 字符串大小将在 [1，100] 范围内。  bool checkVaildSubstring(char * s, int i, int j){ if(i &amp;gt; j) return true; if(s[i] == &amp;#39;)&amp;#39;) { return false; }else if( s[i] == &amp;#39;*&amp;#39;){ if (checkVaildSubstring(s, i+1,j)){ return true; } } for (int k=i+1;k&amp;lt;= j;k++){ if(s[k]==&amp;#39;)&amp;#39; || s[k] == &amp;#39;*&amp;#39;){ if(checkVaildSubstring(s,i+1,k-1) &amp;amp;&amp;amp; checkVaildSubstring(s,k+1,j)){ return true; } } } return false; } bool checkValidString(char * s){ return checkVaildSubstring(s,0,strlen(s)-1); } 这里会因为重复算相同的内容多次导致超时，因此我们可以用一个二维数组将算过的存起来，二维数组的i,j表示从索引i到索引j的这个子串是否计算过</description>
    </item>
    
    <item>
      <title>Leetcode 238 除自身以外数组的乘积</title>
      <link>https://Lu0key.github.io/post/leetcode-238-product-of-array-except-self/</link>
      <pubDate>Tue, 23 Mar 2021 14:27:37 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/leetcode-238-product-of-array-except-self/</guid>
      <description>除自身以外数组的乘积(Product of Array Except Self) 给你一个长度为 n 的整数数组 nums，其中 n &amp;gt; 1，返回输出数组 output ，其中 output[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积。
示例:
输入: [1,2,3,4] 输出: [24,12,8,6] 提示: 题目数据保证数组之中任意元素的全部前缀元素和后缀（甚至是整个数组）的乘积都在 32 位整数范围内。
说明: 请 不要使用除法，且在 O(n) 时间复杂度内完成此题。
进阶： 你可以在常数空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组不被视为额外空间。）
/** * Note: The returned array must be malloced, assume caller calls free(). */ int* productExceptSelf(int* nums, int numsSize, int* returnSize){ *returnSize = numsSize; int * result = malloc(sizeof(int)*numsSize); for (int i =0;i&amp;lt;numsSize;i++){ int left = 1; for(int j =0;j&amp;lt;=i-1;j++){ left *= nums[j]; } int right =1; for (int j =i+1;j&amp;lt;numsSize;j++){ right *=nums[j]; } result[i] = left*right; } return result; } int* productExceptSelf(int* nums, int numsSize, int* returnSize){ int *result = malloc(sizeof(int)*numsSize); int *lefts = malloc(sizeof(int)*numsSize); lefts[0]=1; for(int i =1;i&amp;lt;numsSize;i++){ lefts[i] = lefts[i-1]*nums[i-1]; } int *rights = malloc(sizeof(int)*numsSize); rights[numsSize-1]=1; for(int i =numsSize-2;i&amp;gt;=0;i--){ rights[i] = rights[i+1]*nums[i+1]; } // 这个for可以放在上面，right[i] 算完了就可以算result[i]了，然后少一个for循环  for (int i =0;i&amp;lt;numsSize;i++){ result[i] = lefts[i]*rights[i]; } *returnSize = numsSize; return result; } 题目问能不能不要额外的空间，然后返回的空间不算，因此我们先第一步简化</description>
    </item>
    
    <item>
      <title>Leetcode 525 连续数组</title>
      <link>https://Lu0key.github.io/post/leetcode-525-contiguous-array/</link>
      <pubDate>Tue, 23 Mar 2021 14:24:43 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/leetcode-525-contiguous-array/</guid>
      <description>连续数组(Contiguous Array) 给定一个二进制数组, 找到含有相同数量的 0 和 1 的最长连续子数组（的长度）。
示例 1:
输入: [0,1] 输出: 2 说明: [0, 1] 是具有相同数量0和1的最长连续子数组。 示例 2:
输入: [0,1,0] 输出: 2 说明: [0, 1] (或 [1, 0]) 是具有相同数量0和1的最长连续子数组。 注意: 给定的二进制数组的长度不会超过50000。
最粗暴的方式
int count0(int i,int j,int *nums) { int count = 0; for (int k =i; k&amp;lt;=j;k++){ if(nums[k] == 0){ count++; } } return count; } int count1(int i,int j,int *nums) { int count = 0; for (int k =i; k&amp;lt;=j;k++){ if(nums[k] == 1){ count++; } } return count; } int findMaxLength(int* nums, int numsSize){ int maxLength = 0; for (int i =0;i&amp;lt;numsSize;i++){ for(int j =i;j&amp;lt;numsSize;j++){ if(count0(i,j,nums) == count1(i,j,nums)){ int length = j-i+1; if (length &amp;gt; maxLength){ maxLength = length; } } } } return maxLength; } 但是这样会超时，毕竟O(n^3)</description>
    </item>
    
    <item>
      <title>Leetcode 1046 最后一块石头的重量</title>
      <link>https://Lu0key.github.io/post/leetcode-1046-last-stone-weight/</link>
      <pubDate>Tue, 23 Mar 2021 14:21:07 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/leetcode-1046-last-stone-weight/</guid>
      <description>最后一块石头的重量(Last Stone Weight) 有一堆石头，每块石头的重量都是正整数。
每一回合，从中选出两块 最重的 石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x &amp;lt;= y。那么粉碎的可能结果如下：
 如果 x == y，那么两块石头都会被完全粉碎； 如果 x != y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。  最后，最多只会剩下一块石头。返回此石头的重量。如果没有石头剩下，就返回 0。
示例：
输入：[2,7,4,1,8,1] 输出：1 解释： 先选出 7 和 8，得到 1，所以数组转换为 [2,4,1,1,1]， 再选出 2 和 4，得到 2，所以数组转换为 [2,1,1,1]， 接着是 2 和 1，得到 1，所以数组转换为 [1,1,1]， 最后选出 1 和 1，得到 0，最终数组转换为 [1]，这就是最后剩下那块石头的重量。 提示：
 1 &amp;lt;= stones.length &amp;lt;= 30 1 &amp;lt;= stones[i] &amp;lt;= 1000  int extractMax(int *stones, int stonesSize) { int max = stones[0]; // 获取最大数  for (int i=1;i&amp;lt;stonesSize;i++){ if (stones[i]&amp;gt;max){ max = stones[i]; } } // 将第一个最大数位置置为0  for(int i =0;i&amp;lt;stonesSize;i++){ if(stones[i] == max){ stones[i]=0; break; } } return max; } void insert(int *stones, int stonesSize, int value) { for (int i =0;i&amp;lt;stonesSize;i++){ if(stones[i] == 0){ stones[i] = value; break; } } } int lastStoneWeight(int* stones, int stonesSize){ while(true) { // 第一大  int y = extractMax(stones, stonesSize); // 第二大  int x = extractMax(stones, stonesSize); if(x == 0) { return y; } if(x!</description>
    </item>
    
    <item>
      <title>Leetcode 543 Diameter of Binary Tree</title>
      <link>https://Lu0key.github.io/post/leetcode-543-diameter-of-binary-tree/</link>
      <pubDate>Sat, 20 Mar 2021 13:26:27 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/leetcode-543-diameter-of-binary-tree/</guid>
      <description>二叉树的直径(Diameter of Binary Tree) 给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。
示例 : 给定二叉树
 1 / \ 2 3 / \ 4 5 返回 3, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。
注意：两结点之间的路径长度是以它们之间边的数目表示。
/** * Definition for a binary tree node. * struct TreeNode { * int val; * struct TreeNode *left; * struct TreeNode *right; * }; */ int maxDepth(struct TreeNode * root){ if (root == NULL) return 0; int leftMax = maxDepth(root-&amp;gt;left); int rightMax = maxDepth(root-&amp;gt;right); if(leftMax&amp;gt;rightMax){ return leftMax+1; } return rightMax+1; } int diameterOfBinaryTree(struct TreeNode* root){ if (root == NULL) return 0; int middle = maxDepth(root-&amp;gt;left) + maxDepth(root-&amp;gt;right); int left = diameterOfBinaryTree(root-&amp;gt;left); int right = diameterOfBinaryTree(root-&amp;gt;right); int max = middle; if (left &amp;gt; max){ max = left; } if(right &amp;gt; max){ max = right; } return max; } 二叉树的最大深度(Maximum Depth of Binary Tree) 给定一个二叉树，找出其最大深度。</description>
    </item>
    
    <item>
      <title>Leetcode 155 Min Stack</title>
      <link>https://Lu0key.github.io/post/leetcode-155-min-stack/</link>
      <pubDate>Sat, 20 Mar 2021 13:22:09 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/leetcode-155-min-stack/</guid>
      <description>最小栈(Min Stack) 设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。
push(x) —— 将元素 x 推入栈中。 pop() —— 删除栈顶的元素。 top() —— 获取栈顶元素。 getMin() —— 检索栈中的最小元素。  示例:
输入： [&amp;quot;MinStack&amp;quot;,&amp;quot;push&amp;quot;,&amp;quot;push&amp;quot;,&amp;quot;push&amp;quot;,&amp;quot;getMin&amp;quot;,&amp;quot;pop&amp;quot;,&amp;quot;top&amp;quot;,&amp;quot;getMin&amp;quot;] [[],[-2],[0],[-3],[],[],[],[]] 输出： [null,null,null,null,-3,null,0,-2] 解释： MinStack minStack = new MinStack(); minStack.push(-2); minStack.push(0); minStack.push(-3); minStack.getMin(); --&amp;gt; 返回 -3. minStack.pop(); minStack.top(); --&amp;gt; 返回 0. minStack.getMin(); --&amp;gt; 返回 -2. 提示：
 pop、top 和 getMin 操作总是在 非空栈 上调用。  C语言版:
/** * Your MinStack struct will be instantiated and called as such: * MinStack* obj = minStackCreate(); * minStackPush(obj, val); * minStackPop(obj); * int param_3 = minStackTop(obj); * int param_4 = minStackGetMin(obj); * minStackFree(obj); */ typedef struct { int * data; int * mins; int size; } MinStack; /** initialize your data structure here.</description>
    </item>
    
    <item>
      <title>Leetcode Backspace String Compare</title>
      <link>https://Lu0key.github.io/post/leetcode-backspace-string-compare/</link>
      <pubDate>Fri, 19 Mar 2021 17:42:46 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/leetcode-backspace-string-compare/</guid>
      <description>比较含退格的字符串(Backspace String Compare) 给定 S 和 T 两个字符串，当它们分别被输入到空白的文本编辑器后，判断二者是否相等，并返回结果。 # 代表退格字符。
注意：如果对空文本输入退格字符，文本继续为空。
示例 1：
输入：S = &amp;quot;ab#c&amp;quot;, T = &amp;quot;ad#c&amp;quot; 输出：true 解释：S 和 T 都会变成 “ac”。 示例 2：
输入：S = &amp;quot;ab##&amp;quot;, T = &amp;quot;c#d#&amp;quot; 输出：true 解释：S 和 T 都会变成 “”。 示例 3：
输入：S = &amp;quot;a##c&amp;quot;, T = &amp;quot;#a#c&amp;quot; 输出：true 解释：S 和 T 都会变成 “c”。 示例 4：
输入：S = &amp;quot;a#c&amp;quot;, T = &amp;quot;b&amp;quot; 输出：false 解释：S 会变成 “c”，但 T 仍然是 “b”。 提示：
 1 &amp;lt;= S.</description>
    </item>
    
    <item>
      <title>Leetcode 876 Middle of the Linked List</title>
      <link>https://Lu0key.github.io/post/leetcode-876-middle-of-the-linked-list/</link>
      <pubDate>Fri, 19 Mar 2021 16:54:41 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/leetcode-876-middle-of-the-linked-list/</guid>
      <description>链表的中间结点(Middle Of The Linked List) 给定一个头结点为 head 的非空单链表，返回链表的中间结点。
如果有两个中间结点，则返回第二个中间结点。
示例 1：
输入：[1,2,3,4,5] 输出：此列表中的结点 3 (序列化形式：[3,4,5]) 返回的结点值为 3 。 (测评系统对该结点序列化表述是 [3,4,5])。 注意，我们返回了一个 ListNode 类型的对象 ans，这样： ans.val = 3, ans.next.val = 4, ans.next.next.val = 5, 以及 ans.next.next.next = NULL. 示例 2：
输入：[1,2,3,4,5,6] 输出：此列表中的结点 4 (序列化形式：[4,5,6]) 由于该列表有两个中间结点，值分别为 3 和 4，我们返回第二个结点。 提示：
 给定链表的结点数介于 1 和 100 之间。  C语言版:
/** * Definition for singly-linked list. * struct ListNode { * int val; * struct ListNode *next; * }; */ struct ListNode * middleNode(struct ListNode* head){ int length = 1; struct ListNode* curr = head; while(curr-&amp;gt;next!</description>
    </item>
    
    <item>
      <title>Leetcode 49 Group Anagrams</title>
      <link>https://Lu0key.github.io/post/leetcode-49-group-anagrams/</link>
      <pubDate>Tue, 16 Mar 2021 16:50:13 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/leetcode-49-group-anagrams/</guid>
      <description>字母异位词分组(Group Anagrams) 给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。
示例:
输入: [&amp;quot;eat&amp;quot;, &amp;quot;tea&amp;quot;, &amp;quot;tan&amp;quot;, &amp;quot;ate&amp;quot;, &amp;quot;nat&amp;quot;, &amp;quot;bat&amp;quot;] 输出: [ [&amp;quot;ate&amp;quot;,&amp;quot;eat&amp;quot;,&amp;quot;tea&amp;quot;], [&amp;quot;nat&amp;quot;,&amp;quot;tan&amp;quot;], [&amp;quot;bat&amp;quot;] ] 说明：
 所有输入均为小写字母。 不考虑答案输出的顺序。  C语言版:
/** * Return an array of arrays of size *returnSize. * The sizes of the arrays are returned as *returnColumnSizes array. * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free(). */ int cmpChar(const void*a ,const void *b){ return *(const char*)a - *(const char *)b; } typedef struct { char * original; char * sorted; }Pair; int cmpPair(const void * a, const void * b){ const Pair * pa = (const Pair *)a; const Pair * pb = (const Pair *)b; return strcmp(pa-&amp;gt;sorted, pb-&amp;gt;sorted); } char *** groupAnagrams(char ** strs, int strsSize, int* returnSize, int** returnColumnSizes){ Pair* pairs = malloc(sizeof(Pair)*strsSize); for(int i =0;i&amp;lt;strsSize;i++){ char *sorted_str = malloc(sizeof(char)*strlen(strs[i])+1); strcpy(sorted_str,strs[i]); qsort(sorted_str, strlen(strs[i]),sizeof(char),cmpChar); pairs[i].</description>
    </item>
    
    <item>
      <title>积分练习 3</title>
      <link>https://Lu0key.github.io/post/%E7%A7%AF%E5%88%86%E7%BB%83%E4%B9%A0-3/</link>
      <pubDate>Tue, 16 Mar 2021 12:21:54 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/%E7%A7%AF%E5%88%86%E7%BB%83%E4%B9%A0-3/</guid>
      <description>积分练习 3 1 $$ I=\int_2^{\infty}\dfrac{e^{-\sqrt{x}}}{(\sqrt{x}-1)^2}\text{d}x $$
【Sol】:
$\begin{aligned} I=&amp;amp;\int_{\sqrt{2}}^{\infty}\dfrac{e^{-x}}{(x-1)^2}(2x\text{d}x)\\
=&amp;amp;2\int_{\sqrt{2}}^{\infty}\dfrac{xe^{-x}}{(x-1)^2}\text{d}x\\
=&amp;amp;2\int_{\sqrt{2}-1}^{\infty}\dfrac{x+1}{x^2}e^{-x-1}\text{d}x\\
=&amp;amp;\dfrac{2}{e}\int_{\sqrt{2}-1}^{\infty}(x+1)e^{-x}\text{d}\left(-\dfrac{1}{x}\right)\\
=&amp;amp;\dfrac{2}{e}\left[-\dfrac{x+1}{x}e^{-x}\bigg|_{\sqrt{2}-1}^{\infty}+\int_{\sqrt{2}-1}^{\infty}\dfrac{1}{x}(-x)e^{-x}\text{d}x\right]\\
=&amp;amp;\dfrac{2}{e}\left[\dfrac{\sqrt{2}}{\sqrt{2}-1}e^{1-\sqrt{2}}-\int_{\sqrt{2}-1}^{\infty}e^{-x}\text{d}x\right]\\
=&amp;amp;\dfrac{2}{e}\left[\sqrt{2}(\sqrt{2}+1)e^{1-\sqrt{2}}-e^{1-\sqrt{2}}\right]\\
=&amp;amp;2(\sqrt{2}+1)e^{-\sqrt{2}} \end{aligned}$
 2 $$ I=\int_0^1\dfrac{1}{1+\sqrt{2x\sqrt{1-x^2}}}\text{d}x $$
【Sol】:
利用公式
$$ \int_0^1f(2x\sqrt{1-x^2})\text{d}x=\int_0^1f(1-x^2)\text{d}x $$ 于是有:
$\begin{aligned} I=&amp;amp;\int_0^1\dfrac{1}{1+\sqrt{1-x^2}}\text{d}x\\
=&amp;amp;\int_0^{\frac{\pi}{2}}\dfrac{1}{1+\cos x}\text{d}(\sin x)\\
=&amp;amp;\int_0^{\frac{\pi}{2}}\left[1-\dfrac{1}{1+\cos x}\right]\text{d}x\
=&amp;amp;\dfrac{\pi}{2}-\dfrac{\sin x}{1+\cos x}\bigg|_{0}^{\frac{\pi}{2}}\
=&amp;amp;\dfrac{\pi}{2}-1 \end{aligned}$
 3 $$ I=\int_{0}^{2\pi}\dfrac{\sin^2x}{5+4\cos x}\text{d}x=\dfrac{\pi}{4} $$
【Sol】:
被积函数是周期为 $2\pi$ 的偶函数，因此可以将区间移动到对称区间 $[-\pi,; \pi]$ 上:
$$ I=\int_{-\pi}^{\pi}\dfrac{\sin^2x}{5+4\cos x}\text{d}x=2\int_{0}^{\pi}\dfrac{\sin^2x}{5+4\cos x}\text{d}x $$
又余弦函数在 $[0,; \pi]$ 上不对称，因此
$\begin{aligned} I=&amp;amp;2\left[\int_0^{\frac{\pi}{2}}\dfrac{\sin^2x}{5+\cos x}\text{d}x+\int_{\frac{\pi}{2}}^{\pi}\dfrac{\sin^2x}{5+4\cos x}\text{d}x\right]\\
=&amp;amp;2\left[\int_0^{\frac{\pi}{2}}\dfrac{\sin^2x}{5+4\cos x}\text{d}x+\int_{0}^{\frac{\pi}{2}}\dfrac{\cos^2x}{5-4\sin x}\text{d}x\right]\\
=&amp;amp;2\int_0^{\frac{\pi}{2}}\left[\dfrac{\sin^2x}{5+4\cos x}+\dfrac{\sin^2x}{5-4\cos x}\right]\text{d}x\\</description>
    </item>
    
    <item>
      <title>Leetcode 122 Best Time to Buy and Sell Stock Ii</title>
      <link>https://Lu0key.github.io/post/leetcode-122-best-time-to-buy-and-sell-stock-ii/</link>
      <pubDate>Tue, 16 Mar 2021 00:05:57 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/leetcode-122-best-time-to-buy-and-sell-stock-ii/</guid>
      <description>买卖股票的最佳时机II(Best Time To Buy And Sell Stock II) 给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。
设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。
注意: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
示例 1:
输入: [7,1,5,3,6,4] 输出: 7 解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。 示例 2:
输入: [1,2,3,4,5] 输出: 4 解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。 因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。 示例 3:</description>
    </item>
    
    <item>
      <title>Leetcode 283 Move Zeroes</title>
      <link>https://Lu0key.github.io/post/leetcode-283-move-zeroes/</link>
      <pubDate>Mon, 15 Mar 2021 16:56:34 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/leetcode-283-move-zeroes/</guid>
      <description>移动零(Move Zeroes) 给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。
示例:
输入: [0,1,0,3,12] 输出: [1,3,12,0,0] 说明:
 必须在原数组上操作，不能拷贝额外的数组。 尽量减少操作次数。  C语言版本:
void moveZeroes(int* nums, int numsSize){ while(true){ int count = 0; for (int i =0;i+1&amp;lt;numsSize;i++) { if(nums[i]==0 &amp;amp;&amp;amp; nums[i+1]!=0) { count++; int temp = nums[i]; nums[i] = nums[i+1]; nums[i+1] = temp; break; } } if (count==0)break; } } 这样会超时，去掉第一个break就能过
模仿冒泡排序:
void moveZeroes(int* nums, int numsSize){ for (int k=0;k&amp;lt;numsSize;k++){ for(int i=0;i+1&amp;lt;numsSize;i++){ if(nums[i] == 0 &amp;amp;&amp;amp; nums[i+1] !</description>
    </item>
    
    <item>
      <title>Leetcode 53 Maximum Subarray</title>
      <link>https://Lu0key.github.io/post/leetcode-53-maximum-subarray/</link>
      <pubDate>Mon, 15 Mar 2021 16:02:01 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/leetcode-53-maximum-subarray/</guid>
      <description>最大子序和(Maximum Subarray) 给定一个整数数组 nums，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
示例 1：
输入：nums = [-2,1,-3,4,-1,2,1,-5,4] 输出：6 解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。 示例 2：
输入：nums = [1] 输出：1 示例 3：
输入：nums = [0] 输出：0 示例 4：
输入：nums = [-1] 输出：-1 示例 5：
输入：nums = [-100000] 输出：-100000 提示：
 $1\leqslant nums.length \leqslant 3 * 10^5$ $-10^5 \leqslant nums[i] \leqslant 10^5$  进阶：如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的 分治法 求解。
C语言版本:
int maxSubArray(int* nums, int numsSize){ int max=nums[0]; for (int i=0; i &amp;lt;numsSize;i++) { for (int j =i;j&amp;lt;numsSize;j++){ int sum = 0; for (int k =i;k&amp;lt;=j;k++){ sum += nums[k]; } if (sum&amp;gt;max){ max = sum; } } } return max; } 用这种方法会超时</description>
    </item>
    
    <item>
      <title>Leetcode 202 Happy Number</title>
      <link>https://Lu0key.github.io/post/leetcode-202-happy-number/</link>
      <pubDate>Mon, 15 Mar 2021 15:27:25 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/leetcode-202-happy-number/</guid>
      <description>快乐数(Happy Number) 编写一个算法来判断一个数 n 是不是快乐数。
「快乐数」定义为：
 对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。 然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。 如果 可以变为 1，那么这个数就是快乐数。  如果 n 是快乐数就返回 true ；不是，则返回 false 。
示例 1：
输入：19 输出：true 解释： 1² + 9² = 82 8² + 2² = 68 6² + 8² = 100 1² + 0² + 0² = 1 示例 2：
输入：n = 2 解释： 2² = 4 4² = 16 1² + 6² = 37 3² + 7² = 58 5² + 8² = 89 8² + 9² = 145 1² + 4² + 5² = 42 4² + 2² = 20 2² + 0² = 4 循环了，永远不会到1 输出：false 提示：</description>
    </item>
    
    <item>
      <title>Leetcode 136 Single Number</title>
      <link>https://Lu0key.github.io/post/leetcode-136-single-number/</link>
      <pubDate>Mon, 15 Mar 2021 14:36:31 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/leetcode-136-single-number/</guid>
      <description>只出现一次的数字(Single Number) 给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。
说明：
你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？
示例 1:
输入: [2,2,1] 输出: 1 示例 2:
输入: [4,1,2,1,2] 输出: 4 C的解法:
int singleNumber(int* nums, int numsSize){ for (int i =0;i&amp;lt;numsSize;i++){ int count = 0; for (int j=0;j&amp;lt;numsSize;j++){ if(nums[j]==nums[i]){ count++; } if(count==2)break; } if(count==1){ return nums[i]; } } return -1; } 用位运算:
int singleNumber(int* nums, int numsSize){ int n =nums[0]; for (int i =1;i&amp;lt;numsSize;i++){ n ^= nums[i]; } return n; } 之后再补Java的写法，都是类似的</description>
    </item>
    
    <item>
      <title>两道有意思的数列极限</title>
      <link>https://Lu0key.github.io/post/%E4%B8%A4%E9%81%93%E6%9C%89%E6%84%8F%E6%80%9D%E7%9A%84%E6%95%B0%E5%88%97%E6%9E%81%E9%99%90/</link>
      <pubDate>Thu, 11 Mar 2021 09:22:08 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/%E4%B8%A4%E9%81%93%E6%9C%89%E6%84%8F%E6%80%9D%E7%9A%84%E6%95%B0%E5%88%97%E6%9E%81%E9%99%90/</guid>
      <description>两道有意思的数列极限 1 设 $a_1=\sqrt{\dfrac{1}{2}},\; a_n=\sqrt{\dfrac{1+a_{n-1}}{2}}$，求 $\displaystyle\lim_{n\to\infty}a_1a_2\cdots a_n$.
【Sol】: $a_!=\cos\dfrac{\pi}{4},\;a_2=\sqrt{\dfrac{1+\cos\frac{\pi}{4}}{2}}=\sqrt{\cos^2\dfrac{\pi}{4\cdot2}}=\cos\dfrac{\pi}{4\cdot2},\;a_3\sqrt{\dfrac{1+a_3}{2}}=\cos\dfrac{\pi}{4\cdot2^2},\;\cdots,\;a_n=\cos\dfrac{\pi}{4\cdot2^{n-1}}$
因此
$\begin{aligned} &amp;amp;\lim_{n\to\infty}a_1a_2\cdots a_n\\
=&amp;amp;\lim_{n\to\infty}\cos\dfrac{\pi}{4}\cdot\cos\dfrac{\pi}{4\cdot2}\cdot\cdots\cos\dfrac{\pi}{4\cdot2^{n-1}}\\
=&amp;amp;\lim_{n\to\infty}\dfrac{\cos\dfrac{\pi}{4}\cdot\cos\dfrac{\pi}{4\cdot2}\cdot\cdots\cos\dfrac{\pi}{4\cdot2^{n-1}}(2\sin\dfrac{\pi}{4\cdot2^{n-1}})}{2\sin\dfrac{\pi}{4\cdot2^{n-1}}}\\
=&amp;amp;\lim_{n\to\infty}\dfrac{\cos\dfrac{\pi}{4}\cdot\cos\dfrac{\pi}{4\cdot2}\cdot\cdots\cos\dfrac{\pi}{4\cdot2^{n-2}}\cdot\sin\dfrac{\pi}{4\cdot2^{n-2}}}{2\sin\dfrac{\pi}{4\cdot2^{n-1}}}\\
=&amp;amp;\lim_{n\to\infty}\dfrac{\sin\dfrac{\pi}{2}}{2^{n}\sin\dfrac{\pi}{4\cdot2^{n-1}}}\\
=&amp;amp;\lim_{n\to\infty}\dfrac{1}{2^n\cdot\dfrac{\pi}{2^{n+1}}}\\
=&amp;amp;\dfrac{2}{\pi} \end{aligned}$
这里将 $\sqrt{\dfrac{1}{2}}=\cos\dfrac{\pi}{4}$ 如果是第一次见的话可能比较难以想到.
 2 设 $a_1=1,\;a_n=a_{n-1}+\dfrac{1}{a_{n-1}}(n\geqslant2)$，求
$$ \lim_{n\to\infty}\dfrac{\sqrt{2n}(a_n-\sqrt{2n})}{\ln n} $$
【Sol】:
(1) 由于 $a_1&amp;gt;0$ 因此 ${a_n}$ 为单调递增序列，且趋向于无穷大.
$a_{n+1}^2=a_{n}^2+\dfrac{1}{a_{n}^2}+2$
(2) $\displaystyle\lim_{n\to\infty}\dfrac{a_{n}^2}{2n}\xlongequal{\text{Stolz}}\lim_{n\to\infty}\dfrac{a_{n+1}^2-a_{n}^2}{2}=\lim_{n\to\infty}\dfrac{\dfrac{1}{a_n}^2+2}{2}=1\Rightarrow \lim_{n\to\infty}\dfrac{a_n}{\sqrt{2n}}=1$.
(3)
$\begin{aligned} &amp;amp;\lim_{n\to\infty}\dfrac{\sqrt{2n}(a_n-\sqrt{2n})}{\ln n}\\
=&amp;amp;\lim_{n\to\infty}\dfrac{\sqrt{2n}(a_{n}^2-2n)}{\ln n(a_n+\sqrt{2n})}\\
=&amp;amp;\lim_{n\to\infty}\dfrac{\sqrt{2n}}{a_n+\sqrt{2n}}\cdot\lim_{n\to\infty}\dfrac{a_n^2-2n}{\ln n}\\
\xlongequal{\text{Stolz}}&amp;amp;\dfrac{1}{2}\lim_{n\to\infty}\dfrac{a_{n+1}^2-a_{n}^2-2}{\ln(n+1)-\ln n}\\
=&amp;amp;\dfrac{1}{2}\lim_{n\to\infty}\dfrac{\dfrac{1}{a_n^2}}{\dfrac{1}{n}}\\
=&amp;amp;\dfrac{1}{2}\lim_{n\to\infty}\dfrac{n}{a_n^2}=\dfrac{1}{2}\times\dfrac{1}{2}=\dfrac{1}{4} \end{aligned}$
这题的解答来自一位群友，MSE上有老哥写的更长的渐进展开.</description>
    </item>
    
    <item>
      <title>积分练习 2</title>
      <link>https://Lu0key.github.io/post/%E7%A7%AF%E5%88%86%E7%BB%83%E4%B9%A0-2/</link>
      <pubDate>Tue, 09 Mar 2021 23:08:29 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/%E7%A7%AF%E5%88%86%E7%BB%83%E4%B9%A0-2/</guid>
      <description>积分练习 2 1 求积分 $$ I=\int_0^1\dfrac{x\ln(1+x)}{(1+x^2)^2}\text{d}x\
$$
【Sol】:
$\begin{aligned} I=&amp;amp;\int_0^1\ln(1+x)\text{d}\left[-\dfrac{1}{2(1+x^2)} \right]\\
=&amp;amp;-\dfrac{\ln(1+x)}{2(1+x^2)}\bigg|_0^1+\dfrac{1}{2}\int_0^1\dfrac{1}{(1+x^2)(1+x)}\text{d}x\\
=&amp;amp;-\dfrac{1}{4}\ln2+\dfrac{1}{4}\int_0^1\left[\dfrac{1}{1+x}+\dfrac{1-x}{1+x^2} \right]\\
=&amp;amp;-\dfrac{1}{4}\ln2+\dfrac{1}{4}\left[\ln(1+x)+\arctan x-\dfrac{1}{2}\ln(1+x^2) \right]\bigg|_0^1\\
=&amp;amp;-\dfrac{1}{8}\ln2+\dfrac{\pi}{16} \end{aligned}$
 2 求积分 $$ I=\int_0^{\infty} \dfrac{e^{-x}-e^{-2x}}{x}\sin x\text{d}x $$
【Sol】: 用拉普拉斯变换求
令 $f(x)=(e^{-x}-e^{-2x})\sin x$
$F(x)=\dfrac{1}{(x+1)^2+1}-\dfrac{1}{(x+2)^2+1}$
$\begin{aligned} I=&amp;amp;\int_0^{\infty}\left[\dfrac{1}{(x+1)^2+1}-\dfrac{1}{(x+2)^2+1} \right]\text{d}x\\
=&amp;amp;\left[\arctan(x+1)-\arctan(x+2) \right]\bigg|_{0}^{\infty}\\
=&amp;amp;\arctan 2-\dfrac{\pi}{4} \end{aligned}$
 3 求积分
$$ I=\int_0^1\dfrac{\ln(x+\sqrt{1-x^2})}{x}\text{d}x $$
【Sol】: 考虑含参积分
$\displaystyle I(a)=\int_0^1\dfrac{\ln(xa+\sqrt{1-x^2})}{x}\text{d}x,;;I=I(1)$
$\begin{aligned} I(0)=&amp;amp;\int_0^{1}\dfrac{\ln\sqrt{1-x^2}}{x}\text{d}x\\
=&amp;amp;\dfrac{1}{2}\left[\int_0^1\dfrac{\ln(1+x)}{x}\text{d}x+\int_0^{1}\dfrac{\ln(1-x)}{x}\text{d}x \right]\\
=&amp;amp;\dfrac{1}{2}\left[\dfrac{\pi^2}{12}-\dfrac{\pi^2}{6} \right]\\
=&amp;amp;-\dfrac{\pi^2}{24} \end{aligned}$
$\begin{aligned} I&#39;(a)=&amp;amp;\int_0^1\dfrac{1}{xa+\sqrt{1-x^2}}\text{d}x\\
=&amp;amp;\int_0^{\frac{\pi}{2}}\dfrac{1}{a\sin t+\cos t}\cos t\text{d}t\\
=&amp;amp;\dfrac{1}{a^2+1}\left[ \int_0^{\frac{\pi}{2}}\dfrac{(a\sin t+\cos t)+a(a\cos t-\sin t)}{a\sin t+\cos t}\text{d}t\right]\\</description>
    </item>
    
    <item>
      <title>积分练习 1</title>
      <link>https://Lu0key.github.io/post/%E7%A7%AF%E5%88%86%E7%BB%83%E4%B9%A0-1/</link>
      <pubDate>Tue, 09 Mar 2021 14:35:58 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/%E7%A7%AF%E5%88%86%E7%BB%83%E4%B9%A0-1/</guid>
      <description>积分练习 1 1 求积分 $$ I=\int_0^{\frac{\pi}{2}}\sin x\ln\sin x\text{d}x $$
【Sol】:
$\begin{aligned} I=&amp;amp;\int_0^{\frac{\pi}{2}}\cos x\ln\cos x\text{d}x\\
=&amp;amp;\int_0^{\frac{\pi}{2}}\ln\cos x\text{d}(\sin x-1)\\
=&amp;amp;(\sin x-1)\ln\cos x\bigg|_{0}^{\frac{\pi}{2}}-\int_0^{\frac{\pi}{2}}(\sin x-1)\text{d}(\ln \cos x)\\
=&amp;amp;0-0-\int_0^{\frac{\pi}{2}}\sin x\text{d}(\ln\cos x)+\ln\cos x\bigg|_0^{\frac{\pi}{2}} \end{aligned}$
令 $\displaystyle J=-\int_0^{\frac{\pi}{2}}\sin x\text{d}(\ln\cos x)$
$\begin{aligned} J=&amp;amp;\int_0^{\frac{\pi}{2}}\sin x\tan x\text{d}x\\
=&amp;amp;\int_0^{\frac{\pi}{2}}\dfrac{\sin^2x}{\cos x}\text{d}x\\
=&amp;amp;\int_0^{\frac{\pi}{2}}\dfrac{1-\cos^2x}{\cos x}\text{d}x\\
=&amp;amp;\left[\ln|\sec x+\tan x|-\sin x\right]\bigg|_0^{\frac{\pi}{2}} \end{aligned}$
因此
$\begin{aligned} I=&amp;amp;J+\ln\cos x\bigg|_ 0^{\frac{\pi}{2}}\\
=&amp;amp;\left[\ln|\sec x+\tan x|-\sin x\right] \bigg|_{0}^{ \frac{\pi}{2}} +\ln\cos x\bigg|_{0}^{\frac{\pi}{2}}\\
=&amp;amp;\left[\ln|1+\sin x|-\sin x\right]\bigg|_0^{\frac{\pi}{2}}\\
=&amp;amp;\ln 2-1 \end{aligned}$
 2 $$ I=\int_0^1\dfrac{x\ln x}{\sqrt{1-x^2}}\text{d}x $$</description>
    </item>
    
    <item>
      <title>Listings 笔记</title>
      <link>https://Lu0key.github.io/post/listings-%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Thu, 04 Mar 2021 19:37:06 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/listings-%E7%AC%94%E8%AE%B0/</guid>
      <description>listings 笔记 虽然是使用listings宏包，但是在使用环境的时候是使用lstlisting
basicstyle = &amp;lt;basic style&amp;gt;
可以在每个列表的开头选择. 你可以使用 \footnotesize, \small, \itshape, \ttfamily,或者其他的. The last token of &amp;lt;basic style&amp;gt; 的最后一个标记不能读取以下任何字符(这一句翻译的怪怪的).
如果你发现你的代码没有自动换行，可以加上这句
breaklines=true 我们再设定一下代码块的语言和样式
language=Java, keywordstyle={\bfseries\color{NavyBlue}} 这边要把xcolor宏包引入
如果你觉得listings自带的关键字不够，可以自己手动添加关键字
morekeywords={String} 有些不是关键字，但是是重要的类，可以使用强调(同样的，想要强调明显，也需要给强调设置样式)
emph={Controller,@RequestParam,CommonsMultipartFile,HttpServletRequest,IOException,@Controller,OutputStream, InputStream, @RequestMapping, HttpServletResponse,@PostMapping,File}, emphstyle={\bfseries\color{Tan}} 这时候我们会发现不仅下面的代码强调了，连导入的包中对应的词都强调了，这是我们不想看见的，因此我们可以使用
alsoletter{.} 这样前面有点的强调字就不会被记录在被强调的里面了
效果如图
除此之外，我们还可以设置这些
backgroundcolor={\color{yellow!40!white}}, % 设置背景颜色 frame=shadowbox, % 设置边框 rulecolor={\color{purple}}, % 设置边框线条颜色 rulesepcolor={\color{orange}}, % 设置边框线条和代码块间的颜色 framesep=1em, % 设置代码块和边框的距离 numbers=left, % 设置代码行数的位置 numbersep=2em, % 设置代码行数离代码的距离 numberstyle={\sffamily\footnotesize} % 设置代码行数的样式 最后的效果如图所示， 如果我们需要写很多的代码块，那我们可以把公共的部分放在最前面的 \lstset 中
listings的demo
\begin{lstlisting}[ basicstyle=\ttfamily, breaklines=true, language=Java, morekeywords={String}, keywordstyle={\bfseries\color{NavyBlue}}, emph={Controller,@RequestParam,CommonsMultipartFile,HttpServletRequest,IOException,@Controller, OutputStream, InputStream, @RequestMapping, HttpServletResponse,@PostMapping,File}, emphstyle={\bfseries\color{Tan}}, alsoletter={.</description>
    </item>
    
    <item>
      <title>Test Image Bed</title>
      <link>https://Lu0key.github.io/post/test-image-bed/</link>
      <pubDate>Thu, 04 Mar 2021 00:20:24 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/test-image-bed/</guid>
      <description>测试 Github 的免费图床 这个是图片用https://carbon.now.sh/生成的
别的搜到的一些不太喜欢,比如http://www.planetb.ca/syntax-highlight-word
vscode 有个插件 Polacode，但是不知道为什么没用成功，下次再试试，左上角三个点是模仿苹果的，Polacode没有这三个点，好了先到这里，晚安
如果图床好用了，明天就写listings的笔记</description>
    </item>
    
    <item>
      <title>王道考研 数据结构 查找</title>
      <link>https://Lu0key.github.io/post/%E7%8E%8B%E9%81%93%E8%80%83%E7%A0%94-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%9F%A5%E6%89%BE/</link>
      <pubDate>Mon, 01 Mar 2021 08:27:27 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/%E7%8E%8B%E9%81%93%E8%80%83%E7%A0%94-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%9F%A5%E6%89%BE/</guid>
      <description>查找  查找  基本概念 顺序查找 折半查找 分块查找 B树 B树的插入和删除  插入 删除   B+树 散列查找  散列表(Hash Table) 开放定址法 平方探测法 伪随机序列法 再散列法      基本概念 查找：在数据集合中寻找满足某种条件的数据元素的过程称为查找
查找表(查找结构)：用于查找的数据集合称为查找表，它由同一类型的数据元素(或记录组成)
关键字：数据元素中唯一标识该元素的某个数据项的值，使用基于关键字的查找，查找结果应该是唯一的(比如学号)
常见操作
 查找符合条件的数据元素 插入、删除某个数据元素  如果只进行操作1——静态查找表即可
也要进行操作2——动态查找表
评价指标
查找长度：在查找运算中，需要对比关键字的次数称为查找长度
平均查找长度(ASL)：所有查找过程中进行关键字的比较次数的平均值
$\displaystyle ASL=\sum_{i=1}^nP_iC_i$
其中n为数据元素个数，C_i为查找第i个元素的查找长度，P_i为查找第i个元素的概率
ASL的数量级放映了查找算法时间复杂度
评价一个查找算法的效率时，通常考虑查找成功/失败两种情况的ASL
顺序查找 顺序查找，又叫“线性查找”，通常用于线性表(顺序表、链表)
算法思想：从头到尾一个一个对比
顺序查找的实现
// 查找表的数据结构(顺序表) typedef struct { // 动态数组的基址(剩下靠偏移量)  Elemtypr *elem; // 表的长度  int TableLen; }SSTable; // 顺序查找 int Search_Seq(SSTable ST, ElemType key) { int i; // for循环空语句  for (i=0;i&amp;lt;ST.</description>
    </item>
    
    <item>
      <title>王道考研 数据结构 图</title>
      <link>https://Lu0key.github.io/post/%E7%8E%8B%E9%81%93%E8%80%83%E7%A0%94-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/</link>
      <pubDate>Mon, 01 Mar 2021 08:22:55 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/%E7%8E%8B%E9%81%93%E8%80%83%E7%A0%94-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/</guid>
      <description>图  图  定义 图的存储  临接矩阵 邻接表 十字链表法 邻接多重表   基本操作 图的遍历  广度优先遍历 深度优先遍历   最小生成树 最短路径问题 Dijkstra算法 Floyd算法 有向无环图(DAG) 拓扑排序 关键路径    定义 图G由顶点集V和边集E组成，记为G=(V, E)，其中V(G) 表示图G中顶点的有限非空集；E(G) 表示图G 中顶点之间的关系（边）集合。若 $V={v_1, v_2, &amp;hellip;, v_n}$，则用 $|V|$ 表示图G 中顶点的个数，也称图G 的阶，$E={(u, v)|u\in V, v\in V}$，用 $|E|$ 表示图G中边的条数。
G：Graph
V：Vertex
E：Edge
线性表可以是空表，树可以是空树，但图不可以是空的，即V一定是非空集
e.g.
V:车站，E：铁路
社交软件中的好友关系可以看成是一种无向图
微博中的粉丝关系可以看作是一种有向图
若 E 是无向边（简称边）的有限集合时，则图 G 为无向图。边是顶点的无序对，记为 $(v, w)$ 或 $(w, v)$，因为 $(v, w)=(w, v)$，其中v，w 是顶点。可以说顶点w和顶点v互为邻接点。边 $(v, w)$ 依附于顶点 $w$ 和 $v$，或者说边 $(v, w)$ 和顶点 v、w 相关联。</description>
    </item>
    
    <item>
      <title>Python Selenium 笔记</title>
      <link>https://Lu0key.github.io/post/python-selenium/</link>
      <pubDate>Sun, 28 Feb 2021 19:30:33 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/python-selenium/</guid>
      <description>Python Selenium 笔记 这里用的是Firefox的 webdriver
browser = webdriver.Firefox(executable_path =r&amp;#34;D:\geckodriver&amp;#34;) 通过get打开网页
browser.get(&amp;#34;https://www.baidu.com&amp;#34;) 窗口最大化
browser.maximize_window() 输入内容
browser.find_element_by_id(&amp;#34;un&amp;#34;).send_keys(&amp;#34;学号&amp;#34;) 点击事件
browser.find_element_by_id(&amp;#34;index_login_btn&amp;#34;).click() close 和 quit 的区别
# close 是关闭当前tab browser.close() # quit 是关闭整个浏览器 browser.quit() 在自动化操作的时候可能会遇到多个标签页，这里我还不是很清楚，一个标签页对应一个句柄
# 获得所有句柄 handles = browser.window_handles # 获得当前句柄 currentWin = browser.current_window_handle 因为我在使用的时候，最多只会遇到两个标签页，多的标签页可以直接close掉，因此没有深究怎么切换到指定的标签页的方法，只要每次产生新的标签页的时候，我就把当前的标签页关掉，然后获得新标签页的句柄(因为只有一个标签页，因此句柄也只有一个)
# 假装这里打开了新的标签页 # 关闭当前标签页 browser.close() # 获得所有句柄(这时只有1个) handles = browser.window_handles # 切换到这个句柄上 browser.switch_to.window(handles[0]) 当页面中有iframe标签的时候，选择器无法选择到iframe中的内容，因此要切换到iframe内
# 这里只要获得了对应的iframe标签即可，比如用id也可以 iframe = browser.find_elements_by_tag_name(&amp;#34;iframe&amp;#34;)[0] # 切换到iframe中就可以用css选择器之类的去获取元素 browser.switch_to.frame(iframe) # 对iframe中的内容操作完了，返回原页面 browser.switch_to.default_content() </description>
    </item>
    
    <item>
      <title>Python 操作 Excel</title>
      <link>https://Lu0key.github.io/post/python-wr-excel/</link>
      <pubDate>Sun, 28 Feb 2021 18:37:37 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/python-wr-excel/</guid>
      <description>Python 处理excel 老师需要找出哪些同学在网上填了返校申请，因为有几百个人，所以比较难以肉眼看出来
这里我们假设填了信息的人可以导出名字，和整个年级的名单
这样我们就有两个表了，代码如下
import xlrd # 总的人名 name_set = [] # 填报的人 name_data = [] # 没填报的人 other = [] set_excel = xlrd.open_workbook(&amp;#39;C:\\Users\\Luokey\\Desktop\\set.xlsx&amp;#39;) set_sheet = set_excel.sheets()[0] print(set_sheet.name) print(&amp;#34;=============&amp;#34;) # 这里实际上是从第二行开始，到第一列的最后一个元素 for i in range(1,len(set_sheet.col_slice(0, start_rowx=0, end_rowx=None))): name = set_sheet.cell_value(i, 0) name_set.append(name) print(name_set) print(len(name_set)) data_excel = xlrd.open_workbook(&amp;#39;C:\\Users\\Luokey\\Desktop\\data.xlsx&amp;#39;) data_sheet = data_excel.sheets()[0] print(&amp;#34;=============&amp;#34;) # 这里实际上是从第二行开始，到第一列的最后一个元素 for i in range(1,len(data_sheet.col_slice(0, start_rowx=0, end_rowx=None))): name = data_sheet.cell_value(i, 0) name_data.append(name) print(&amp;#34;======没提交的名单=======&amp;#34;) for name in name_set: if name not in name_data: print(name) other.</description>
    </item>
    
    <item>
      <title>Spring5</title>
      <link>https://Lu0key.github.io/post/spring5/</link>
      <pubDate>Wed, 17 Feb 2021 22:18:45 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/spring5/</guid>
      <description>Spring Spring 简介  Spring理念：使现有的技术 更加容易使用，本身是一个大杂烩  SSH：Struct2+Spring+Hibernate
SSM：SpringMVC+Spring+Mybatis
官网：https://spring.io/projects/spring-framework
官方下载地址：https://repo.spring.io/release/org/springframework/spring/ Github：https://github.com/spring-projects/spring-framework
&amp;lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-webmvc&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;5.2.12.RELEASE&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-jdbc --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-jdbc&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;5.2.12.RELEASE&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; 优点  Spring是一个开源的免费的框架(容器) Spring是一个轻量级、非入侵式的框架 控制反转(IOC)，面向切面编程(AOP) 支持事务的处理，对框架整合的支持  总结：Spring是一个轻量级的控制反转(IOC)和面向切面变成(AOP)的框架！
组成 拓展  SpringBoot  一个快速开发的脚手架 基于SpringBoot可以快速地开发单个微服务、 约定大于配置   SpringCloud  SpringCloud 是基于 SpringBoot实现的    因为现在大多数公司都在使用SpringBoot进行快速开发，学习SpingBoot的前提，需要完全掌握Spring和SpringMVC。承上启下的作用
弊端：发展了太久之后，违背了原来的理念，配置十分繁琐，人称“配置地狱”
IOC理论推导  UserDao接口 UserDaoImpl 实现类 UserService 业务接口 UserServiceImpl 业务实现  在我们之前的业务中，用户的需求可能会影响我们原来的代码，我们需要根据用户的需求去修改原代码，如果程序代码量十分大，修改一次的成本十分高昂
我们使用一个Set接口实现，已经发生了革命性的变化
private UserDao userDao; public void setUserDao(UserDao userdao) { this.</description>
    </item>
    
    <item>
      <title>Mybatis</title>
      <link>https://Lu0key.github.io/post/mybatis/</link>
      <pubDate>Mon, 15 Feb 2021 22:05:30 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/mybatis/</guid>
      <description>MyBatis MyBatis官网
简介 什么是MaBatis？  MyBatis 是一款优秀的持久层框架 它支持自定义 SQL、存储过程以及高级映射。 MyBatis 免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作。 MyBatis 可以通过简单的 XML 或注解来配置和映射原始类型、接口和 Java POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。  如何获得MyBatis？
 github maven  &amp;lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.mybatis&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;mybatis&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;3.5.2&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; 持久化 数据持久化
 持久化就是将程序的数据在持久状态和瞬时状态转化的过程 内存：断电即失 数据库(JDBC)、IO文件持久化  为什么需要持久化？
 有一些数据，不能让他丢掉 内存太贵了  持久层  完成持久化工作的代码块 层界限十分明显  为什么需要MyBatis？  方便 传统的JDBC代码太复杂了。简化，框架 帮助程序员将数据存入到数据库中 不用MyBatis也可以，MyBatis更容易上手。技术没有高低之分 优点  sql和代码分离 更容易单元测试 提供xml标签，支持编写动态sql    最重要的一点：使用的人多</description>
    </item>
    
    <item>
      <title>王道考研 数据结构 串</title>
      <link>https://Lu0key.github.io/post/%E7%8E%8B%E9%81%93%E8%80%83%E7%A0%94-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%B8%B2/</link>
      <pubDate>Sat, 06 Feb 2021 22:10:51 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/%E7%8E%8B%E9%81%93%E8%80%83%E7%A0%94-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%B8%B2/</guid>
      <description>串  串  定义 存储结构  顺序存储 链式存储   基本操作  求子串 比较字符串 定位操作   朴素模式匹配算法 KMP 算法 KMP算法优化    定义 串，即字符串（String）是由零个或者多个字符组成的有限序列。一般记为 S = &amp;lsquo;a1a2&amp;hellip;a_n&amp;rsquo; ($n\geqslant0$)
其中，S是串名，单引号括起来的字符序列是串的值；$a_i$可以是字母、数字或者其他字符；串中字符的个数n称为串的长度。n=0 时的串称为空串（用 $\varnothing$ 表示）
字串：串中任意个连续的字符组成的子序列
主串：包含字串的串
字符在主串中的位置：字符在串中的序号
字串在主串中的位置：字串的第一个字符在主串中的位置
位序是从1开始，而不是0开始
串是一种特殊的线性表，数据元素之间呈线性关系
串的数据对象限定为字符集（如中文字符、英文字符、数字字符、标点字符等）
串的基本操作，如增删改查通常以字串为操作对象
串的基本操作
 StrAssign(&amp;amp;T, chars)：赋值操作，把串T赋值为chars StrCopy(&amp;amp;T, S)：复制操作。由串S复制得到串T StrEmpty(S)：判空操作。若S为空串，则返回true，否则返回false StrLength(S)：求串长，返回串S的元素个数 ClearString(&amp;amp;S)：清空操作。将S清为空串 DestroyString(&amp;amp;S)：销毁串。将串S销毁，回收存储空间 Concat(&amp;amp;T, S1, S2)：串联接。用T返回由S1和S2联接而成的新串 SubString(&amp;amp;sub, S, pos, len)：求字串，用sub但会串S的第pos个字符起长度为len的子串 Index(S, T)：定位操作。若主串S中存在与串T值相同的子串，则返回它在主串S中第一次出现的位置；否则函数值为0 StrCompare(S, T)：比较操作。若S&amp;gt;T，则返回值&amp;gt;0，若S=T，则返回值=0，若S&amp;lt; T，则返回值&amp;lt;0  这个比较是一个字符一个字符比较的，那字符怎么比较呢？
ASCII字符编码，将数字与字符一一对应，因此比较字符实际上就是比较字符对应的数字
乱码问题：
不同的编码规则可能会导致乱码</description>
    </item>
    
    <item>
      <title>王道考研 数据结构 栈和队列</title>
      <link>https://Lu0key.github.io/post/%E7%8E%8B%E9%81%93%E8%80%83%E7%A0%94-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/</link>
      <pubDate>Sat, 06 Feb 2021 22:08:19 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/%E7%8E%8B%E9%81%93%E8%80%83%E7%A0%94-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/</guid>
      <description>栈和队列  栈和队列  定义 顺序栈  顺序栈-进栈 顺序表-出栈 顺序栈-读栈 顺序栈-共享栈 栈的链式实现   队列  队列-顺序存储 队列-入队 队列-出队 队列的链式实现 双端队列   栈-括号匹配 栈-表达式求值  原理 代码   栈的应用-递归 队列的应用 特殊矩阵的压缩存储  对称矩阵 三角矩阵 三对角矩阵 稀疏矩阵      定义 栈(stack) 是只允许一端进行插入或删除操作的线性表（是同一端）.
重要术语
 栈顶 栈底 空栈  特点：LIFO（Last In First Out）后进的先出
基本操作
 InitStack(&amp;amp; S)：初始化栈。构造一个空栈S，分配内存空间。 DestroyStack(&amp;amp; S)：销毁栈。销毁并释放栈S所占的内存空间。 Push(&amp;amp;S, x)：进栈，若栈S未满，则将x加入使之成为新栈顶。 Pop(&amp;amp;S, &amp;amp;x)：出栈，若栈S非空，则弹出栈顶元素，并用x返回 GetTop(S, &amp;amp;x)：读栈顶元素。若栈S非空，则用x返回栈顶元素  栈的差一般只访问栈顶元素   StackEmpty(S)：判断一个栈S是否为空，若为空，则返回true，否则返回false。  常考题型：判断合法的出栈的顺序（要满足先进后出，后进先出）</description>
    </item>
    
    <item>
      <title>王道考研 数据结构 线性表</title>
      <link>https://Lu0key.github.io/post/%E7%8E%8B%E9%81%93%E8%80%83%E7%A0%94-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%80%A7%E8%A1%A8/</link>
      <pubDate>Sat, 06 Feb 2021 21:43:51 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/%E7%8E%8B%E9%81%93%E8%80%83%E7%A0%94-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%80%A7%E8%A1%A8/</guid>
      <description>线性表  线性表  定义 基本操作  其他常用操作 注 为什么需要实现基本操作   顺序表  顺序表的实现-静态分配 顺序表的实现-动态分配 特点 顺序表-插入 顺序表-删除 顺序表-按位查找 顺序表-按值查找 按值查找的时间复杂度   链表  定义 单链表-初始化 单链表-按位序插入 单链表-后插操作 单链表-前插操作 单链表-按位序删除 单链表-删除指定结点 单链表-按位查找 单链表-按值查找 单链表-获取长度 单链表-尾插法 单链表-头插法   双链表  初始化 双链表-插入 双链表-删除 双链表-遍历   循环链表  循环单链表 循环双链表   静态链表  静态链表-定义   顺序表和链表的比较    定义 线性表(Linear List)是具有相同数据类型的 n ($n\geqslant0$) 个数据元素的有限序列，其中 n 为表长，当 n=0 时线性表是一个空表。若用 L 命名线性表，则一般表示为 $$ L=(a_1, a_2,\cdots,a_j, a_{j+1},\cdots,a_n) $$ 相同：意味着每个数据元素所占空间一样大</description>
    </item>
    
    <item>
      <title>Git Commit错误修改</title>
      <link>https://Lu0key.github.io/post/git-commit%E9%94%99%E8%AF%AF%E4%BF%AE%E6%94%B9/</link>
      <pubDate>Sat, 06 Feb 2021 21:34:56 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/git-commit%E9%94%99%E8%AF%AF%E4%BF%AE%E6%94%B9/</guid>
      <description>git commit错误修改 在 git commit -m &amp;quot;message&amp;quot; 时，我们有时会不小心把 message 的信息写错，要怎么修改呢？
这时候分为两种情况
 已经git push了 还没git push  还没push 这种情况比较简单，直接使用
git commit --amend 进入vim界面，按i进入insert模式，修改完错误的message后，按esc，输入:wq保存退出即可，最后再push
通过
git log 可以看到记录是修改后的message
已经push 这种情况命令比较多一点，但是也是能够解决
先用 git log 查看是哪一次commit 的message需要修改，比如我是倒数第二次和第三次的commit都有一点问题，那么我们先修改倒数第二次的，先使用命令
git rebase -i HEAD^ 进入vim界面，按i进入insert模式，将需要修改message的那一行的pick改成edit，将message改成正确的，再按esc，输入 :wq 保存退出
输入命令
git commit --amend 同样进入vim界面，按i进入insert模式，将第一行错误的message修改为正确的message，退出保存流程和上面一样
rebase确认命令
git rebase --continue 最后强制push一下即可
git push -f 查看git log会发现已经修改好了</description>
    </item>
    
    <item>
      <title>上交考研数分一题</title>
      <link>https://Lu0key.github.io/post/%E4%B8%8A%E4%BA%A4%E8%80%83%E7%A0%94%E6%95%B0%E5%88%86%E4%B8%80%E9%A2%98/</link>
      <pubDate>Fri, 22 Jan 2021 20:49:16 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/%E4%B8%8A%E4%BA%A4%E8%80%83%E7%A0%94%E6%95%B0%E5%88%86%E4%B8%80%E9%A2%98/</guid>
      <description>2021 上海交通大学硕士研究生入学考试数学分析第7题
求极限
$$ \lim_{x\to\infty}\dfrac{(1+\frac{1}{x})^x-e}{\sin\dfrac{1}{x}}
$$
Solution: $$\begin{aligned} &amp;amp;\lim_{x\to\infty}\dfrac{(1+\frac{1}{x})^x-e}{\sin\dfrac{1}{x}}\\
=&amp;amp;e\lim_{x\to\infty}\dfrac{e^{x\ln(1+\frac{1}{x})-1}-1}{\dfrac{1}{x}}\\
=&amp;amp;e\lim_{x\to\infty}x[x\ln(1+\dfrac{1}{x})-1]\\
=&amp;amp;e\lim_{x\to\infty}x[x(\dfrac{1}{x}-\dfrac{1}{2x^2}+o(\dfrac{1}{x^3}))-1]\\
=&amp;amp;-\dfrac{e}{2} \end{aligned}$$</description>
    </item>
    
    <item>
      <title>函数的不可积问题</title>
      <link>https://Lu0key.github.io/post/%E5%87%BD%E6%95%B0%E7%9A%84%E4%B8%8D%E5%8F%AF%E7%A7%AF%E9%97%AE%E9%A2%98/</link>
      <pubDate>Fri, 22 Jan 2021 20:32:15 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/%E5%87%BD%E6%95%B0%E7%9A%84%E4%B8%8D%E5%8F%AF%E7%A7%AF%E9%97%AE%E9%A2%98/</guid>
      <description>函数的“不可积”问题 这里的“不可积”指的是原函数不能表示成初等函数的形式
基本是搬运，但是忘记出处了
常见的“不可积”的例子 三角积分类 $\displaystyle\int\dfrac{\sin x}{x^n}\text{d}x,;\int\dfrac{\cos x}{x^n}\text{d}x,;\int\dfrac{\tan x}{x^n},;\int x^n\tan x\text{d}x$
$\displaystyle\int\left(\dfrac{x}{\sin x}\right)^n\text{d}x,;\int\left(\dfrac{x}{\cos x}\right)^n\text{d}x,;\int\left(\dfrac{x}{\tan x}\right)^n\text{d}x$
菲涅尔积分类型 $\displaystyle\int\sin x^2\text{d}x,;\int\cos x^2\text{d}x,;\int\tan x^2\text{d}x$
贝塞尔积分 $\displaystyle\int\cos(x\sin x)\text{d}x$
Laplace 积分 $\displaystyle\int\dfrac{\cos\beta x}{1+x^2}\text{d}x$
高斯积分类 $\displaystyle\int e^{ax^2+bx+c}\text{d}x$
$\displaystyle\int x^ne^{ax^2+bx+c}\text{d}x$
指数积分类型 $\displaystyle\int\dfrac{e^{ax}}{x}\text{d}x,;\int\dfrac{e^{ax}}{a+x^n}\text{d}x,;\int\dfrac{x^n}{1\pm e^x}\text{d}x$
对数积分类型 $\displaystyle\int\dfrac{\text{d}x}{\ln x},;\int\dfrac{\ln x\text{d}x}{1+x^2},;\int\ln\sin x\text{d}x,;\int\ln\cos x\text{d}x,;\int\ln\tan x\text{d}x$
$\displaystyle\int\ln(a+b\sin x)\text{d}x,;\int\ln(a+b\cos x)\text{d}x,\int\ln(a+b\tan x)\text{d}x$
$\displaystyle\int\ln\ln\sin x\text{d}x,;\int\ln\ln\cos x\text{d}x,;\int\ln\ln\tan x\text{d}x$
椭圆积分类 $\displaystyle\int\dfrac{1}{\sqrt{1-k^2\sin^2x}}\text{d}x,;\int\sqrt{1-k^2\sin^2x}\text{d}x$
$\displaystyle\int\dfrac{1}{\sqrt{1\pm x^n}}\text{d}x,;\int\sqrt{1\pm x^n}\text{d}x;(n\geqslant3)$
常见的特殊函数 Beta 函数 $\displaystyle\text{B}(p,q)=\int_0^1x^{p-1}(1-x)^{q-1}\text{d}x=\dfrac{\Gamma(p)\Gamma(q)}{\Gamma(p+q)},;(p,q&amp;gt;0)$
Gamma 函数 $\displaystyle\Gamma(s)=\int_0^{+\infty}x^{s-1}e^{-x}\text{d}x,;(s&amp;gt;0)$
误差函数 $\displaystyle\text{erf}(x)=\dfrac{2}{\sqrt{\pi}}\int_0^xe^{-x^2}\text{d}x$
互补误差函数 $\displaystyle \text{erfc}(x)=1-\text{erf}(x)=\dfrac{2}{\sqrt{\pi}}\int_x^{+\infty}e^{-x^2}\text{d}x$
zeta 函数 $\displaystyle\zeta(s)=\sum_{k=1}^{\infty}\dfrac{1}{k^s}$</description>
    </item>
    
    <item>
      <title>王道考研 数据结构 绪论</title>
      <link>https://Lu0key.github.io/post/%E7%8E%8B%E9%81%93%E8%80%83%E7%A0%94-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BB%AA%E8%AE%BA/</link>
      <pubDate>Fri, 22 Jan 2021 19:09:34 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/%E7%8E%8B%E9%81%93%E8%80%83%E7%A0%94-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BB%AA%E8%AE%BA/</guid>
      <description>绪论 学什么  如何用程序代码把现实世界的问题信息化 如何用计算机高效地处理这些信息从而创造价值  基本概念 数据  数据是信息的载体，是描述客观事物属性的数、字符及所有能输入到计算机中并被计算机程序识别和处理的符号的集合。数据是计算机程序加工的原料。
 数据元素、数据项  数据元素是数据的基本单位，通常作为一个整体进行考虑和处理。
一个数据元素可由若干个数据项组成，数据项是构成数据元素的不可分割的最小单位。
 数据结构、数据对象  结构 是各个元素之间的关系
数据结构 是相互之间存在一种或者多种特定关系的数据元素的集合。
数据对象 是具有相同性质的数据元素的集合，是数据的一个子集。
 数据结构的三要素   逻辑结构
 集合  各个元素同属一个集合，别无其他关系   线性结构  数据元素之间是一对一的关系，除了第一个元素，所有元素都有唯一前驱，除了最后一个元素，所有元素都有唯一后继   树形结构  数据元素之间是一对多的关系   图状结构（网状结构）  数据元素之间是多对多的关系      物理结构（存储结构）
 顺序存储  存储位置相邻   链式存储  借助元素存储地址的指针来辨识元素之间的逻辑关系   索引存储  索引表，索引表中的每项称为索引项(关键字，地址)   散列存储  通过元素的关键字直接计算出该元素的存储地址，又称哈希（Hash）存储      数据的运算</description>
    </item>
    
    <item>
      <title>Euler积分</title>
      <link>https://Lu0key.github.io/post/euler%E7%A7%AF%E5%88%86/</link>
      <pubDate>Fri, 22 Jan 2021 16:04:02 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/euler%E7%A7%AF%E5%88%86/</guid>
      <description>Beta 函数 形如
$\displaystyle \text{B}(p,q)=\int_0^1x^{p-1}(1-x)^{q-1}\text{d}x$
的含参变量积分称为 Beta 函数，或 第一类 Euler 积分。
Beta 函数 $\text{B}(p,q)$ 的定义域为 $(0,+\infty)\times(0,+\infty)$
性质 1 连续性 $\text{B}(p,q)$ 在 $(0,+\infty)\times(0,+\infty)$ 上连续.
2 对称性 $\text{B}(p,q)=\text{B}(q,p),;p&amp;gt;0,;q&amp;gt;0$
3 递推公式 $\text{B}(p,q)=\dfrac{q-1}{p+q-1}\text{B}(p,q-1),;p&amp;gt;0,;q&amp;gt;1$
可由对称性与递推公式得到，
当 $p&amp;gt;1,;q&amp;gt;1$ 时，有
$\text{B}(p,q)=\dfrac{(p-1)(q-1)}{(p+q-1)(p+q-2)}\text{B}(p-1,q-1)$
其他表示 1 作变量代换 $x=\cos^2\varphi$，得到
$\text{B}(p,q)=2\displaystyle\int_0^{\frac\pi2}\cos^{2p-1}\varphi\sin^{2q-1}\varphi;\text{d}\varphi$
易知
$\text{B}\left(\dfrac{1}{2},\dfrac{1}{2}\right)=\pi$
2 作变量代换 $x=\dfrac{1}{1+t}$，得到
$\begin{aligned} \text{B}(p,q)=&amp;amp;\int_0^{+\infty}\dfrac{t^{q-1}}{(1+t)^{p+q}}\text{d}t\
=&amp;amp;\int_0^{1}\dfrac{t^{q-1}}{(1+t)^{p+q}}\text{d}t+\int_1^{+\infty}\dfrac{t^{q-1}}{(1+t)^{p+q}}\text{d}t \end{aligned}$
对后一个积分作变量代换 $t=\dfrac{1}{u}$，得到
$\displaystyle\int_1^{+\infty}\dfrac{t^{q-1}}{(1+t)^{p+q}}\text{d}t=\int_0^1\dfrac{u^{p-1}}{(1+u)^{p+q}}\text{d}u$
于是
$\displaystyle\text{B}(p,q)=\int_0^1\dfrac{t^{q-1}+t^{p-1}}{(1+t)^{p+q}}\text{d}t$
 Gamma 函数 形如
$\displaystyle\Gamma(s)=\int_0^{+\infty}x^{s-1}e^{-x}\text{d}x$
的含参变量积分称为 Gamma 函数 或 第二类 Euler 积分.
$\Gamma(s)$ 的定义域为 $(0,+\infty)$
性质 1 连续性与可导性 $\Gamma(s)$ 在 $(0,+\infty)$ 上连续且任意阶可导.</description>
    </item>
    
    <item>
      <title>Python Flask 入门</title>
      <link>https://Lu0key.github.io/post/python-flask-%E5%85%A5%E9%97%A8/</link>
      <pubDate>Fri, 22 Jan 2021 16:01:50 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/python-flask-%E5%85%A5%E9%97%A8/</guid>
      <description>Flask  Flask  特点 list  example   tuple(元组)  “可变的” tuple  tips     循环  range() continue  example   break   dict set  常用函数   定义函数  tips 空函数 参数检查 多个返回值 默认参数  坑   可变参数 关键字参数 命名关键词参数   参数组合还没看&amp;hellip;..  递归函数  tips   尾递归 切片 Slice 切片   Iteration 迭代  如何判断一个对象是否可迭代 如何同时迭代索引和元素   列表生成式 generator 生成器 迭代器 高阶函数 map/reduce filter sorted 返回函数 闭包(Closure) 匿名函数lambda 装饰器(Decorator) 偏函数 Partial function 模块 Module  作用域 安装第三方库   OOP 访问限制 继承和多态 获取对象信息 实例属性和类属性 使用__slots__ 使用@property 多重继承 定制类  __iter__ __getattr__ __call__   枚举类 待解决问题    特点 123</description>
    </item>
    
    <item>
      <title>Js Dom</title>
      <link>https://Lu0key.github.io/post/js-dom/</link>
      <pubDate>Thu, 21 Jan 2021 14:41:37 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/js-dom/</guid>
      <description>DOM DOM 树   DOM
 DOM 树 获取DOM元素 元素的属性 操作元素类名 操作文本内容 全选 选项卡 返回顶部 操作元素样式 DOM节点 获取节点 创建节点 插入节点 删除节点 替换节点 克隆节点 带有添加和删除功能的表格 动态创建表格 获取元素尺寸 获取元素偏移量 获取浏览器窗口尺寸 元素的常用事件 二级菜单渲染 选择器    doucument object model文档对象模型
  操作页面元素的属性与方法
  DOM树
  DOM 的顶级是 document，可能会有更高的节点window，看情况
  可以操作各种标签，文本，属性， 样式
  获取DOM元素  非常规标签  html/head/body  document.documentElement document.head document.body     常规标签  能用常规标签的方法去获取非常规标签，知识一般不这样用   getElementById()  语法：查找范围.</description>
    </item>
    
    <item>
      <title>Test Mathjax</title>
      <link>https://Lu0key.github.io/post/test-mathjax/</link>
      <pubDate>Thu, 21 Jan 2021 13:37:06 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/test-mathjax/</guid>
      <description>测试数学公式 行内公式: $a^2+b^2=c^2$
块状公式: $$ E=mc^2 $$
显示公式参考：https://note.qidong.name/2018/03/hugo-mathjax/</description>
    </item>
    
    <item>
      <title>First Blog</title>
      <link>https://Lu0key.github.io/post/first-blog/</link>
      <pubDate>Thu, 21 Jan 2021 11:15:13 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/first-blog/</guid>
      <description>Hello world 第一篇Hugo博客
下载主题
git clone https://github.com/lxndrblz/m10c.git themes/m10c  hugo 本地启动
hugo server -t themename --bulidDrafts hugo 创建新文章
hugo new post/blogname.md 推到Github远端服务器 创建名为 [github用户名].github.io 的仓库
blog目录下
hugo --theme=m10c --baseUrl=&amp;#34;https://Lu0key.github.io/&amp;#34; --buildDrafts 会生成一个public文件夹，进入该文件夹
cd public 初始化git仓库
git init 将所有文件添加入暂存区
git add . 将git仓库和云端仓库关联
git remote add [shortname] [url] 比如我的就是
git remote add origin https://github.com/Lu0key/Lu0key.github.io.git 最后推至云端
git push -u origin master  之后修改博客后，再推到GitHub上需要
hugo --theme=m10c --baseUrl=&amp;#34;https://Lu0key.github.io/&amp;#34; --buildDrafts cd public git add . git commit -m &amp;#34;message&amp;#34; git push </description>
    </item>
    
  </channel>
</rss>
