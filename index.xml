<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>洛七的摸鱼池塘</title>
    <link>https://Lu0key.github.io/</link>
    <description>Recent content on 洛七的摸鱼池塘</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 28 Feb 2021 18:37:37 +0800</lastBuildDate><atom:link href="https://Lu0key.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Python Wr Excel</title>
      <link>https://Lu0key.github.io/post/python-wr-excel/</link>
      <pubDate>Sun, 28 Feb 2021 18:37:37 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/python-wr-excel/</guid>
      <description>Python 处理excel 老师需要找出哪些同学在网上填了返校申请，因为有几百个人，所以比较难以肉眼看出来
这里我们假设填了信息的人可以导出名字，和整个年级的名单
这样我们就有两个表了，代码如下
import xlrd # 总的人名 name_set = [] # 填报的人 name_data = [] # 没填报的人 other = [] set_excel = xlrd.open_workbook(&amp;#39;C:\\Users\\Luokey\\Desktop\\set.xlsx&amp;#39;) set_sheet = set_excel.sheets()[0] print(set_sheet.name) print(&amp;#34;=============&amp;#34;) # 这里实际上是从第二行开始，到第一列的最后一个元素 for i in range(1,len(set_sheet.col_slice(0, start_rowx=0, end_rowx=None))): name = set_sheet.cell_value(i, 0) name_set.append(name) print(name_set) print(len(name_set)) data_excel = xlrd.open_workbook(&amp;#39;C:\\Users\\Luokey\\Desktop\\data.xlsx&amp;#39;) data_sheet = data_excel.sheets()[0] print(&amp;#34;=============&amp;#34;) # 这里实际上是从第二行开始，到第一列的最后一个元素 for i in range(1,len(data_sheet.col_slice(0, start_rowx=0, end_rowx=None))): name = data_sheet.cell_value(i, 0) name_data.append(name) print(&amp;#34;======没提交的名单=======&amp;#34;) for name in name_set: if name not in name_data: print(name) other.</description>
    </item>
    
    <item>
      <title>Spring5</title>
      <link>https://Lu0key.github.io/post/spring5/</link>
      <pubDate>Wed, 17 Feb 2021 22:18:45 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/spring5/</guid>
      <description>Spring Spring 简介  Spring理念：使现有的技术 更加容易使用，本身是一个大杂烩  SSH：Struct2+Spring+Hibernate
SSM：SpringMVC+Spring+Mybatis
官网：https://spring.io/projects/spring-framework
官方下载地址：https://repo.spring.io/release/org/springframework/spring/ Github：https://github.com/spring-projects/spring-framework
&amp;lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-webmvc&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;5.2.12.RELEASE&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-jdbc --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-jdbc&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;5.2.12.RELEASE&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; 优点  Spring是一个开源的免费的框架(容器) Spring是一个轻量级、非入侵式的框架 控制反转(IOC)，面向切面编程(AOP) 支持事务的处理，对框架整合的支持  总结：Spring是一个轻量级的控制反转(IOC)和面向切面变成(AOP)的框架！
组成 拓展  SpringBoot  一个快速开发的脚手架 基于SpringBoot可以快速地开发单个微服务、 约定大于配置   SpringCloud  SpringCloud 是基于 SpringBoot实现的    因为现在大多数公司都在使用SpringBoot进行快速开发，学习SpingBoot的前提，需要完全掌握Spring和SpringMVC。承上启下的作用
弊端：发展了太久之后，违背了原来的理念，配置十分繁琐，人称“配置地狱”
IOC理论推导  UserDao接口 UserDaoImpl 实现类 UserService 业务接口 UserServiceImpl 业务实现  在我们之前的业务中，用户的需求可能会影响我们原来的代码，我们需要根据用户的需求去修改原代码，如果程序代码量十分大，修改一次的成本十分高昂
我们使用一个Set接口实现，已经发生了革命性的变化
private UserDao userDao; public void setUserDao(UserDao userdao) { this.</description>
    </item>
    
    <item>
      <title>Mybatis</title>
      <link>https://Lu0key.github.io/post/mybatis/</link>
      <pubDate>Mon, 15 Feb 2021 22:05:30 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/mybatis/</guid>
      <description>MyBatis MyBatis官网
简介 什么是MaBatis？  MyBatis 是一款优秀的持久层框架 它支持自定义 SQL、存储过程以及高级映射。 MyBatis 免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作。 MyBatis 可以通过简单的 XML 或注解来配置和映射原始类型、接口和 Java POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。  如何获得MyBatis？
 github maven  &amp;lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.mybatis&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;mybatis&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;3.5.2&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; 持久化 数据持久化
 持久化就是将程序的数据在持久状态和瞬时状态转化的过程 内存：断电即失 数据库(JDBC)、IO文件持久化  为什么需要持久化？
 有一些数据，不能让他丢掉 内存太贵了  持久层  完成持久化工作的代码块 层界限十分明显  为什么需要MyBatis？  方便 传统的JDBC代码太复杂了。简化，框架 帮助程序员将数据存入到数据库中 不用MyBatis也可以，MyBatis更容易上手。技术没有高低之分 优点  sql和代码分离 更容易单元测试 提供xml标签，支持编写动态sql    最重要的一点：使用的人多</description>
    </item>
    
    <item>
      <title>王道考研 数据结构 串</title>
      <link>https://Lu0key.github.io/post/%E7%8E%8B%E9%81%93%E8%80%83%E7%A0%94-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%B8%B2/</link>
      <pubDate>Sat, 06 Feb 2021 22:10:51 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/%E7%8E%8B%E9%81%93%E8%80%83%E7%A0%94-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%B8%B2/</guid>
      <description>串  串  定义 存储结构  顺序存储 链式存储   基本操作  求子串 比较字符串 定位操作   朴素模式匹配算法 KMP 算法 KMP算法优化    定义 串，即字符串（String）是由零个或者多个字符组成的有限序列。一般记为 S = &amp;lsquo;a1a2&amp;hellip;a_n&amp;rsquo; ($n\geqslant0$)
其中，S是串名，单引号括起来的字符序列是串的值；$a_i$可以是字母、数字或者其他字符；串中字符的个数n称为串的长度。n=0 时的串称为空串（用 $\varnothing$ 表示）
字串：串中任意个连续的字符组成的子序列
主串：包含字串的串
字符在主串中的位置：字符在串中的序号
字串在主串中的位置：字串的第一个字符在主串中的位置
位序是从1开始，而不是0开始
串是一种特殊的线性表，数据元素之间呈线性关系
串的数据对象限定为字符集（如中文字符、英文字符、数字字符、标点字符等）
串的基本操作，如增删改查通常以字串为操作对象
串的基本操作
 StrAssign(&amp;amp;T, chars)：赋值操作，把串T赋值为chars StrCopy(&amp;amp;T, S)：复制操作。由串S复制得到串T StrEmpty(S)：判空操作。若S为空串，则返回true，否则返回false StrLength(S)：求串长，返回串S的元素个数 ClearString(&amp;amp;S)：清空操作。将S清为空串 DestroyString(&amp;amp;S)：销毁串。将串S销毁，回收存储空间 Concat(&amp;amp;T, S1, S2)：串联接。用T返回由S1和S2联接而成的新串 SubString(&amp;amp;sub, S, pos, len)：求字串，用sub但会串S的第pos个字符起长度为len的子串 Index(S, T)：定位操作。若主串S中存在与串T值相同的子串，则返回它在主串S中第一次出现的位置；否则函数值为0 StrCompare(S, T)：比较操作。若S&amp;gt;T，则返回值&amp;gt;0，若S=T，则返回值=0，若S&amp;lt; T，则返回值&amp;lt;0  这个比较是一个字符一个字符比较的，那字符怎么比较呢？
ASCII字符编码，将数字与字符一一对应，因此比较字符实际上就是比较字符对应的数字
乱码问题：
不同的编码规则可能会导致乱码</description>
    </item>
    
    <item>
      <title>王道考研 数据结构 栈和队列</title>
      <link>https://Lu0key.github.io/post/%E7%8E%8B%E9%81%93%E8%80%83%E7%A0%94-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/</link>
      <pubDate>Sat, 06 Feb 2021 22:08:19 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/%E7%8E%8B%E9%81%93%E8%80%83%E7%A0%94-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/</guid>
      <description>栈和队列  栈和队列  定义 顺序栈  顺序栈-进栈 顺序表-出栈 顺序栈-读栈 顺序栈-共享栈 栈的链式实现   队列  队列-顺序存储 队列-入队 队列-出队 队列的链式实现 双端队列   栈-括号匹配 栈-表达式求值  原理 代码   栈的应用-递归 队列的应用 特殊矩阵的压缩存储  对称矩阵 三角矩阵 三对角矩阵 稀疏矩阵      定义 栈(stack) 是只允许一端进行插入或删除操作的线性表（是同一端）.
重要术语
 栈顶 栈底 空栈  特点：LIFO（Last In First Out）后进的先出
基本操作
 InitStack(&amp;amp; S)：初始化栈。构造一个空栈S，分配内存空间。 DestroyStack(&amp;amp; S)：销毁栈。销毁并释放栈S所占的内存空间。 Push(&amp;amp;S, x)：进栈，若栈S未满，则将x加入使之成为新栈顶。 Pop(&amp;amp;S, &amp;amp;x)：出栈，若栈S非空，则弹出栈顶元素，并用x返回 GetTop(S, &amp;amp;x)：读栈顶元素。若栈S非空，则用x返回栈顶元素  栈的差一般只访问栈顶元素   StackEmpty(S)：判断一个栈S是否为空，若为空，则返回true，否则返回false。  常考题型：判断合法的出栈的顺序（要满足先进后出，后进先出）</description>
    </item>
    
    <item>
      <title>王道考研 数据结构 线性表</title>
      <link>https://Lu0key.github.io/post/%E7%8E%8B%E9%81%93%E8%80%83%E7%A0%94-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%80%A7%E8%A1%A8/</link>
      <pubDate>Sat, 06 Feb 2021 21:43:51 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/%E7%8E%8B%E9%81%93%E8%80%83%E7%A0%94-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%80%A7%E8%A1%A8/</guid>
      <description>线性表  线性表  定义 基本操作  其他常用操作 注 为什么需要实现基本操作   顺序表  顺序表的实现-静态分配 顺序表的实现-动态分配 特点 顺序表-插入 顺序表-删除 顺序表-按位查找 顺序表-按值查找 按值查找的时间复杂度   链表  定义 单链表-初始化 单链表-按位序插入 单链表-后插操作 单链表-前插操作 单链表-按位序删除 单链表-删除指定结点 单链表-按位查找 单链表-按值查找 单链表-获取长度 单链表-尾插法 单链表-头插法   双链表  初始化 双链表-插入 双链表-删除 双链表-遍历   循环链表  循环单链表 循环双链表   静态链表  静态链表-定义   顺序表和链表的比较    定义 线性表(Linear List)是具有相同数据类型的 n ($n\geqslant0$) 个数据元素的有限序列，其中 n 为表长，当 n=0 时线性表是一个空表。若用 L 命名线性表，则一般表示为 $$ L=(a_1, a_2,\cdots,a_j, a_{j+1},\cdots,a_n) $$ 相同：意味着每个数据元素所占空间一样大</description>
    </item>
    
    <item>
      <title>Git Commit错误修改</title>
      <link>https://Lu0key.github.io/post/git-commit%E9%94%99%E8%AF%AF%E4%BF%AE%E6%94%B9/</link>
      <pubDate>Sat, 06 Feb 2021 21:34:56 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/git-commit%E9%94%99%E8%AF%AF%E4%BF%AE%E6%94%B9/</guid>
      <description>git commit错误修改 在 git commit -m &amp;quot;message&amp;quot; 时，我们有时会不小心把 message 的信息写错，要怎么修改呢？
这时候分为两种情况
 已经git push了 还没git push  还没push 这种情况比较简单，直接使用
git commit --amend 进入vim界面，按i进入insert模式，修改完错误的message后，按esc，输入:wq保存退出即可，最后再push
通过
git log 可以看到记录是修改后的message
已经push 这种情况命令比较多一点，但是也是能够解决
先用 git log 查看是哪一次commit 的message需要修改，比如我是倒数第二次和第三次的commit都有一点问题，那么我们先修改倒数第二次的，先使用命令
git rebase -i HEAD^ 进入vim界面，按i进入insert模式，将需要修改message的那一行的pick改成edit，将message改成正确的，再按esc，输入 :wq 保存退出
输入命令
git commit --amend 同样进入vim界面，按i进入insert模式，将第一行错误的message修改为正确的message，退出保存流程和上面一样
rebase确认命令
git rebase --continue 最后强制push一下即可
git push -f 查看git log会发现已经修改好了</description>
    </item>
    
    <item>
      <title>上交考研数分一题</title>
      <link>https://Lu0key.github.io/post/%E4%B8%8A%E4%BA%A4%E8%80%83%E7%A0%94%E6%95%B0%E5%88%86%E4%B8%80%E9%A2%98/</link>
      <pubDate>Fri, 22 Jan 2021 20:49:16 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/%E4%B8%8A%E4%BA%A4%E8%80%83%E7%A0%94%E6%95%B0%E5%88%86%E4%B8%80%E9%A2%98/</guid>
      <description>2021 上海交通大学硕士研究生入学考试数学分析第7题
求极限
$$ \lim_{x\to\infty}\dfrac{(1+\frac{1}{x})^x-e}{\sin\dfrac{1}{x}}
$$
Solution: $$\begin{aligned} &amp;amp;\lim_{x\to\infty}\dfrac{(1+\frac{1}{x})^x-e}{\sin\dfrac{1}{x}}\\
=&amp;amp;e\lim_{x\to\infty}\dfrac{e^{x\ln(1+\frac{1}{x})-1}-1}{\dfrac{1}{x}}\\
=&amp;amp;e\lim_{x\to\infty}x[x\ln(1+\dfrac{1}{x})-1]\\
=&amp;amp;e\lim_{x\to\infty}x[x(\dfrac{1}{x}-\dfrac{1}{2x^2}+o(\dfrac{1}{x^3}))-1]\\
=&amp;amp;-\dfrac{e}{2} \end{aligned}$$</description>
    </item>
    
    <item>
      <title>函数的不可积问题</title>
      <link>https://Lu0key.github.io/post/%E5%87%BD%E6%95%B0%E7%9A%84%E4%B8%8D%E5%8F%AF%E7%A7%AF%E9%97%AE%E9%A2%98/</link>
      <pubDate>Fri, 22 Jan 2021 20:32:15 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/%E5%87%BD%E6%95%B0%E7%9A%84%E4%B8%8D%E5%8F%AF%E7%A7%AF%E9%97%AE%E9%A2%98/</guid>
      <description>函数的“不可积”问题 这里的“不可积”指的是原函数不能表示成初等函数的形式
基本是搬运，但是忘记出处了
常见的“不可积”的例子 三角积分类 $\displaystyle\int\dfrac{\sin x}{x^n}\text{d}x,;\int\dfrac{\cos x}{x^n}\text{d}x,;\int\dfrac{\tan x}{x^n},;\int x^n\tan x\text{d}x$
$\displaystyle\int\left(\dfrac{x}{\sin x}\right)^n\text{d}x,;\int\left(\dfrac{x}{\cos x}\right)^n\text{d}x,;\int\left(\dfrac{x}{\tan x}\right)^n\text{d}x$
菲涅尔积分类型 $\displaystyle\int\sin x^2\text{d}x,;\int\cos x^2\text{d}x,;\int\tan x^2\text{d}x$
贝塞尔积分 $\displaystyle\int\cos(x\sin x)\text{d}x$
Laplace 积分 $\displaystyle\int\dfrac{\cos\beta x}{1+x^2}\text{d}x$
高斯积分类 $\displaystyle\int e^{ax^2+bx+c}\text{d}x$
$\displaystyle\int x^ne^{ax^2+bx+c}\text{d}x$
指数积分类型 $\displaystyle\int\dfrac{e^{ax}}{x}\text{d}x,;\int\dfrac{e^{ax}}{a+x^n}\text{d}x,;\int\dfrac{x^n}{1\pm e^x}\text{d}x$
对数积分类型 $\displaystyle\int\dfrac{\text{d}x}{\ln x},;\int\dfrac{\ln x\text{d}x}{1+x^2},;\int\ln\sin x\text{d}x,;\int\ln\cos x\text{d}x,;\int\ln\tan x\text{d}x$
$\displaystyle\int\ln(a+b\sin x)\text{d}x,;\int\ln(a+b\cos x)\text{d}x,\int\ln(a+b\tan x)\text{d}x$
$\displaystyle\int\ln\ln\sin x\text{d}x,;\int\ln\ln\cos x\text{d}x,;\int\ln\ln\tan x\text{d}x$
椭圆积分类 $\displaystyle\int\dfrac{1}{\sqrt{1-k^2\sin^2x}}\text{d}x,;\int\sqrt{1-k^2\sin^2x}\text{d}x$
$\displaystyle\int\dfrac{1}{\sqrt{1\pm x^n}}\text{d}x,;\int\sqrt{1\pm x^n}\text{d}x;(n\geqslant3)$
常见的特殊函数 Beta 函数 $\displaystyle\text{B}(p,q)=\int_0^1x^{p-1}(1-x)^{q-1}\text{d}x=\dfrac{\Gamma(p)\Gamma(q)}{\Gamma(p+q)},;(p,q&amp;gt;0)$
Gamma 函数 $\displaystyle\Gamma(s)=\int_0^{+\infty}x^{s-1}e^{-x}\text{d}x,;(s&amp;gt;0)$
误差函数 $\displaystyle\text{erf}(x)=\dfrac{2}{\sqrt{\pi}}\int_0^xe^{-x^2}\text{d}x$
互补误差函数 $\displaystyle \text{erfc}(x)=1-\text{erf}(x)=\dfrac{2}{\sqrt{\pi}}\int_x^{+\infty}e^{-x^2}\text{d}x$
zeta 函数 $\displaystyle\zeta(s)=\sum_{k=1}^{\infty}\dfrac{1}{k^s}$</description>
    </item>
    
    <item>
      <title>王道考研 数据结构 绪论</title>
      <link>https://Lu0key.github.io/post/%E7%8E%8B%E9%81%93%E8%80%83%E7%A0%94-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BB%AA%E8%AE%BA/</link>
      <pubDate>Fri, 22 Jan 2021 19:09:34 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/%E7%8E%8B%E9%81%93%E8%80%83%E7%A0%94-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BB%AA%E8%AE%BA/</guid>
      <description>绪论 学什么  如何用程序代码把现实世界的问题信息化 如何用计算机高效地处理这些信息从而创造价值  基本概念 数据  数据是信息的载体，是描述客观事物属性的数、字符及所有能输入到计算机中并被计算机程序识别和处理的符号的集合。数据是计算机程序加工的原料。
 数据元素、数据项  数据元素是数据的基本单位，通常作为一个整体进行考虑和处理。
一个数据元素可由若干个数据项组成，数据项是构成数据元素的不可分割的最小单位。
 数据结构、数据对象  结构 是各个元素之间的关系
数据结构 是相互之间存在一种或者多种特定关系的数据元素的集合。
数据对象 是具有相同性质的数据元素的集合，是数据的一个子集。
 数据结构的三要素   逻辑结构
 集合  各个元素同属一个集合，别无其他关系   线性结构  数据元素之间是一对一的关系，除了第一个元素，所有元素都有唯一前驱，除了最后一个元素，所有元素都有唯一后继   树形结构  数据元素之间是一对多的关系   图状结构（网状结构）  数据元素之间是多对多的关系      物理结构（存储结构）
 顺序存储  存储位置相邻   链式存储  借助元素存储地址的指针来辨识元素之间的逻辑关系   索引存储  索引表，索引表中的每项称为索引项(关键字，地址)   散列存储  通过元素的关键字直接计算出该元素的存储地址，又称哈希（Hash）存储      数据的运算</description>
    </item>
    
    <item>
      <title>Euler积分</title>
      <link>https://Lu0key.github.io/post/euler%E7%A7%AF%E5%88%86/</link>
      <pubDate>Fri, 22 Jan 2021 16:04:02 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/euler%E7%A7%AF%E5%88%86/</guid>
      <description>Beta 函数 形如
$\displaystyle \text{B}(p,q)=\int_0^1x^{p-1}(1-x)^{q-1}\text{d}x$
的含参变量积分称为 Beta 函数，或 第一类 Euler 积分。
Beta 函数 $\text{B}(p,q)$ 的定义域为 $(0,+\infty)\times(0,+\infty)$
性质 1 连续性 $\text{B}(p,q)$ 在 $(0,+\infty)\times(0,+\infty)$ 上连续.
2 对称性 $\text{B}(p,q)=\text{B}(q,p),;p&amp;gt;0,;q&amp;gt;0$
3 递推公式 $\text{B}(p,q)=\dfrac{q-1}{p+q-1}\text{B}(p,q-1),;p&amp;gt;0,;q&amp;gt;1$
可由对称性与递推公式得到，
当 $p&amp;gt;1,;q&amp;gt;1$ 时，有
$\text{B}(p,q)=\dfrac{(p-1)(q-1)}{(p+q-1)(p+q-2)}\text{B}(p-1,q-1)$
其他表示 1 作变量代换 $x=\cos^2\varphi$，得到
$\text{B}(p,q)=2\displaystyle\int_0^{\frac\pi2}\cos^{2p-1}\varphi\sin^{2q-1}\varphi;\text{d}\varphi$
易知
$\text{B}\left(\dfrac{1}{2},\dfrac{1}{2}\right)=\pi$
2 作变量代换 $x=\dfrac{1}{1+t}$，得到
$\begin{aligned} \text{B}(p,q)=&amp;amp;\int_0^{+\infty}\dfrac{t^{q-1}}{(1+t)^{p+q}}\text{d}t\
=&amp;amp;\int_0^{1}\dfrac{t^{q-1}}{(1+t)^{p+q}}\text{d}t+\int_1^{+\infty}\dfrac{t^{q-1}}{(1+t)^{p+q}}\text{d}t \end{aligned}$
对后一个积分作变量代换 $t=\dfrac{1}{u}$，得到
$\displaystyle\int_1^{+\infty}\dfrac{t^{q-1}}{(1+t)^{p+q}}\text{d}t=\int_0^1\dfrac{u^{p-1}}{(1+u)^{p+q}}\text{d}u$
于是
$\displaystyle\text{B}(p,q)=\int_0^1\dfrac{t^{q-1}+t^{p-1}}{(1+t)^{p+q}}\text{d}t$
 Gamma 函数 形如
$\displaystyle\Gamma(s)=\int_0^{+\infty}x^{s-1}e^{-x}\text{d}x$
的含参变量积分称为 Gamma 函数 或 第二类 Euler 积分.
$\Gamma(s)$ 的定义域为 $(0,+\infty)$
性质 1 连续性与可导性 $\Gamma(s)$ 在 $(0,+\infty)$ 上连续且任意阶可导.</description>
    </item>
    
    <item>
      <title>Python Flask 入门</title>
      <link>https://Lu0key.github.io/post/python-flask-%E5%85%A5%E9%97%A8/</link>
      <pubDate>Fri, 22 Jan 2021 16:01:50 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/python-flask-%E5%85%A5%E9%97%A8/</guid>
      <description>Flask  Flask  特点 list  example   tuple(元组)  “可变的” tuple  tips     循环  range() continue  example   break   dict set  常用函数   定义函数  tips 空函数 参数检查 多个返回值 默认参数  坑   可变参数 关键字参数 命名关键词参数   参数组合还没看&amp;hellip;..  递归函数  tips   尾递归 切片 Slice 切片   Iteration 迭代  如何判断一个对象是否可迭代 如何同时迭代索引和元素   列表生成式 generator 生成器 迭代器 高阶函数 map/reduce filter sorted 返回函数 闭包(Closure) 匿名函数lambda 装饰器(Decorator) 偏函数 Partial function 模块 Module  作用域 安装第三方库   OOP 访问限制 继承和多态 获取对象信息 实例属性和类属性 使用__slots__ 使用@property 多重继承 定制类  __iter__ __getattr__ __call__   枚举类 待解决问题    特点 123</description>
    </item>
    
    <item>
      <title>Js Dom</title>
      <link>https://Lu0key.github.io/post/js-dom/</link>
      <pubDate>Thu, 21 Jan 2021 14:41:37 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/js-dom/</guid>
      <description>DOM DOM 树   DOM
 DOM 树 获取DOM元素 元素的属性 操作元素类名 操作文本内容 全选 选项卡 返回顶部 操作元素样式 DOM节点 获取节点 创建节点 插入节点 删除节点 替换节点 克隆节点 带有添加和删除功能的表格 动态创建表格 获取元素尺寸 获取元素偏移量 获取浏览器窗口尺寸 元素的常用事件 二级菜单渲染 选择器    doucument object model文档对象模型
  操作页面元素的属性与方法
  DOM树
  DOM 的顶级是 document，可能会有更高的节点window，看情况
  可以操作各种标签，文本，属性， 样式
  获取DOM元素  非常规标签  html/head/body  document.documentElement document.head document.body     常规标签  能用常规标签的方法去获取非常规标签，知识一般不这样用   getElementById()  语法：查找范围.</description>
    </item>
    
    <item>
      <title>Test Mathjax</title>
      <link>https://Lu0key.github.io/post/test-mathjax/</link>
      <pubDate>Thu, 21 Jan 2021 13:37:06 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/test-mathjax/</guid>
      <description>测试数学公式 行内公式: $a^2+b^2=c^2$
块状公式: $$ E=mc^2 $$
显示公式参考：https://note.qidong.name/2018/03/hugo-mathjax/</description>
    </item>
    
    <item>
      <title>First Blog</title>
      <link>https://Lu0key.github.io/post/first-blog/</link>
      <pubDate>Thu, 21 Jan 2021 11:15:13 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/first-blog/</guid>
      <description>Hello world 第一篇Hugo博客
下载主题
git clone https://github.com/lxndrblz/m10c.git themes/m10c  hugo 本地启动
hugo server -t themename --bulidDrafts hugo 创建新文章
hugo new post/blogname.md 推到Github远端服务器 创建名为 [github用户名].github.io 的仓库
blog目录下
hugo --theme=m10c --baseUrl=&amp;#34;https://Lu0key.github.io/&amp;#34; --buildDrafts 会生成一个public文件夹，进入该文件夹
cd public 初始化git仓库
git init 将所有文件添加入暂存区
git add . 将git仓库和云端仓库关联
git remote add [shortname] [url] 比如我的就是
git remote add origin https://github.com/Lu0key/Lu0key.github.io.git 最后推至云端
git push -u origin master  之后修改博客后，再推到GitHub上需要
hugo --theme=m10c --baseUrl=&amp;#34;https://Lu0key.github.io/&amp;#34; --buildDrafts cd public git add . git commit -m &amp;#34;message&amp;#34; git push </description>
    </item>
    
  </channel>
</rss>
