<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>leetcode on 洛七的摸鱼池塘</title>
    <link>https://Lu0key.github.io/tags/leetcode/</link>
    <description>Recent content in leetcode on 洛七的摸鱼池塘</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 23 Mar 2021 14:50:23 +0800</lastBuildDate><atom:link href="https://Lu0key.github.io/tags/leetcode/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Leetcode 560 和为K的子数组</title>
      <link>https://Lu0key.github.io/post/leetcode-560-subarray-sum-equals-k/</link>
      <pubDate>Tue, 23 Mar 2021 14:50:23 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/leetcode-560-subarray-sum-equals-k/</guid>
      <description>和为K的子数组(Subarray Sum Equals K) 给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数。
示例 1 :
输入:nums = [1,1,1], k = 2 输出: 2 , [1,1] 与 [1,1] 为两种不同的情况。 说明 :
 数组的长度为 [1, 20,000]。 数组中元素的范围是 [-1000, 1000] ，且整数 k 的范围是 [-1e7, 1e7]。  int subarraySum(int* nums, int numsSize, int k){ int count = 0; for(int i =0;i&amp;lt;numsSize;i++){ int sum = 0; for(int j=i;j&amp;lt;numsSize;j++){ sum+=nums[j]; if(sum == k){ count++; } } } return count; } O(n^2) 会超时哦</description>
    </item>
    
    <item>
      <title>Leetcode 1008 前序遍历构造二叉搜索树</title>
      <link>https://Lu0key.github.io/post/leetcode-1008-construct-binary-search-tree-from-preorder-traversal/</link>
      <pubDate>Tue, 23 Mar 2021 14:47:50 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/leetcode-1008-construct-binary-search-tree-from-preorder-traversal/</guid>
      <description>前序遍历构造二叉搜索树(Construct Binary Search Tree from Preorder Traversal) 返回与给定前序遍历 preorder 相匹配的二叉搜索树（binary search tree）的根结点。
(回想一下，二叉搜索树是二叉树的一种，其每个节点都满足以下规则，对于 node.left 的任何后代，值总 &amp;lt; node.val，而 node.right 的任何后代，值总 &amp;gt; node.val。此外，前序遍历首先显示节点 node 的值，然后遍历 node.left，接着遍历 node.right。）
题目保证，对于给定的测试用例，总能找到满足要求的二叉搜索树。
示例：
输入：[8,5,1,7,10,12] 输出：[8,5,10,1,7,null,12] 提示：
 1 &amp;lt;= preorder.length &amp;lt; = 100 1 &amp;lt;= preorder[i] &amp;lt;= 10^8 preorder 中的值互不相同  /** * Definition for a binary tree node. * struct TreeNode { * int val; * struct TreeNode *left; * struct TreeNode *right; * }; */ struct TreeNode* bstFromPreorderRanged(int* preorder, int start, int end){ if(start == end) return NULL; struct TreeNode* root = malloc(sizeof(struct TreeNode)); root-&amp;gt;val = preorder[start]; int i = start+1; while (i&amp;lt;end &amp;amp;&amp;amp; preorder[i]&amp;lt;root-&amp;gt;val){ i++; } root-&amp;gt;left = bstFromPreorderRanged(preorder, start+1, i); root-&amp;gt;right = bstFromPreorderRanged(preorder,i,end); return root; } struct TreeNode* bstFromPreorder(int* preorder, int preorderSize){ return bstFromPreorderRanged(preorder,0,preorderSize); } 提高效率</description>
    </item>
    
    <item>
      <title>Leetcode 33 搜索旋转排序数组</title>
      <link>https://Lu0key.github.io/post/leetcode-33-search-in-rotated-sorted-array/</link>
      <pubDate>Tue, 23 Mar 2021 14:44:28 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/leetcode-33-search-in-rotated-sorted-array/</guid>
      <description>搜索旋转排序数组(Search in Rotated Sorted Array) 整数数组 nums 按升序排列，数组中的值 互不相同 。
在传递给函数之前，nums 在预先未知的某个下标 k（0 &amp;lt;= k &amp;lt; nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。
给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的索引，否则返回 -1 。
示例 1：
输入：nums = [4,5,6,7,0,1,2], target = 0 输出：4 示例 2：
输入：nums = [4,5,6,7,0,1,2], target = 3 输出：-1 示例 3：
输入：nums = [1], target = 0 输出：-1 提示：</description>
    </item>
    
    <item>
      <title>Leetcode 64 最小路径和</title>
      <link>https://Lu0key.github.io/post/leetcode-64-minimum-path-sum/</link>
      <pubDate>Tue, 23 Mar 2021 14:41:59 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/leetcode-64-minimum-path-sum/</guid>
      <description>最小路径和(Minimum Path Sum) 给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。
说明： 每次只能向下或者向右移动一步。
示例 1： 输入：grid = [[1,3,1],[1,5,1],[4,2,1]] 输出：7 解释：因为路径 1→3→1→1→1 的总和最小。 示例 2：
输入：grid = [[1,2,3],[4,5,6]] 输出：12 提示：
 m == grid.length n == grid[i].length 1 &amp;lt;= m, n &amp;lt;= 200 0 &amp;lt;= grid[i][j] &amp;lt;= 100  int minPartialPathSum(int** grid,int** path,int ROWS,int COLS,int i,int j){ if (path[i][j]!=-1){ return path[i][j]; } int right = grid[i][j]; int down = grid[i][j]; if (i==ROWS-1&amp;amp;&amp;amp;j==COLS-1){ path[i][j] = grid[i][j]; return grid[i][j]; } if(j&amp;lt;COLS-1){ right +=minPartialPathSum(grid,path,ROWS,COLS,i,j+1); } if(i&amp;lt;ROWS-1){ down +=minPartialPathSum(grid,path,ROWS,COLS,i+1,j); } if (j==COLS-1){ path[i][j] = down; return down; } if (i==ROWS-1){ path[i][j] = right; return right; } int re = right&amp;lt;down?</description>
    </item>
    
    <item>
      <title>Leetcode 200 岛屿数量</title>
      <link>https://Lu0key.github.io/post/leetcode-200-number-of-islands/</link>
      <pubDate>Tue, 23 Mar 2021 14:39:02 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/leetcode-200-number-of-islands/</guid>
      <description>岛屿数量(Number of Islands) 给你一个由 &#39;1&#39;（陆地）和 &#39;0&#39;（水）组成的的二维网格，请你计算网格中岛屿的数量。
岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。
此外，你可以假设该网格的四条边均被水包围。
示例 1：
输入：grid = [ [&amp;quot;1&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;0&amp;quot;], [&amp;quot;1&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;0&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;0&amp;quot;], [&amp;quot;1&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;0&amp;quot;,&amp;quot;0&amp;quot;,&amp;quot;0&amp;quot;], [&amp;quot;0&amp;quot;,&amp;quot;0&amp;quot;,&amp;quot;0&amp;quot;,&amp;quot;0&amp;quot;,&amp;quot;0&amp;quot;] ] 输出：1 示例 2：
输入：grid = [ [&amp;quot;1&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;0&amp;quot;,&amp;quot;0&amp;quot;,&amp;quot;0&amp;quot;], [&amp;quot;1&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;0&amp;quot;,&amp;quot;0&amp;quot;,&amp;quot;0&amp;quot;], [&amp;quot;0&amp;quot;,&amp;quot;0&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;0&amp;quot;,&amp;quot;0&amp;quot;], [&amp;quot;0&amp;quot;,&amp;quot;0&amp;quot;,&amp;quot;0&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;1&amp;quot;] ] 输出：3 提示：
 m == grid.length n == grid[i].length 1 &amp;lt;= m, n &amp;lt;= 300 grid[i][j] 的值为 &#39;0&#39; 或 &#39;1&#39;  我们找到一个岛屿之后就把他清零，当所有数字都为0时，就表示结束了
const char WATER = &amp;#39;0&amp;#39;; const char LAND = &amp;#39;1&amp;#39;; const char NEW = &amp;#39;X&amp;#39;; const char USED = &amp;#39;O&amp;#39;; void floodFill(char** grid,int NUMBER_OF_ROWS,int NUMBER_OF_COLS,int i,int j){ if(i&amp;lt;0 || i&amp;gt;=NUMBER_OF_ROWS || j&amp;lt;0 || j&amp;gt;=NUMBER_OF_COLS||grid[i][j]!</description>
    </item>
    
    <item>
      <title>Leetcode 678 有效的括号字符串</title>
      <link>https://Lu0key.github.io/post/leetcode-678-valid-parenthesis-string/</link>
      <pubDate>Tue, 23 Mar 2021 14:30:43 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/leetcode-678-valid-parenthesis-string/</guid>
      <description>有效的括号字符串(Valid Parenthesis String) 给定一个只包含三种字符的字符串：（ ，） 和 *，写一个函数来检验这个字符串是否为有效字符串。有效字符串具有如下规则：
 任何左括号 ( 必须有相应的右括号 )。 任何右括号 ) 必须有相应的左括号 ( 。 左括号 ( 必须在对应的右括号之前 )。 * 可以被视为单个右括号 ) ，或单个左括号 ( ，或一个空字符串。 一个空字符串也被视为有效字符串。  示例 1:
输入: &amp;quot;()&amp;quot; 输出: True 示例 2:
输入: &amp;quot;(*)&amp;quot; 输出: True 示例 3:
输入: &amp;quot;(*))&amp;quot; 输出: True 注意:
 字符串大小将在 [1，100] 范围内。  bool checkVaildSubstring(char * s, int i, int j){ if(i &amp;gt; j) return true; if(s[i] == &amp;#39;)&amp;#39;) { return false; }else if( s[i] == &amp;#39;*&amp;#39;){ if (checkVaildSubstring(s, i+1,j)){ return true; } } for (int k=i+1;k&amp;lt;= j;k++){ if(s[k]==&amp;#39;)&amp;#39; || s[k] == &amp;#39;*&amp;#39;){ if(checkVaildSubstring(s,i+1,k-1) &amp;amp;&amp;amp; checkVaildSubstring(s,k+1,j)){ return true; } } } return false; } bool checkValidString(char * s){ return checkVaildSubstring(s,0,strlen(s)-1); } 这里会因为重复算相同的内容多次导致超时，因此我们可以用一个二维数组将算过的存起来，二维数组的i,j表示从索引i到索引j的这个子串是否计算过</description>
    </item>
    
    <item>
      <title>Leetcode 238 除自身以外数组的乘积</title>
      <link>https://Lu0key.github.io/post/leetcode-238-product-of-array-except-self/</link>
      <pubDate>Tue, 23 Mar 2021 14:27:37 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/leetcode-238-product-of-array-except-self/</guid>
      <description>除自身以外数组的乘积(Product of Array Except Self) 给你一个长度为 n 的整数数组 nums，其中 n &amp;gt; 1，返回输出数组 output ，其中 output[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积。
示例:
输入: [1,2,3,4] 输出: [24,12,8,6] 提示: 题目数据保证数组之中任意元素的全部前缀元素和后缀（甚至是整个数组）的乘积都在 32 位整数范围内。
说明: 请 不要使用除法，且在 O(n) 时间复杂度内完成此题。
进阶： 你可以在常数空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组不被视为额外空间。）
/** * Note: The returned array must be malloced, assume caller calls free(). */ int* productExceptSelf(int* nums, int numsSize, int* returnSize){ *returnSize = numsSize; int * result = malloc(sizeof(int)*numsSize); for (int i =0;i&amp;lt;numsSize;i++){ int left = 1; for(int j =0;j&amp;lt;=i-1;j++){ left *= nums[j]; } int right =1; for (int j =i+1;j&amp;lt;numsSize;j++){ right *=nums[j]; } result[i] = left*right; } return result; } int* productExceptSelf(int* nums, int numsSize, int* returnSize){ int *result = malloc(sizeof(int)*numsSize); int *lefts = malloc(sizeof(int)*numsSize); lefts[0]=1; for(int i =1;i&amp;lt;numsSize;i++){ lefts[i] = lefts[i-1]*nums[i-1]; } int *rights = malloc(sizeof(int)*numsSize); rights[numsSize-1]=1; for(int i =numsSize-2;i&amp;gt;=0;i--){ rights[i] = rights[i+1]*nums[i+1]; } // 这个for可以放在上面，right[i] 算完了就可以算result[i]了，然后少一个for循环  for (int i =0;i&amp;lt;numsSize;i++){ result[i] = lefts[i]*rights[i]; } *returnSize = numsSize; return result; } 题目问能不能不要额外的空间，然后返回的空间不算，因此我们先第一步简化</description>
    </item>
    
    <item>
      <title>Leetcode 525 连续数组</title>
      <link>https://Lu0key.github.io/post/leetcode-525-contiguous-array/</link>
      <pubDate>Tue, 23 Mar 2021 14:24:43 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/leetcode-525-contiguous-array/</guid>
      <description>连续数组(Contiguous Array) 给定一个二进制数组, 找到含有相同数量的 0 和 1 的最长连续子数组（的长度）。
示例 1:
输入: [0,1] 输出: 2 说明: [0, 1] 是具有相同数量0和1的最长连续子数组。 示例 2:
输入: [0,1,0] 输出: 2 说明: [0, 1] (或 [1, 0]) 是具有相同数量0和1的最长连续子数组。 注意: 给定的二进制数组的长度不会超过50000。
最粗暴的方式
int count0(int i,int j,int *nums) { int count = 0; for (int k =i; k&amp;lt;=j;k++){ if(nums[k] == 0){ count++; } } return count; } int count1(int i,int j,int *nums) { int count = 0; for (int k =i; k&amp;lt;=j;k++){ if(nums[k] == 1){ count++; } } return count; } int findMaxLength(int* nums, int numsSize){ int maxLength = 0; for (int i =0;i&amp;lt;numsSize;i++){ for(int j =i;j&amp;lt;numsSize;j++){ if(count0(i,j,nums) == count1(i,j,nums)){ int length = j-i+1; if (length &amp;gt; maxLength){ maxLength = length; } } } } return maxLength; } 但是这样会超时，毕竟O(n^3)</description>
    </item>
    
    <item>
      <title>Leetcode 1046 最后一块石头的重量</title>
      <link>https://Lu0key.github.io/post/leetcode-1046-last-stone-weight/</link>
      <pubDate>Tue, 23 Mar 2021 14:21:07 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/leetcode-1046-last-stone-weight/</guid>
      <description>最后一块石头的重量(Last Stone Weight) 有一堆石头，每块石头的重量都是正整数。
每一回合，从中选出两块 最重的 石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x &amp;lt;= y。那么粉碎的可能结果如下：
 如果 x == y，那么两块石头都会被完全粉碎； 如果 x != y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。  最后，最多只会剩下一块石头。返回此石头的重量。如果没有石头剩下，就返回 0。
示例：
输入：[2,7,4,1,8,1] 输出：1 解释： 先选出 7 和 8，得到 1，所以数组转换为 [2,4,1,1,1]， 再选出 2 和 4，得到 2，所以数组转换为 [2,1,1,1]， 接着是 2 和 1，得到 1，所以数组转换为 [1,1,1]， 最后选出 1 和 1，得到 0，最终数组转换为 [1]，这就是最后剩下那块石头的重量。 提示：
 1 &amp;lt;= stones.length &amp;lt;= 30 1 &amp;lt;= stones[i] &amp;lt;= 1000  int extractMax(int *stones, int stonesSize) { int max = stones[0]; // 获取最大数  for (int i=1;i&amp;lt;stonesSize;i++){ if (stones[i]&amp;gt;max){ max = stones[i]; } } // 将第一个最大数位置置为0  for(int i =0;i&amp;lt;stonesSize;i++){ if(stones[i] == max){ stones[i]=0; break; } } return max; } void insert(int *stones, int stonesSize, int value) { for (int i =0;i&amp;lt;stonesSize;i++){ if(stones[i] == 0){ stones[i] = value; break; } } } int lastStoneWeight(int* stones, int stonesSize){ while(true) { // 第一大  int y = extractMax(stones, stonesSize); // 第二大  int x = extractMax(stones, stonesSize); if(x == 0) { return y; } if(x!</description>
    </item>
    
    <item>
      <title>Leetcode 543 Diameter of Binary Tree</title>
      <link>https://Lu0key.github.io/post/leetcode-543-diameter-of-binary-tree/</link>
      <pubDate>Sat, 20 Mar 2021 13:26:27 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/leetcode-543-diameter-of-binary-tree/</guid>
      <description>二叉树的直径(Diameter of Binary Tree) 给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。
示例 : 给定二叉树
 1 / \ 2 3 / \ 4 5 返回 3, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。
注意：两结点之间的路径长度是以它们之间边的数目表示。
/** * Definition for a binary tree node. * struct TreeNode { * int val; * struct TreeNode *left; * struct TreeNode *right; * }; */ int maxDepth(struct TreeNode * root){ if (root == NULL) return 0; int leftMax = maxDepth(root-&amp;gt;left); int rightMax = maxDepth(root-&amp;gt;right); if(leftMax&amp;gt;rightMax){ return leftMax+1; } return rightMax+1; } int diameterOfBinaryTree(struct TreeNode* root){ if (root == NULL) return 0; int middle = maxDepth(root-&amp;gt;left) + maxDepth(root-&amp;gt;right); int left = diameterOfBinaryTree(root-&amp;gt;left); int right = diameterOfBinaryTree(root-&amp;gt;right); int max = middle; if (left &amp;gt; max){ max = left; } if(right &amp;gt; max){ max = right; } return max; } 二叉树的最大深度(Maximum Depth of Binary Tree) 给定一个二叉树，找出其最大深度。</description>
    </item>
    
    <item>
      <title>Leetcode 155 Min Stack</title>
      <link>https://Lu0key.github.io/post/leetcode-155-min-stack/</link>
      <pubDate>Sat, 20 Mar 2021 13:22:09 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/leetcode-155-min-stack/</guid>
      <description>最小栈(Min Stack) 设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。
push(x) —— 将元素 x 推入栈中。 pop() —— 删除栈顶的元素。 top() —— 获取栈顶元素。 getMin() —— 检索栈中的最小元素。  示例:
输入： [&amp;quot;MinStack&amp;quot;,&amp;quot;push&amp;quot;,&amp;quot;push&amp;quot;,&amp;quot;push&amp;quot;,&amp;quot;getMin&amp;quot;,&amp;quot;pop&amp;quot;,&amp;quot;top&amp;quot;,&amp;quot;getMin&amp;quot;] [[],[-2],[0],[-3],[],[],[],[]] 输出： [null,null,null,null,-3,null,0,-2] 解释： MinStack minStack = new MinStack(); minStack.push(-2); minStack.push(0); minStack.push(-3); minStack.getMin(); --&amp;gt; 返回 -3. minStack.pop(); minStack.top(); --&amp;gt; 返回 0. minStack.getMin(); --&amp;gt; 返回 -2. 提示：
 pop、top 和 getMin 操作总是在 非空栈 上调用。  C语言版:
/** * Your MinStack struct will be instantiated and called as such: * MinStack* obj = minStackCreate(); * minStackPush(obj, val); * minStackPop(obj); * int param_3 = minStackTop(obj); * int param_4 = minStackGetMin(obj); * minStackFree(obj); */ typedef struct { int * data; int * mins; int size; } MinStack; /** initialize your data structure here.</description>
    </item>
    
    <item>
      <title>Leetcode Backspace String Compare</title>
      <link>https://Lu0key.github.io/post/leetcode-backspace-string-compare/</link>
      <pubDate>Fri, 19 Mar 2021 17:42:46 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/leetcode-backspace-string-compare/</guid>
      <description>比较含退格的字符串(Backspace String Compare) 给定 S 和 T 两个字符串，当它们分别被输入到空白的文本编辑器后，判断二者是否相等，并返回结果。 # 代表退格字符。
注意：如果对空文本输入退格字符，文本继续为空。
示例 1：
输入：S = &amp;quot;ab#c&amp;quot;, T = &amp;quot;ad#c&amp;quot; 输出：true 解释：S 和 T 都会变成 “ac”。 示例 2：
输入：S = &amp;quot;ab##&amp;quot;, T = &amp;quot;c#d#&amp;quot; 输出：true 解释：S 和 T 都会变成 “”。 示例 3：
输入：S = &amp;quot;a##c&amp;quot;, T = &amp;quot;#a#c&amp;quot; 输出：true 解释：S 和 T 都会变成 “c”。 示例 4：
输入：S = &amp;quot;a#c&amp;quot;, T = &amp;quot;b&amp;quot; 输出：false 解释：S 会变成 “c”，但 T 仍然是 “b”。 提示：
 1 &amp;lt;= S.</description>
    </item>
    
    <item>
      <title>Leetcode 876 Middle of the Linked List</title>
      <link>https://Lu0key.github.io/post/leetcode-876-middle-of-the-linked-list/</link>
      <pubDate>Fri, 19 Mar 2021 16:54:41 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/leetcode-876-middle-of-the-linked-list/</guid>
      <description>链表的中间结点(Middle Of The Linked List) 给定一个头结点为 head 的非空单链表，返回链表的中间结点。
如果有两个中间结点，则返回第二个中间结点。
示例 1：
输入：[1,2,3,4,5] 输出：此列表中的结点 3 (序列化形式：[3,4,5]) 返回的结点值为 3 。 (测评系统对该结点序列化表述是 [3,4,5])。 注意，我们返回了一个 ListNode 类型的对象 ans，这样： ans.val = 3, ans.next.val = 4, ans.next.next.val = 5, 以及 ans.next.next.next = NULL. 示例 2：
输入：[1,2,3,4,5,6] 输出：此列表中的结点 4 (序列化形式：[4,5,6]) 由于该列表有两个中间结点，值分别为 3 和 4，我们返回第二个结点。 提示：
 给定链表的结点数介于 1 和 100 之间。  C语言版:
/** * Definition for singly-linked list. * struct ListNode { * int val; * struct ListNode *next; * }; */ struct ListNode * middleNode(struct ListNode* head){ int length = 1; struct ListNode* curr = head; while(curr-&amp;gt;next!</description>
    </item>
    
    <item>
      <title>Leetcode 49 Group Anagrams</title>
      <link>https://Lu0key.github.io/post/leetcode-49-group-anagrams/</link>
      <pubDate>Tue, 16 Mar 2021 16:50:13 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/leetcode-49-group-anagrams/</guid>
      <description>字母异位词分组(Group Anagrams) 给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。
示例:
输入: [&amp;quot;eat&amp;quot;, &amp;quot;tea&amp;quot;, &amp;quot;tan&amp;quot;, &amp;quot;ate&amp;quot;, &amp;quot;nat&amp;quot;, &amp;quot;bat&amp;quot;] 输出: [ [&amp;quot;ate&amp;quot;,&amp;quot;eat&amp;quot;,&amp;quot;tea&amp;quot;], [&amp;quot;nat&amp;quot;,&amp;quot;tan&amp;quot;], [&amp;quot;bat&amp;quot;] ] 说明：
 所有输入均为小写字母。 不考虑答案输出的顺序。  C语言版:
/** * Return an array of arrays of size *returnSize. * The sizes of the arrays are returned as *returnColumnSizes array. * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free(). */ int cmpChar(const void*a ,const void *b){ return *(const char*)a - *(const char *)b; } typedef struct { char * original; char * sorted; }Pair; int cmpPair(const void * a, const void * b){ const Pair * pa = (const Pair *)a; const Pair * pb = (const Pair *)b; return strcmp(pa-&amp;gt;sorted, pb-&amp;gt;sorted); } char *** groupAnagrams(char ** strs, int strsSize, int* returnSize, int** returnColumnSizes){ Pair* pairs = malloc(sizeof(Pair)*strsSize); for(int i =0;i&amp;lt;strsSize;i++){ char *sorted_str = malloc(sizeof(char)*strlen(strs[i])+1); strcpy(sorted_str,strs[i]); qsort(sorted_str, strlen(strs[i]),sizeof(char),cmpChar); pairs[i].</description>
    </item>
    
    <item>
      <title>Leetcode 122 Best Time to Buy and Sell Stock Ii</title>
      <link>https://Lu0key.github.io/post/leetcode-122-best-time-to-buy-and-sell-stock-ii/</link>
      <pubDate>Tue, 16 Mar 2021 00:05:57 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/leetcode-122-best-time-to-buy-and-sell-stock-ii/</guid>
      <description>买卖股票的最佳时机II(Best Time To Buy And Sell Stock II) 给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。
设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。
注意: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
示例 1:
输入: [7,1,5,3,6,4] 输出: 7 解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。 示例 2:
输入: [1,2,3,4,5] 输出: 4 解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。 因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。 示例 3:</description>
    </item>
    
    <item>
      <title>Leetcode 283 Move Zeroes</title>
      <link>https://Lu0key.github.io/post/leetcode-283-move-zeroes/</link>
      <pubDate>Mon, 15 Mar 2021 16:56:34 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/leetcode-283-move-zeroes/</guid>
      <description>移动零(Move Zeroes) 给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。
示例:
输入: [0,1,0,3,12] 输出: [1,3,12,0,0] 说明:
 必须在原数组上操作，不能拷贝额外的数组。 尽量减少操作次数。  C语言版本:
void moveZeroes(int* nums, int numsSize){ while(true){ int count = 0; for (int i =0;i+1&amp;lt;numsSize;i++) { if(nums[i]==0 &amp;amp;&amp;amp; nums[i+1]!=0) { count++; int temp = nums[i]; nums[i] = nums[i+1]; nums[i+1] = temp; break; } } if (count==0)break; } } 这样会超时，去掉第一个break就能过
模仿冒泡排序:
void moveZeroes(int* nums, int numsSize){ for (int k=0;k&amp;lt;numsSize;k++){ for(int i=0;i+1&amp;lt;numsSize;i++){ if(nums[i] == 0 &amp;amp;&amp;amp; nums[i+1] !</description>
    </item>
    
    <item>
      <title>Leetcode 53 Maximum Subarray</title>
      <link>https://Lu0key.github.io/post/leetcode-53-maximum-subarray/</link>
      <pubDate>Mon, 15 Mar 2021 16:02:01 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/leetcode-53-maximum-subarray/</guid>
      <description>最大子序和(Maximum Subarray) 给定一个整数数组 nums，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
示例 1：
输入：nums = [-2,1,-3,4,-1,2,1,-5,4] 输出：6 解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。 示例 2：
输入：nums = [1] 输出：1 示例 3：
输入：nums = [0] 输出：0 示例 4：
输入：nums = [-1] 输出：-1 示例 5：
输入：nums = [-100000] 输出：-100000 提示：
 $1\leqslant nums.length \leqslant 3 * 10^5$ $-10^5 \leqslant nums[i] \leqslant 10^5$  进阶：如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的 分治法 求解。
C语言版本:
int maxSubArray(int* nums, int numsSize){ int max=nums[0]; for (int i=0; i &amp;lt;numsSize;i++) { for (int j =i;j&amp;lt;numsSize;j++){ int sum = 0; for (int k =i;k&amp;lt;=j;k++){ sum += nums[k]; } if (sum&amp;gt;max){ max = sum; } } } return max; } 用这种方法会超时</description>
    </item>
    
    <item>
      <title>Leetcode 202 Happy Number</title>
      <link>https://Lu0key.github.io/post/leetcode-202-happy-number/</link>
      <pubDate>Mon, 15 Mar 2021 15:27:25 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/leetcode-202-happy-number/</guid>
      <description>快乐数(Happy Number) 编写一个算法来判断一个数 n 是不是快乐数。
「快乐数」定义为：
 对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。 然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。 如果 可以变为 1，那么这个数就是快乐数。  如果 n 是快乐数就返回 true ；不是，则返回 false 。
示例 1：
输入：19 输出：true 解释： 1² + 9² = 82 8² + 2² = 68 6² + 8² = 100 1² + 0² + 0² = 1 示例 2：
输入：n = 2 解释： 2² = 4 4² = 16 1² + 6² = 37 3² + 7² = 58 5² + 8² = 89 8² + 9² = 145 1² + 4² + 5² = 42 4² + 2² = 20 2² + 0² = 4 循环了，永远不会到1 输出：false 提示：</description>
    </item>
    
    <item>
      <title>Leetcode 136 Single Number</title>
      <link>https://Lu0key.github.io/post/leetcode-136-single-number/</link>
      <pubDate>Mon, 15 Mar 2021 14:36:31 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/leetcode-136-single-number/</guid>
      <description>只出现一次的数字(Single Number) 给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。
说明：
你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？
示例 1:
输入: [2,2,1] 输出: 1 示例 2:
输入: [4,1,2,1,2] 输出: 4 C的解法:
int singleNumber(int* nums, int numsSize){ for (int i =0;i&amp;lt;numsSize;i++){ int count = 0; for (int j=0;j&amp;lt;numsSize;j++){ if(nums[j]==nums[i]){ count++; } if(count==2)break; } if(count==1){ return nums[i]; } } return -1; } 用位运算:
int singleNumber(int* nums, int numsSize){ int n =nums[0]; for (int i =1;i&amp;lt;numsSize;i++){ n ^= nums[i]; } return n; } 之后再补Java的写法，都是类似的</description>
    </item>
    
  </channel>
</rss>
