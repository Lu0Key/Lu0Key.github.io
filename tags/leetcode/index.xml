<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>leetcode on 洛七的摸鱼池塘</title>
    <link>https://Lu0key.github.io/tags/leetcode/</link>
    <description>Recent content in leetcode on 洛七的摸鱼池塘</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 28 Feb 2024 22:46:15 +0800</lastBuildDate><atom:link href="https://Lu0key.github.io/tags/leetcode/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Leetcode 2583 二叉树中的第 K 大层和</title>
      <link>https://Lu0key.github.io/post/lc-2583-kth-largest-sum-in-a-binary-tree/</link>
      <pubDate>Wed, 28 Feb 2024 22:46:15 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/lc-2583-kth-largest-sum-in-a-binary-tree/</guid>
      <description>2583.二叉树中的第 K 大层和 给你一棵二叉树的根节点 root 和一个正整数 k 。
树中的 层和 是指 同一层 上节点值的总和。
返回树中第 k 大的层和（不一定不同）。如果树少于 k 层，则返回 -1 。
注意，如果两个节点与根节点的距离相同，则认为它们在同一层。
示例 1:
输入: root = [5,8,9,2,1,3,7,4,6], k = 2
输出: 13
解释: 树中每一层的层和分别是：
 Level 1: 5 Level 2: 8 + 9 = 17 Level 3: 2 + 1 + 3 + 7 = 13 Level 4: 4 + 6 = 10 第 2 大的层和等于 13 。  示例 2:</description>
    </item>
    
    <item>
      <title>Leetcode 889 根据前序和后序遍历构造二叉树</title>
      <link>https://Lu0key.github.io/post/lc-889-construct-binary-tree-from-preorder-and-postorder-traversal/</link>
      <pubDate>Wed, 28 Feb 2024 22:43:59 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/lc-889-construct-binary-tree-from-preorder-and-postorder-traversal/</guid>
      <description>889. 根据前序和后序遍历构造二叉树 给定两个整数数组, preorder 和 postorder ，其中 preorder 是一个具有 无重复 值的二叉树的前序遍历，postorder 是同一棵树的后序遍历，重构并返回二叉树。
如果存在多个答案，您可以返回其中 任何 一个。
示例 1:
输入: preorder = [1,2,4,5,3,6,7], postorder = [4,5,2,6,7,3,1]
输出: [1,2,3,4,5,6,7]
示例 2:
输入: preorder = [1], postorder = [1]
输出: [1]
提示：
 1 &amp;lt;= preorder.length &amp;lt;= 30 1 &amp;lt;= preorder[i] &amp;lt;= preorder.length preorder 中所有值都 不同 postorder.length == preorder.length 1 &amp;lt;= postorder[i] &amp;lt;= postorder.length postorder 中所有值都 不同 保证 preorder 和 postorder 是同一棵二叉树的前序遍历和后序遍历  Related Topics</description>
    </item>
    
    <item>
      <title>Leetcode 106 从中序与后序遍历序列构造二叉树</title>
      <link>https://Lu0key.github.io/post/lc-106-construct-binary-tree-from-inorder-and-postorder-traversal/</link>
      <pubDate>Wed, 28 Feb 2024 22:42:06 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/lc-106-construct-binary-tree-from-inorder-and-postorder-traversal/</guid>
      <description>106.从中序与后序遍历序列构造二叉树 给定两个整数数组 inorder 和 postorder ，其中 inorder 是二叉树的中序遍历， postorder 是同一棵树的后序遍历，请你构造并返回这颗 二叉树 。
示例 1:
输入: inorder = [9,3,15,20,7], postorder = [9,15,7,20,3]
输出: [3,9,20,null,null,15,7]
示例 2:
输入: inorder = [-1], postorder = [-1]
输出: [-1]
提示：
 1 &amp;lt;= inorder.length &amp;lt;= 3000 postorder.length == inorder.length -3000 &amp;lt;= inorder[i], postorder[i] &amp;lt;= 3000 inorder 和 postorder 都由 不同 的值组成 postorder 中每一个值都在 inorder 中 inorder 保证是树的中序遍历 postorder 保证是树的后序遍历  Related Topics
 树 数组 哈希表 分治 二叉树  题目链接: link</description>
    </item>
    
    <item>
      <title>Leetcode 105 从前序与中序遍历序列构造二叉树</title>
      <link>https://Lu0key.github.io/post/lc-105-construct-binary-tree-from-preorder-and-inorder-traversal/</link>
      <pubDate>Wed, 28 Feb 2024 22:40:00 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/lc-105-construct-binary-tree-from-preorder-and-inorder-traversal/</guid>
      <description>105.从前序与中序遍历序列构造二叉树 给定两个整数数组 preorder 和 inorder ，其中 preorder 是二叉树的先序遍历， inorder 是同一棵树的 中序遍历，请构造二叉树并返回其根节点。
示例 1:
输入: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]
输出: [3,9,20,null,null,15,7]
示例 2:
输入: preorder = [-1], inorder = [-1]
输出: [-1]
提示：
 1 &amp;lt;= preorder.length &amp;lt;= 3000 inorder.length == preorder.length -3000 &amp;lt;= preorder[i], inorder[i] &amp;lt;= 3000 preorder 和 inorder 均 无重复 元素 inorder 均出现在 preorder preorder 保证 为二叉树的前序遍历序列 inorder 保证 为二叉树的中序遍历序列  Related Topics
 树 数组 哈希表 分治 二叉树  题目链接: link</description>
    </item>
    
    <item>
      <title>Leetcode 590 N 叉树的后序遍历</title>
      <link>https://Lu0key.github.io/post/lc-590-n-ary-tree-postorder-traversal/</link>
      <pubDate>Wed, 28 Feb 2024 22:37:43 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/lc-590-n-ary-tree-postorder-traversal/</guid>
      <description>589.N 叉树的后序遍历 给定一个 n 叉树的根节点 root ，返回 其节点值的 后序遍历 。
n 叉树 在输入中按层序遍历进行序列化表示，每组子节点由空值 null 分隔（请参见示例）。
示例 1:
输入: root = [1,null,3,2,4,null,5,6]
输出: [5,6,3,2,4,1]
示例 2:
输入: root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]
输出: [2,6,14,11,7,3,12,8,4,13,9,10,5,1]
提示：
 节点总数在范围 [0, 10^4] 内 0 &amp;lt;= Node.val &amp;lt;= 10^4 n 叉树的高度小于或等于 1000  Related Topics
 栈 树 深度优先搜索  题目链接: link
解答 本题的难度是 Easy.
也是后序遍历的定义.
代码如下:
class Solution { private List&amp;lt;Integer&amp;gt; result = new ArrayList&amp;lt;&amp;gt;(); public List&amp;lt;Integer&amp;gt; postorder(Node root) { dfs(root); return result; } private void dfs(Node node){ if (node == null) {return;} for (Node child:node.</description>
    </item>
    
    <item>
      <title>Leetcode 589 N 叉树的前序遍历</title>
      <link>https://Lu0key.github.io/post/lc-589-n-ary-tree-preorder-traversal/</link>
      <pubDate>Wed, 28 Feb 2024 22:33:50 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/lc-589-n-ary-tree-preorder-traversal/</guid>
      <description>589.N 叉树的前序遍历 给定一个 n 叉树的根节点 root ，返回 其节点值的 前序遍历 。
n 叉树 在输入中按层序遍历进行序列化表示，每组子节点由空值 null 分隔（请参见示例）。
示例 1:
输入: root = [1,null,3,2,4,null,5,6]
输出: [1,3,5,6,2,4]
示例 2:
输入: root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]
输出: [1,2,3,6,7,11,14,4,8,12,5,9,13,10]
提示：
 节点总数在范围 [0, 10^4] 内 0 &amp;lt;= Node.val &amp;lt;= 10^4 n 叉树的高度小于或等于 1000  Related Topics
 栈 树 深度优先搜索  题目链接: link
解答 本题的难度是 Easy.
也是前序遍历的定义.
代码如下:
class Solution { private List&amp;lt;Integer&amp;gt; result = new ArrayList&amp;lt;&amp;gt;(); public List&amp;lt;Integer&amp;gt; preorder(Node root) { dfs(root); return result; } private void dfs(Node node){ if (node == null) {return;} result.</description>
    </item>
    
    <item>
      <title>Leetcode 429 N 叉树的层序遍历</title>
      <link>https://Lu0key.github.io/post/lc-429-n-ary-tree-level-order-traversal/</link>
      <pubDate>Wed, 28 Feb 2024 22:25:43 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/lc-429-n-ary-tree-level-order-traversal/</guid>
      <description>429.N 叉树的层序遍历 给定一个 N 叉树，返回其节点值的层序遍历。（即从左到右，逐层遍历）。
树的序列化输入是用层序遍历，每组子节点都由 null 值分隔（参见示例）。
示例 1:
输入: root = [1,null,3,2,4,null,5,6]
输出: [[1],[3,2,4],[5,6]]
示例 2:
输入: root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]
输出: [[1],[2,3,4,5],[6,7,8,9,10],[11,12,13],[14]]
提示：
 树的高度不会超过 1000 树的节点总数在 [0, 10^4] 之间  Related Topics
 树 广度优先搜索  题目链接: link
解答 本题的难度是 Medium.
这题和层序遍历二叉树本质上是一样的, 只不过是多了一个子节点的遍历, 怎么这几天都是层序遍历.
代码如下:
class Solution { private List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; result = new ArrayList&amp;lt;&amp;gt;(); public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; levelOrder(Node root) { subLevelOrder(root, 0); return result; } private void subLevelOrder(Node node, int depth){ if(node == null) {return;} if(result.</description>
    </item>
    
    <item>
      <title>Leetcode 103 二叉树的锯齿形层序遍历</title>
      <link>https://Lu0key.github.io/post/lc-103-binary-tree-zigzag-level-order-traversal/</link>
      <pubDate>Wed, 28 Feb 2024 22:23:36 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/lc-103-binary-tree-zigzag-level-order-traversal/</guid>
      <description>103.二叉树的锯齿形层序遍历 给你二叉树的根节点 root ，返回其节点值的 锯齿形层序遍历 。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）
示例 1:
输入: root = [3,9,20,null,null,15,7]
输出: [[15,7],[9,20],[3]]
示例 2:
输入: root = [1]
输出: [[1]]
示例 3:
输入: root = []
输出: []
提示：
 树中节点数目在范围 [0, 2000] 内 100 &amp;lt;= Node.val &amp;lt;= 100  Related Topics
 树 广度优先搜索 二叉树  题目链接: link
解答 本题的难度是 Medium.
也是写了很抽象的代码, 都不知道自己脑子那几天在想什么? 太怪了.
代码如下:
class Solution { private HashMap&amp;lt;Integer, ArrayList&amp;lt;Integer&amp;gt;&amp;gt; hashMap = new HashMap&amp;lt;&amp;gt;(); private int maxDepth = -1; public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; zigzagLevelOrder(TreeNode root) { List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; result = new ArrayList&amp;lt;&amp;gt;(); levelOrder(root, 0); for (int i = 0; i &amp;lt;= maxDepth; i++) { ArrayList&amp;lt;Integer&amp;gt; list = hashMap.</description>
    </item>
    
    <item>
      <title>Leetcode 107 二叉树的层序遍历II</title>
      <link>https://Lu0key.github.io/post/lc-107-binary-tree-level-order-traversal-ii/</link>
      <pubDate>Wed, 28 Feb 2024 22:21:40 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/lc-107-binary-tree-level-order-traversal-ii/</guid>
      <description>107.二叉树的层序遍历II 给你二叉树的根节点 root ，返回其节点值 自底向上的层序遍历 。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）
示例 1:
输入: root = [3,9,20,null,null,15,7]
输出: [[15,7],[9,20],[3]]
示例 2:
输入: root = [1]
输出: [[1]]
示例 3:
输入: root = []
输出: []
提示：
 树中节点数目在范围 [0, 2000] 内 1000 &amp;lt;= Node.val &amp;lt;= 1000  Related Topics
 树 广度优先搜索 二叉树  题目链接: link
解答 本题的难度是 Medium.
一开始写的很抽象, 先创建一个 HashMap, 然后记录最大深度, 然后再倒序插入到 result 里.
代码如下:
class Solution { private int maxDepth = -1; HashMap&amp;lt;Integer, ArrayList&amp;lt;Integer&amp;gt;&amp;gt; hashMap = new HashMap(); public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; levelOrderBottom(TreeNode root) { levelOrder(root, 0); List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; result = new ArrayList&amp;lt;&amp;gt;(); for (int i = maxDepth; i &amp;gt;= 0 ; i--) { result.</description>
    </item>
    
    <item>
      <title>Leetcode 102 二叉树的层序遍历</title>
      <link>https://Lu0key.github.io/post/lc-102-binary-tree-level-order-traversal/</link>
      <pubDate>Wed, 28 Feb 2024 22:18:42 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/lc-102-binary-tree-level-order-traversal/</guid>
      <description>102.二叉树的层序遍历 给你二叉树的根节点 root ，返回其节点值的 层序遍历 。 （即逐层地，从左到右访问所有节点）。
示例 1:
输入: root = [3,9,20,null,null,15,7]
输出: [[3],[9,20],[15,7]]
示例 2:
输入: root = [1]
输出: [[1]]
示例 3:
输入: root = []
输出: []
提示：
 树中节点数目在范围 [0, 2000] 内 -1000 &amp;lt;= Node.val &amp;lt;= 1000  Related Topics
 树 广度优先搜索 二叉树  题目链接: link
解答 本题的难度是 Medium.
之前做 Hot100 的时候做过了, 直接复制之前的代码 E:), 感觉妙妙妙, 因为这样很自然地就是层序遍历了.
代码如下:
class Solution { List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; lists = new ArrayList&amp;lt;&amp;gt;(); public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; levelOrder(TreeNode root) { ceng(0, root); return lists; } private void ceng(int cengIndex, TreeNode node){ if(node == null ){return ;} if(lists.</description>
    </item>
    
    <item>
      <title>Leetcode 987 二叉树的垂序遍历</title>
      <link>https://Lu0key.github.io/post/lc-987-vertical-order-traversal-of-a-binary-tree/</link>
      <pubDate>Wed, 28 Feb 2024 22:16:13 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/lc-987-vertical-order-traversal-of-a-binary-tree/</guid>
      <description>987.二叉树的垂序遍历 给你二叉树的根结点 root ，请你设计算法计算二叉树的 垂序遍历 序列。
对位于 (row, col) 的每个结点而言，其左右子结点分别位于 (row + 1, col - 1) 和 (row + 1, col + 1) 。树的根结点位于 (0, 0) 。
二叉树的 垂序遍历 从最左边的列开始直到最右边的列结束，按列索引每一列上的所有结点，形成一个按出现位置从上到下排序的有序列表。如果同行同列上有多个结点，则按结点的值从小到大进行排序。
返回二叉树的 垂序遍历 序列。
示例 1:
输入: root = [3,9,20,null,null,15,7]
输出: [[9],[3,15],[20],[7]]
解释:
列 -1 ：只有结点 9 在此列中。
列 0 ：只有结点 3 和 15 在此列中，按从上到下顺序。
列 1 ：只有结点 20 在此列中。
列 2 ：只有结点 7 在此列中。
示例 2:
输入: root = [1,2,3,4,5,6,7]</description>
    </item>
    
    <item>
      <title>Leetcode 145 二叉树的后序遍历</title>
      <link>https://Lu0key.github.io/post/lc-145-binary-tree-postorder-traversal/</link>
      <pubDate>Wed, 28 Feb 2024 22:14:20 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/lc-145-binary-tree-postorder-traversal/</guid>
      <description>145.二叉树的后序遍历 给你一棵二叉树的根节点 root ，返回其节点值的 后序遍历 。
示例 1:
输入: root = [1,null,2,3]
输出: [3,2,1]
示例 2:
输入: root = []
输出: []
示例 3:
输入: root = [1]
输出: [1]
提示：
 树中节点的数目在范围 [0, 100] 内 100 &amp;lt;= Node.val &amp;lt;= 100  进阶：递归算法很简单，你可以通过迭代算法完成吗？
Related Topics
 栈 树 深度优先搜索 二叉树  题目链接: link
解答 本题的难度是 Easy.
最近感觉是捅了树窝了, 这题和前两天的题目一样, 都只是定义.
代码如下:
class Solution { public List&amp;lt;Integer&amp;gt; postorderTraversal(TreeNode root) { List&amp;lt;Integer&amp;gt; result = new ArrayList&amp;lt;&amp;gt;(); middleOrder(result, root); return result; } private void middleOrder(List&amp;lt;Integer&amp;gt; result, TreeNode node){ if(node == null){return;} if(node.</description>
    </item>
    
    <item>
      <title>Leetcode 144 二叉树的前序遍历</title>
      <link>https://Lu0key.github.io/post/lc-144-binary-tree-inorder-traversal/</link>
      <pubDate>Wed, 28 Feb 2024 22:11:49 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/lc-144-binary-tree-inorder-traversal/</guid>
      <description>144. 二叉树的前序遍历 给你二叉树的根节点 root ，返回它节点值的 前序 遍历。
示例 1:
输入: root = [1,null,2,3]
输出: [1,2,3]
示例 2:
输入: root = []
输出: []
示例 3:
输入: root = [1]
输出: [1]
还有两个示例就不放了&amp;hellip; 没啥意义
提示：
 树中节点数目在范围 [0, 100] 内 -100 &amp;lt;= Node.val &amp;lt;= 100  Related Topics
 栈 树 深度优先搜索 二叉树  题目链接: link
解答 本题的难度是 Easy.
和之前那题一样, 也没啥好说的, 纯纯定义.
class Solution { private List&amp;lt;Integer&amp;gt; list = new ArrayList&amp;lt;&amp;gt;(); public List&amp;lt;Integer&amp;gt; preorderTraversal(TreeNode root) { preorder(root); return list; } private void preorder(TreeNode node) { if(node==null){return;} list.</description>
    </item>
    
    <item>
      <title>Leetcode 94 二叉树的中序遍历</title>
      <link>https://Lu0key.github.io/post/lc-94-binary-tree-inorder-traversal/</link>
      <pubDate>Wed, 28 Feb 2024 22:10:10 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/lc-94-binary-tree-inorder-traversal/</guid>
      <description>94. 二叉树的中序遍历 给定一个二叉树的根节点 root ，返回 它的 中序 遍历 。
示例 1:
输入: root = [1,null,2,3]
输出: [1,3,2]
示例 2:
输入: root = []
输出: []
示例 3:
输入: root = [1]
输出: [1]
提示：
 树中节点数目在范围 [0, 100] 内 -100 &amp;lt;= Node.val &amp;lt;= 100  Related Topics
 栈 树 深度优先搜索 二叉树  题目链接: link
解答 本题的难度是 Easy.
这题太基础了, 甚至一时间都不知道该怎么讲, 属于树的入门题了, 纯纯定义.
class Solution { public List&amp;lt;Integer&amp;gt; inorderTraversal(TreeNode root) { List&amp;lt;Integer&amp;gt; result = new ArrayList&amp;lt;&amp;gt;(); middleOrder(result, root); return result; } private void middleOrder(List&amp;lt;Integer&amp;gt; result, TreeNode node){ if(node == null){return;} if(node.</description>
    </item>
    
    <item>
      <title>Leetcode 236 二叉树的最近公共祖先</title>
      <link>https://Lu0key.github.io/post/lc-236-lowest-common-ancestor-of-a-binary-tree/</link>
      <pubDate>Wed, 28 Feb 2024 22:07:21 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/lc-236-lowest-common-ancestor-of-a-binary-tree/</guid>
      <description>236. 二叉树的最近公共祖先 给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。
百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”
示例 1:
输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
输出: 3
解释: 节点 5 和节点 1 的最近公共祖先是节点 3 。
示例 2:
输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
输出: 5
解释: 节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。
示例 3:
输入: root = [1,2], p = 1, q = 2</description>
    </item>
    
    <item>
      <title>Leetcode 993 二叉树的堂兄弟节点</title>
      <link>https://Lu0key.github.io/post/lc-993-cousins-in-binary-tree/</link>
      <pubDate>Wed, 28 Feb 2024 22:04:55 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/lc-993-cousins-in-binary-tree/</guid>
      <description>993.二叉树的堂兄弟节点 在二叉树中, 根节点位于深度 0 处，每个深度为 k 的节点的子节点位于深度 k+1 处。
如果二叉树的两个节点深度相同，但 父节点不同 ，则它们是一对堂兄弟节点。
我们给出了具有唯一值的二叉树的根节点 root ，以及树中两个不同节点的值 x 和 y 。
只有与值 x 和 y 对应的节点是堂兄弟节点时，才返回 true 。否则，返回 false。
示例 1:
输入: root = [1,2,3,4], x = 4, y = 3
输出: false
示例 2:
输入: root = [1,2,3,null,4,null,5], x = 5, y = 4
输出: true
示例 3:
输入: root = [1,2,3,null,4], x = 2, y = 3
输出: false
提示：</description>
    </item>
    
    <item>
      <title>Leetcode 2641 二叉树的堂兄弟节点 II</title>
      <link>https://Lu0key.github.io/post/lc-2641-cousins-in-binary-tree-ii/</link>
      <pubDate>Wed, 28 Feb 2024 22:02:26 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/lc-2641-cousins-in-binary-tree-ii/</guid>
      <description>2641.二叉树的堂兄弟节点 II 给你一棵二叉树的根 root ，请你将每个节点的值替换成该节点的所有 堂兄弟节点值的和 。
如果两个节点在树中有相同的深度且它们的父节点不同，那么它们互为 堂兄弟 。
请你返回修改值之后，树的根 root 。
注意，一个节点的深度指的是从树根节点到这个节点经过的边数。
示例 1:
输入: root = [5,4,9,1,10,null,7]
输出: [0,0,0,7,7,null,11]
解释: 上图展示了初始的二叉树和修改每个节点的值之后的二叉树。
 值为 5 的节点没有堂兄弟，所以值修改为 0 。 值为 4 的节点没有堂兄弟，所以值修改为 0 。 值为 9 的节点没有堂兄弟，所以值修改为 0 。 值为 1 的节点有一个堂兄弟，值为 7 ，所以值修改为 7 。 值为 10 的节点有一个堂兄弟，值为 7 ，所以值修改为 7 。 值为 7 的节点有两个堂兄弟，值分别为 1 和 10 ，所以值修改为 11 。  示例 2:
输入: root = [3,1,2]</description>
    </item>
    
    <item>
      <title>Leetcode LCP30 魔塔游戏</title>
      <link>https://Lu0key.github.io/post/lc-lcp30-%E9%AD%94%E5%A1%94%E6%B8%B8%E6%88%8F/</link>
      <pubDate>Wed, 28 Feb 2024 21:57:09 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/lc-lcp30-%E9%AD%94%E5%A1%94%E6%B8%B8%E6%88%8F/</guid>
      <description>LCP30.魔塔游戏 小扣当前位于魔塔游戏第一层，共有 N 个房间，编号为 0 ~ N-1。每个房间的补血道具/怪物对于血量影响记于数组 nums，其中正数表示道具补血数值，即血量增加对应数值；负数表示怪物造成伤害值，即血量减少对应数值；0 表示房间对血量无影响。
小扣初始血量为 1，且无上限。假定小扣原计划按房间编号升序访问所有房间补血/打怪，为保证血量始终为正值，小扣需对房间访问顺序进行调整，每次仅能将一个怪物房间（负数的房间）调整至访问顺序末尾。请返回小扣最少需要调整几次，才能顺利访问所有房间。若调整顺序也无法访问完全部房间，请返回 -1。
示例 1:
输入: nums = [100,100,100,-250,-60,-140,-50,-50,100,150]
输出: 1
解释: 初始血量为 1。至少需要将 nums[3] 调整至访问顺序末尾以满足要求.
示例 2:
输入: nums = [-200,-300,400,0]
输出: -1
解释: 调整访问顺序也无法完成全部房间的访问。
提示：
 1 &amp;lt;= nums.length &amp;lt;= 10^5 -10^5 &amp;lt;= nums[i] &amp;lt;= 10^5  Related Topics
 贪心 数组 堆(优先队列)  题目链接: link
解答 本题的难度是 Medium.
这里的话我们可以考虑贪心算法, 从左到右遍历, 如果当前的血量小于 0 我们才考虑调整. 那这边我们当然是希望如果能够调整当然是能调整次数越少越好, 因此肯定选择把前面扣血最多的负数移到最后面, 因此其实我们相当于是需要维护一个最小堆, 因为只有负值才会放到堆里. 这样我们就可以每次取出堆顶的元素, 然后把血量加上这个值, 然后再把这个值放到最后面.</description>
    </item>
    
    <item>
      <title>Leetcode 1696 跳跃游戏 VI</title>
      <link>https://Lu0key.github.io/post/lc-1696-jump-game-vi/</link>
      <pubDate>Wed, 28 Feb 2024 21:54:36 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/lc-1696-jump-game-vi/</guid>
      <description>1696.跳跃游戏 VI 给你一个下标从 0 开始的整数数组 nums 和一个整数 k 。
一开始你在下标 0 处。每一步，你最多可以往前跳 k 步，但你不能跳出数组的边界。也就是说，你可以从下标 i 跳到 [i + 1， min(n - 1, i + k)] 包含 两个端点的任意位置。
你的目标是到达数组最后一个位置（下标为 n - 1 ），你的 得分 为经过的所有数字之和。
请你返回你能得到的 最大得分 。
示例 1:
输入: nums = [**1**,**-1**,-2,**4**,-7,**3**], k = 2
输出: 7
解释: 你可以选择子序列 [1,-1,4,3] （上面加粗的数字），和为 7 。
示例 2:
输入: nums = [**10**,-5,-2,**4**,0,**3**], k = 3
输出: 17
解释: 你可以选择子序列 [10,4,3] （上面加粗数字），和为 17 。</description>
    </item>
    
    <item>
      <title>Leetcode 292 Nim 游戏</title>
      <link>https://Lu0key.github.io/post/lc-292-nim-game/</link>
      <pubDate>Wed, 28 Feb 2024 21:50:49 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/lc-292-nim-game/</guid>
      <description>292.Nim 游戏 你和你的朋友，两个人一起玩 Nim 游戏：
 桌子上有一堆石头。 你们轮流进行自己的回合， 你作为先手 。 每一回合，轮到的人拿掉 1 - 3 块石头。 拿掉最后一块石头的人就是获胜者。 假设你们每一步都是最优解。请编写一个函数，来判断你是否可以在给定石头数量为 n 的情况下赢得游戏。如果可以赢，返回 true；否则，返回 false 。  示例 1:
输入: n = 4
输出: false
解释: 以下是可能的结果:
 移除1颗石头。你的朋友移走了3块石头，包括最后一块。你的朋友赢了。 移除2个石子。你的朋友移走2块石头，包括最后一块。你的朋友赢了。 3.你移走3颗石子。你的朋友移走了最后一块石头。你的朋友赢了。 在所有结果中，你的朋友是赢家。  示例 2:
输入: n = 1
输出: true
示例 3:
输入: n = 2
输出: true
提示：
 1 &amp;lt;= n &amp;lt;= 2^31 - 1  Related Topics
 脑筋急转弯 数学 博弈  题目链接: link</description>
    </item>
    
    <item>
      <title>Leetcode 2670 找出不同元素数目差数组</title>
      <link>https://Lu0key.github.io/post/lc-2670-find-the-distinct-difference-array/</link>
      <pubDate>Wed, 28 Feb 2024 21:44:34 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/lc-2670-find-the-distinct-difference-array/</guid>
      <description>2670.找出不同元素数目差数组 给你一个下标从 0 开始的数组 nums ，数组长度为 n 。
nums 的 不同元素数目差 数组可以用一个长度为 n 的数组 diff 表示，其中 diff[i] 等于前缀 nums[0, ..., i] 中不同元素的数目 减去 后缀 nums[i + 1, ..., n - 1] 中不同元素的数目。
返回 nums 的 不同元素数目差 数组。
注意 nums[i, ..., j] 表示 nums 的一个从下标 i 开始到下标 j 结束的子数组（包含下标 i 和 j 对应元素）。特别需要说明的是，如果 i &amp;gt; j ，则 nums[i, ..., j] 表示一个空子数组。
示例 1:
输入: nums = [1,2,3,4,5]
输出: [-3,-1,1,3,5]
解释:
对于 i = 0，前缀中有 1 个不同的元素，而在后缀中有 4 个不同的元素。因此，diff[0] = 1 - 4 = -3 。</description>
    </item>
    
    <item>
      <title>Leetcode 365 水壶问题</title>
      <link>https://Lu0key.github.io/post/lc-365-water-and-jug-problem/</link>
      <pubDate>Wed, 28 Feb 2024 21:35:19 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/lc-365-water-and-jug-problem/</guid>
      <description>365.水壶问题 有两个水壶，容量分别为 jug1Capacity 和 jug2Capacity 升。水的供应是无限的。确定是否有可能使用这两个壶准确得到 targetCapacity 升。
如果可以得到 targetCapacity 升水，最后请用以上水壶中的一或两个来盛放取得的 targetCapacity 升水。
你可以：
 装满任意一个水壶 清空任意一个水壶 从一个水壶向另外一个水壶倒水，直到装满或者倒空  示例 1:
输入: jug1Capacity = 3, jug2Capacity = 5, targetCapacity = 4
输出: true
示例 2:
输入: jug1Capacity = 2, jug2Capacity = 6, targetCapacity = 5
输出: false
示例 3:
输入: jug1Capacity = 1, jug2Capacity = 2, targetCapacity = 3
输出: true
提示：
 1 &amp;lt;= jug1Capacity, jug2Capacity, targetCapacity &amp;lt;= 10^6  Related Topics</description>
    </item>
    
    <item>
      <title>Leetcode 2861 最大合金数</title>
      <link>https://Lu0key.github.io/post/lc-2861-maximum-number-of-alloys/</link>
      <pubDate>Wed, 28 Feb 2024 21:29:15 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/lc-2861-maximum-number-of-alloys/</guid>
      <description>2861.最大合金数 假设你是一家合金制造公司的老板，你的公司使用多种金属来制造合金。现在共有 n 种不同类型的金属可以使用，并且你可以使用 k 台机器来制造合金。每台机器都需要特定数量的每种金属来创建合金。
对于第 i 台机器而言，创建合金需要 composition[i][j] 份 j 类型金属。最初，你拥有 stock[i] 份 i 类型金属，而每购入一份 i 类型金属需要花费 cost[i] 的金钱。
给你整数 n、k、budget，下标从 1 开始的二维数组 composition，两个下标从 1 开始的数组 stock 和 cost，请你在预算不超过 budget 金钱的前提下，最大化 公司制造合金的数量。
所有合金都需要由同一台机器制造。
返回公司可以制造的最大合金数。
示例 1:
输入: n = 3, k = 2, budget = 15, composition = [[1,1,1],[1,1,10]], stock = [0,0,0], cost = [1,2,3]
输出: 2
解释: 优的方法是使用第 1 台机器来制造合金。
要想制造 2 份合金，我们需要购买：
 2 份第 1 类金属。 2 份第 2 类金属。 2 份第 3 类金属。  总共需要 2 * 1 + 2 * 2 + 2 * 3 = 12 的金钱，小于等于预算 15 。</description>
    </item>
    
    <item>
      <title>Leetcode 2859 计算 K 置位下标对应元素的和</title>
      <link>https://Lu0key.github.io/post/lc-2859-sum-of-values-at-indices-with-k-set-bits/</link>
      <pubDate>Wed, 28 Feb 2024 21:15:49 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/lc-2859-sum-of-values-at-indices-with-k-set-bits/</guid>
      <description>2859.计算 K 置位下标对应元素的和 你一个下标从 0 开始的整数数组 nums 和一个整数 k 。
请你用整数形式返回 nums 中的特定元素之 和 ，这些特定元素满足：其对应下标的二进制表示中恰存在 k 个置位。
整数的二进制表示中的 1 就是这个整数的 置位 。
例如，21 的二进制表示为 10101 ，其中有 3 个置位。
示例 1:
输入: nums = [5,10,1,5,2], k = 1
输出: 13
解释: 下标的二进制表示是：
0 = 00021 = 00122 = 01023 = 01124 = 1002下标 1、2 和 4 在其二进制表示中都存在 k = 1 个置位。
因此，答案为 nums[1] + nums[2] + nums[4] = 13 。
示例 2:</description>
    </item>
    
    <item>
      <title>Leetcode 2765 最长交替子数组</title>
      <link>https://Lu0key.github.io/post/lc-2765-longest-alternating-subarray/</link>
      <pubDate>Tue, 23 Jan 2024 23:43:58 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/lc-2765-longest-alternating-subarray/</guid>
      <description>2765.最长交替子数组 给你一个下标从 0 开始的整数数组 nums 。如果 nums 中长度为 m 的子数组 s 满足以下条件，我们称它是一个 交替子数组 ：
 m 大于 1 。 s_1 = s_0 + 1 。 下标从 0 开始的子数组 s 与数组 [s_0, s1, s_0, s_1,...,s_{(m-1) % 2}] 一样。也就是说，s1 - s0 = 1 ，s2 - s1 = -1 ，s3 - s2 = 1 ，s4 - s3 = -1 ，以此类推，直到 s[m - 1] - s[m - 2] = (-1)^m 。 请你返回 nums 中所有 交替 子数组中，最长的长度，如果不存在交替子数组，请你返回 -1 。  子数组是一个数组中一段连续 非空 的元素序列。</description>
    </item>
    
    <item>
      <title>Leetcode 670 最大交换</title>
      <link>https://Lu0key.github.io/post/lc-670-maximum-swap/</link>
      <pubDate>Mon, 22 Jan 2024 23:27:38 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/lc-670-maximum-swap/</guid>
      <description>670.最大交换 给定一个非负整数，你至多可以交换一次数字中的任意两位。返回你能得到的最大值。
示例 1:
输入: 2736
输出: 7236
解释: 交换数字2和数字7。
示例 2:
输入: 9973
输出: 9973
解释: 不需要交换。
注意:
 给定数字的范围是 [0, 10^8]  Related Topics
 贪心 数学  题目链接: link
解答 本题的难度是 Medium.
首先很自然的想法，当然是越高位的被换成越大越好, 因此我们从左到右遍历, 对于每一位来看, 这一位的右边有没有更大的, 如果有就把右边最大的和当前位进行换, 如果没有, 说明当前遍历过的数字已经是最大的了, 就要看看后面的了. 当然右边同时有两个是最大的, 那么当然是选位更小的那个数字, 因此从右向左遍历.
比如: 96177, 9 的右边没有比 9 更大的了, 因此跳到 6, 右边最大的为 7, 因此我们要找最大的应该用最低位, 即个位的 7. 得到结果, 97176。
代码如下:
class Solution { public int maximumSwap(int num) { String s = Integer.</description>
    </item>
    
    <item>
      <title>Leetcode 2788 按分隔符拆分字符串</title>
      <link>https://Lu0key.github.io/post/lc-2788-split-strings-by-separator/</link>
      <pubDate>Sat, 20 Jan 2024 15:24:45 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/lc-2788-split-strings-by-separator/</guid>
      <description>2788.按分隔符拆分字符串 给你一个字符串数组 words 和一个字符 separator ，请你按 separator 拆分 words 中的每个字符串。
返回一个由拆分后的新字符串组成的字符串数组，不包括空字符串 。
注意
 separator 用于决定拆分发生的位置，但它不包含在结果字符串中。 拆分可能形成两个以上的字符串。 结果字符串必须保持初始相同的先后顺序。  示例 1:
输入: words = [&amp;ldquo;one.two.three&amp;rdquo;,&amp;ldquo;four.five&amp;rdquo;,&amp;ldquo;six&amp;rdquo;], separator = &amp;ldquo;.&amp;rdquo;
输出: [&amp;ldquo;one&amp;rdquo;,&amp;ldquo;two&amp;rdquo;,&amp;ldquo;three&amp;rdquo;,&amp;ldquo;four&amp;rdquo;,&amp;ldquo;five&amp;rdquo;,&amp;ldquo;six&amp;rdquo;]
解释: 在本示例中，我们进行下述拆分：
&amp;ldquo;one.two.three&amp;rdquo; 拆分为 &amp;ldquo;one&amp;rdquo;, &amp;ldquo;two&amp;rdquo;,
&amp;ldquo;three&amp;rdquo; &amp;ldquo;four.five&amp;rdquo; 拆分为 &amp;ldquo;four&amp;rdquo;,
&amp;ldquo;five&amp;rdquo; &amp;ldquo;six&amp;rdquo; 拆分为 &amp;ldquo;six&amp;rdquo;
因此，结果数组为 [&amp;ldquo;one&amp;rdquo;,&amp;ldquo;two&amp;rdquo;,&amp;ldquo;three&amp;rdquo;,&amp;ldquo;four&amp;rdquo;,&amp;ldquo;five&amp;rdquo;,&amp;ldquo;six&amp;rdquo;] 。
示例 2:
输入: words = [&amp;quot;$easy$&amp;quot;,&amp;quot;$problem$&amp;quot;], separator = &amp;ldquo;$&amp;rdquo;
输出: [&amp;ldquo;easy&amp;rdquo;,&amp;ldquo;problem&amp;rdquo;]
解释: 在本示例中，我们进行下述拆分：
&amp;ldquo;$easy$&amp;rdquo; 拆分为 &amp;ldquo;easy&amp;rdquo;（不包括空字符串）
&amp;ldquo;$problem$&amp;rdquo; 拆分为 &amp;ldquo;problem&amp;rdquo;（不包括空字符串）
因此，结果数组为 [&amp;ldquo;easy&amp;rdquo;,&amp;ldquo;problem&amp;rdquo;] 。
示例 3:</description>
    </item>
    
    <item>
      <title>Leetcode 2809 使数组和小于等于 x 的最少时间</title>
      <link>https://Lu0key.github.io/post/lc-2809-minimum-time-to-make-array-sum-at-most-x/</link>
      <pubDate>Sat, 20 Jan 2024 00:07:08 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/lc-2809-minimum-time-to-make-array-sum-at-most-x/</guid>
      <description>2809.使数组和小于等于 x 的最少时间 给你两个长度相等下标从 0 开始的整数数组 nums1 和 nums2 。每一秒，对于所有下标 0 &amp;lt;= i &amp;lt; nums1.length ，nums1[i] 的值都增加 nums2[i] 。操作 完成后 ，你可以进行如下操作：
 选择任一满足 0 &amp;lt;= i &amp;lt; nums1.length 的下标 i ，并使 nums1[i] = 0 。  同时给你一个整数 x 。
请你返回使 nums1 中所有元素之和 小于等于 x 所需要的 最少 时间，如果无法实现，那么返回 -1 。
示例 1：
输入: nums1 = [1,2,3], nums2 = [1,2,3], x = 4
输出: 3
解释：
第 1 秒，我们对 i = 0 进行操作，得到 nums1 = [0,2+2,3+3] = [0,4,6] 。</description>
    </item>
    
    <item>
      <title>Leetcode 2171 拿出最少数目的魔法豆</title>
      <link>https://Lu0key.github.io/post/lc-2171-removing-minimum-number-of-magic-beans/</link>
      <pubDate>Thu, 18 Jan 2024 14:37:18 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/lc-2171-removing-minimum-number-of-magic-beans/</guid>
      <description>2171.拿出最少数目的魔法豆 给定一个 正整数 数组 beans ，其中每个整数表示一个袋子里装的魔法豆的数目。
请你从每个袋子中 拿出 一些豆子（也可以 不拿出），使得剩下的 非空 袋子中（即 至少还有一颗 魔法豆的袋子）魔法豆的数目 相等。一旦把魔法豆从袋子中取出，你不能再将它放到任何袋子中。
请返回你需要拿出魔法豆的 最少数目。
示例 1：
输入：beans = [4,1,6,5]
输出：4
解释：
 我们从有 1 个魔法豆的袋子中拿出 1 颗魔法豆。 剩下袋子中魔法豆的数目为：[4,0,6,5] 然后我们从有 6 个魔法豆的袋子中拿出 2 个魔法豆。 剩下袋子中魔法豆的数目为：[4,0,4,5] 然后我们从有 5 个魔法豆的袋子中拿出 1 个魔法豆。 剩下袋子中魔法豆的数目为：[4,0,4,4] 总共拿出了 1 + 2 + 1 = 4 个魔法豆，剩下非空袋子中魔法豆的数目相等。 没有比取出 4 个魔法豆更少的方案。  示例 2：
输入：beans = [2,10,3,2]
输出：7
解释：
 我们从有 2 个魔法豆的其中一个袋子中拿出 2 个魔法豆。 剩下袋子中魔法豆的数目为：[0,10,3,2] 然后我们从另一个有 2 个魔法豆的袋子中拿出 2 个魔法豆。 剩下袋子中魔法豆的数目为：[0,10,3,0] 然后我们从有 3 个魔法豆的袋子中拿出 3 个魔法豆。 剩下袋子中魔法豆的数目为：[0,10,0,0] 总共拿出了 2 + 2 + 3 = 7 个魔法豆，剩下非空袋子中魔法豆的数目相等。 没有比取出 7 个魔法豆更少的方案。  提示:</description>
    </item>
    
    <item>
      <title>Leetcode 2744 最大字符串配对数目</title>
      <link>https://Lu0key.github.io/post/lc-2744-find-maximum-number-of-string-pairs/</link>
      <pubDate>Wed, 17 Jan 2024 10:46:40 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/lc-2744-find-maximum-number-of-string-pairs/</guid>
      <description>2744.最大字符串配对数目 给你一个下标从 0 开始的数组 words ，数组中包含 互不相同 的字符串。
如果字符串 words[i] 与字符串 words[j] 满足以下条件，我们称它们可以匹配：
 字符串 words[i] 等于 words[j] 的反转字符串. 0 &amp;lt;= i &amp;lt; j &amp;lt; words.length  请你返回数组 words 中的 最大 匹配数目。
注意，每个字符串最多匹配一次。
示例 1：
示例 1：
输入：words = [&amp;ldquo;cd&amp;rdquo;,&amp;ldquo;ac&amp;rdquo;,&amp;ldquo;dc&amp;rdquo;,&amp;ldquo;ca&amp;rdquo;,&amp;ldquo;zz&amp;rdquo;]
输出：2 解释：在此示例中，我们可以通过以下方式匹配 2 对字符串：
 我们将第 0 个字符串与第 2 个字符串匹配，因为 word[0] 的反转字符串是 &amp;ldquo;dc&amp;rdquo; 并且等于 words[2]。 我们将第 1 个字符串与第 3 个字符串匹配，因为 word[1] 的反转字符串是 &amp;ldquo;ca&amp;rdquo; 并且等于 words[3]。  可以证明最多匹配数目是 2 。
示例 2:</description>
    </item>
    
    <item>
      <title>Leetcode 2719 統計整數數目</title>
      <link>https://Lu0key.github.io/post/lc-2719-count-of-integers/</link>
      <pubDate>Tue, 16 Jan 2024 17:51:29 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/lc-2719-count-of-integers/</guid>
      <description>2719.統計整數數目 給你兩個數字字符串 num1 和 num2，以及兩個整數 max_sum 和 min_sum. 如果一個整數滿足一下條件，我們稱它是一個好整數：
 num1 &amp;lt;= x &amp;lt;= num2 min_sum &amp;lt;= digit_sum(x) &amp;lt;= max_sum  請你返回好整數的數目。答案可能很大，請返回答案對 10^9+7 取餘后的結果。
注意，digit_sum(x) 表示 x 各位數字之和。
示例 1：
输入：num1 = &amp;ldquo;1&amp;rdquo;, num2 = &amp;ldquo;12&amp;rdquo;, min_num = 1, max_num = 8
输出：11
解释：总共有 11 个整数的数位和在 1 到 8 之间，分别是 1,2,3,4,5,6,7,8,10,11 和 12 。所以我们返回 11 。
示例 2：
输入：num1 = &amp;ldquo;1&amp;rdquo;, num2 = &amp;ldquo;5&amp;rdquo;, min_num = 1, max_num = 5</description>
    </item>
    
    <item>
      <title>Leetcode 82 删除排序链表中的重复元素Ⅱ</title>
      <link>https://Lu0key.github.io/post/lc-82-remove-duplicates-from-sorted-list-ii/</link>
      <pubDate>Mon, 15 Jan 2024 14:24:03 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/lc-82-remove-duplicates-from-sorted-list-ii/</guid>
      <description>82.删除排序链表中的重复元素Ⅱ 给定一个已排序的链表的头 head ， 给定一个已排序的链表的头 head ， 删除原始链表中所有重复数字的节点，只留下不同的数字 。返回已排序的链表。
示例 1：
示例 1：
输入: head = head = [1,2,3,3,4,4,5]
输出: [1,2,5]
示例 2:
输入: head = [1,1,1,2,3]
输出: [2,3]
提示：
 链表中节点数目在范围 [0, 300] 内 -100 &amp;lt;= Node.val &amp;lt;= 100 题目数据保证链表已经按升序 排列  Related Topics
 链表 双指针  题目链接: link
解答 这题虽然是 Medium，但是和昨天的 Easy 其实差不多，只是在删除了多余的节点外还要删除自己本身。
首先用最粗暴的方式，先遍历一遍所有节点，看看哪些节点只出现过一次，然后重建一遍链表。实现包括但不限于使用HashMap存每个元素出现的次数；一个长201的count数组统计每种可能的元素出现的次数；两个集合分别存出现过的节点和出现不止一次的节点，然后两个集合做差，最后通过筛选出来的结果重新构造节点，时间复杂度都是 O(N), 但是空间复杂度差一点。这些方法对于算法学习没什么帮助，因此直接选择更优的方法。
题目给出的链表本身就是升序的，因此我们只需要看当前节点与下一个节点的值是否相同，如果相同就跳过下一个节点，并且用一个值 isDelete 标记一下当前这个节点需要删除，然后继续此流程直到当前节点和下一个节点的值不同时，根据标记值 isDelete 判断是否要删除当前节点。
但是此方法只能当下一个节点存在时才能持续，因此结束了循环还要单独判断一下边界，因为有步骤需要跳过当前节点，因此需要记录当前节点的上一个节点，需要一个参数 pre 用于存储上一个节点。代码如下：
/** * Definition for singly-linked list.</description>
    </item>
    
    <item>
      <title>Leetcode 83 删除排序链表中的重复元素</title>
      <link>https://Lu0key.github.io/post/lc-83-remove-duplicates-from-sorted-list/</link>
      <pubDate>Sun, 14 Jan 2024 14:07:16 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/lc-83-remove-duplicates-from-sorted-list/</guid>
      <description>83.删除排序链表中的重复元素 给定一个已排序的链表的头 head ， 删除所有重复的元素，使每个元素只出现一次 。返回已排序的链表。
示例 1：
输入: head = [1,1,2]
输出: [1,2]
示例 2:
输入: head = [1,1,2,3,3]
输出: [1,2,3]
提示：
 链表中节点数目在范围 [0, 300] 内 -100 &amp;lt;= Node.val &amp;lt;= 100 题目数据保证链表已经按升序 排列  Related Topics
 链表  题目链接: link
解答 这题不愧是 Easy ，没有什么弯弯绕绕，因此只需要看看下一个和当前这个节点的值一不一样，如果一样就跳过下一个节点，如果不一样就当前节点跳到下一个节点，因为只要一直保持当前节点和下一个节点不一样就能保证只出现一次。
/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.</description>
    </item>
    
    <item>
      <title>Leetcode 338 比特位计数</title>
      <link>https://Lu0key.github.io/post/leetcode-338-counting-bits/</link>
      <pubDate>Thu, 25 Mar 2021 18:22:30 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/leetcode-338-counting-bits/</guid>
      <description>比特位计数(Counting Bits) 给定一个非负整数 num。对于 0 ≤ i ≤ num 范围中的每个数字 i ，计算其二进制数中的 1 的数目并将它们作为数组返回。
示例 1:
输入: 2输出: [0,1,1]示例 2:
输入: 5输出: [0,1,1,2,1,2]进阶:
 给出时间复杂度为**O(n*sizeof(integer))的解答非常容易。但你可以在线性时间O(n)**内用一趟扫描做到吗？ 要求算法的空间复杂度为O(n)。 你能进一步完善解法吗？要求在C++或任何其他语言中不使用任何内置函数（如 C++ 中的 __builtin_popcount）来执行此操作。。  /** * Note: The returned array must be malloced, assume caller calls free(). */ int* countBits(int num, int* returnSize){ int* ret = malloc(sizeof(int)*(num+1)); *returnSize = num+1; for (int i = 0; i &amp;lt;= num; ++i) { int count = 0; for (int offset = 30; offset &amp;gt;= 0 ; offset--) { int mask = 1&amp;lt;&amp;lt;offset; if ((i &amp;amp; mask)&amp;gt;0){ count++; } } ret[i] = count; } return ret; } 更猛的方法orz</description>
    </item>
    
    <item>
      <title>Leetcode 986 区间列表的交集</title>
      <link>https://Lu0key.github.io/post/leetcode-986-interval-list-intersections/</link>
      <pubDate>Thu, 25 Mar 2021 18:19:26 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/leetcode-986-interval-list-intersections/</guid>
      <description>区间列表的交集(Interval List Intersections) 给定两个由一些 闭区间 组成的列表，firstList 和 secondList ，其中 firstList[i] = [start_i, end_i] 而 secondList[j] = [start_j, end_j] 。每个区间列表都是成对 不相交 的，并且 已经排序 。
返回这 两个区间列表的交集 。
形式上，闭区间 [a, b]（其中 a &amp;lt;= b）表示实数 x 的集合，而 a &amp;lt;= x &amp;lt;= b 。
两个闭区间的 交集 是一组实数，要么为空集，要么为闭区间。例如，[1, 3] 和 [2, 4] 的交集为 [2, 3] 。
示例 1： 输入：firstList = [[0,2],[5,10],[13,23],[24,25]], secondList = [[1,5],[8,12],[15,24],[25,26]]输出：[[1,2],[5,5],[8,10],[15,23],[24,24],[25,25]]示例 2：
输入：firstList = [[1,3],[5,9]], secondList = []输出：[]示例 3：</description>
    </item>
    
    <item>
      <title>Leetcode 451 根据字符出现频率排序</title>
      <link>https://Lu0key.github.io/post/leetcode-451-sort-characters-by-frequency/</link>
      <pubDate>Thu, 25 Mar 2021 18:15:20 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/leetcode-451-sort-characters-by-frequency/</guid>
      <description>根据字符出现频率排序(Sort Characters By Frequency) 给定一个字符串，请将字符串里的字符按照出现的频率降序排列。
示例 1:
输入:&amp;quot;tree&amp;quot;输出:&amp;quot;eert&amp;quot;解释:&#39;e&#39;出现两次，&#39;r&#39;和&#39;t&#39;都只出现一次。因此&#39;e&#39;必须出现在&#39;r&#39;和&#39;t&#39;之前。此外，&amp;quot;eetr&amp;quot;也是一个有效的答案。示例 2:
输入:&amp;quot;cccaaa&amp;quot;输出:&amp;quot;cccaaa&amp;quot;解释:&#39;c&#39;和&#39;a&#39;都出现三次。此外，&amp;quot;aaaccc&amp;quot;也是有效的答案。注意&amp;quot;cacaca&amp;quot;是不正确的，因为相同的字母必须放在一起。示例 3:
输入:&amp;quot;Aabb&amp;quot;输出:&amp;quot;bbAa&amp;quot;解释:此外，&amp;quot;bbaA&amp;quot;也是一个有效的答案，但&amp;quot;Aabb&amp;quot;是不正确的。注意&#39;A&#39;和&#39;a&#39;被认为是两种不同的字符。char * frequencySort(char * s){ int count[128] = {0}; for (int i = 0; i &amp;lt; strlen(s); ++i) { count[s[i]]++; } for (int k = 0; k &amp;lt; strlen(s); ++k) { for (int i = 0; i+1 &amp;lt; strlen(s); ++i) { if(count[s[i]] &amp;lt; count[s[i+1]] || count[s[i]] == count[s[i+1]] &amp;amp;&amp;amp; s[i] &amp;gt; s[i+1]){ char temp = s[i]; s[i] = s[i+1]; s[i+1] = temp; } } } return s; } 可以用，但是会TLE，一般遇到排序的时候，如果没有用快排，而是用冒泡排序这种O(n^2)时间复杂度的算法，都很可能会超时</description>
    </item>
    
    <item>
      <title>Leetcode 230 二叉搜索树中第K小的元素</title>
      <link>https://Lu0key.github.io/post/leetcode-230-kth-smallest-element-in-a-bst/</link>
      <pubDate>Thu, 25 Mar 2021 18:09:50 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/leetcode-230-kth-smallest-element-in-a-bst/</guid>
      <description>二叉搜索树中第K小的元素(Kth Smallest Element in a BST) 给定一个二叉搜索树的根节点 root ，和一个整数 k ，请你设计一个算法查找其中第 k 个最小元素（从 1 开始计数）。
示例 1： 输入：root = [3,1,4,null,2], k = 1输出：1示例 2： 输入：root = [5,3,6,2,4,null,null,1], k = 3输出：3提示：
 树中的节点数为 n 。 1 &amp;lt;= k &amp;lt;= n &amp;lt;= 10^4 0 &amp;lt;= Node.val &amp;lt;= 10^4  **进阶：**如果二叉搜索树经常被修改（插入/删除操作）并且你需要频繁地查找第 k 小的值，你将如何优化算法？
/** * Definition for a binary tree node. * struct TreeNode { * int val; * struct TreeNode *left; * struct TreeNode *right; * }; */ int getSize(struct TreeNode* root){ if (root == NULL) return 0; return getSize(root-&amp;gt;left)+getSize(root-&amp;gt;right)+1; } int kthSmallest(struct TreeNode* root, int k){ int leftSize = getSize(root-&amp;gt;left); if (k &amp;lt;= leftSize){ return kthSmallest(root-&amp;gt;left, k); } if (k &amp;lt;= leftSize+1){ return root-&amp;gt;val; } return kthSmallest(root-&amp;gt;right,k-leftSize-1); } 好爽，这个比较简单，写的很爽，可能因为简单？</description>
    </item>
    
    <item>
      <title>Leetcode 438 找到字符串中所有字母异位词</title>
      <link>https://Lu0key.github.io/post/leetcode-438-find-all-anagrams-in-a-string/</link>
      <pubDate>Thu, 25 Mar 2021 18:03:24 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/leetcode-438-find-all-anagrams-in-a-string/</guid>
      <description>找到字符串中所有字母异位词(Find All Anagrams in a String) 给定一个字符串 s 和一个非空字符串 p，找到 s 中所有是 p 的字母异位词的子串，返回这些子串的起始索引。
字符串只包含小写英文字母，并且字符串 s 和 p 的长度都不超过 20100。
说明：
 字母异位词指字母相同，但排列不同的字符串。 不考虑答案输出的顺序。  示例 1:
输入:s: &amp;quot;cbaebabacd&amp;quot; p: &amp;quot;abc&amp;quot;输出:[0, 6]解释:起始索引等于 0 的子串是 &amp;quot;cba&amp;quot;, 它是 &amp;quot;abc&amp;quot; 的字母异位词。起始索引等于 6 的子串是 &amp;quot;bac&amp;quot;, 它是 &amp;quot;abc&amp;quot; 的字母异位词。示例 2:
输入:s: &amp;quot;abab&amp;quot; p: &amp;quot;ab&amp;quot;输出:[0, 1, 2]解释:起始索引等于 0 的子串是 &amp;quot;ab&amp;quot;, 它是 &amp;quot;ab&amp;quot; 的字母异位词。起始索引等于 1 的子串是 &amp;quot;ba&amp;quot;, 它是 &amp;quot;ab&amp;quot; 的字母异位词。起始索引等于 2 的子串是 &amp;quot;ab&amp;quot;, 它是 &amp;quot;ab&amp;quot; 的字母异位词。/** * Note: The returned array must be malloced, assume caller calls free().</description>
    </item>
    
    <item>
      <title>Leetcode 567 字符串的排列</title>
      <link>https://Lu0key.github.io/post/leetcode-567-permutation-in-string/</link>
      <pubDate>Thu, 25 Mar 2021 16:55:44 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/leetcode-567-permutation-in-string/</guid>
      <description>字符串的排列(Permutation in String) 给定两个字符串 s1 和 s2，写一个函数来判断 s2 是否包含 s1 的排列。
换句话说，第一个字符串的排列之一是第二个字符串的 子串 。
示例 1：
输入: s1 = &amp;quot;ab&amp;quot; s2 = &amp;quot;eidbaooo&amp;quot;输出: True解释: s2 包含 s1 的排列之一 (&amp;quot;ba&amp;quot;).示例 2：
输入: s1= &amp;quot;ab&amp;quot; s2 = &amp;quot;eidboaoo&amp;quot;输出: False提示：
 输入的字符串只包含小写字母 两个字符串的长度都在 [1, 10,000] 之间。  和上一题几乎一样，甚至更简单
bool checkInclusion(char * s1, char * s2){ int lenS1 = strlen(s1); int lenS2 = strlen(s2); if (lenS1&amp;gt;lenS2) return false; int Diff[&amp;#39;z&amp;#39;-&amp;#39;a&amp;#39;+1] = {0}; for (int i = 0; i &amp;lt; lenS1; ++i) Diff[s1[i]-&amp;#39;a&amp;#39;]--; for (int i = 0; i &amp;lt; lenS1; ++i) Diff[s2[i]-&amp;#39;a&amp;#39;]++; int diffCount = 0; for (char c = &amp;#39;a&amp;#39;; c &amp;lt;= &amp;#39;z&amp;#39;; c++) { if (Diff[c-&amp;#39;a&amp;#39;] !</description>
    </item>
    
    <item>
      <title>Leetcode 540 有序数组中的单一元素</title>
      <link>https://Lu0key.github.io/post/leetcode-540-single-element-in-a-sorted-array/</link>
      <pubDate>Thu, 25 Mar 2021 16:53:45 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/leetcode-540-single-element-in-a-sorted-array/</guid>
      <description>有序数组中的单一元素(Single Element in a Sorted Array) 给定一个只包含整数的有序数组，每个元素都会出现两次，唯有一个数只会出现一次，找出这个数。
示例 1:
输入: [1,1,2,3,3,4,4,8,8]输出: 2示例 2:
输入: [3,3,7,7,10,11,11]输出: 10注意: 您的方案应该在 O(log n)时间复杂度和 O(1)空间复杂度中运行。
int singleNonDuplicate(int* nums, int numsSize){ int ans = nums[0]; for (int i = 1; i &amp;lt; numsSize; ++i) { ans ^= nums[i]; } return ans; } 这个做法和之前的做法是一模一样的，这边应该有更妙的做法，毕竟条件更多了
int singleNonDuplicate(int* nums, int numsSize){ for (int i = 0; i+1 &amp;lt; numsSize; i+=2) { if (nums[i] != nums[i+1]){ return nums[i]; } } return nums[numsSize-1]; } 这样的做法也是比较简单的，而且不用用到异或，更清楚，但是时间复杂度还是O(n)</description>
    </item>
    
    <item>
      <title>Leetcode 733 图像渲染</title>
      <link>https://Lu0key.github.io/post/leetcode-733-flood-fill/</link>
      <pubDate>Thu, 25 Mar 2021 16:51:06 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/leetcode-733-flood-fill/</guid>
      <description>图像渲染(Flood Fill) 有一幅以二维整数数组表示的图画，每一个整数表示该图画的像素值大小，数值在 0 到 65535 之间。
给你一个坐标 (sr, sc) 表示图像渲染开始的像素值（行 ，列）和一个新的颜色值 newColor，让你重新上色这幅图像。
为了完成上色工作，从初始坐标开始，记录初始坐标的上下左右四个方向上像素值与初始坐标相同的相连像素点，接着再记录这四个方向上符合条件的像素点与他们对应四个方向上像素值与初始坐标相同的相连像素点，……，重复该过程。将所有有记录的像素点的颜色值改为新的颜色值。
最后返回经过上色渲染后的图像。
示例 1:
输入: image = [[1,1,1],[1,1,0],[1,0,1]]sr = 1, sc = 1, newColor = 2输出: [[2,2,2],[2,2,0],[2,0,1]]解析: 在图像的正中间，(坐标(sr,sc)=(1,1)),在路径上所有符合条件的像素点的颜色都被更改成2。注意，右下角的像素没有更改为2，因为它不是在上下左右四个方向上与初始点相连的像素点。注意:
 image 和 image[0] 的长度在范围 [1, 50] 内。 给出的初始点将满足 0 &amp;lt;= sr &amp;lt; image.length 和 0 &amp;lt;= sc &amp;lt; image[0].length。 image[i][j] 和 newColor 表示的颜色值在范围 [0, 65535]内。  /** * Return an array of arrays of size *returnSize.</description>
    </item>
    
    <item>
      <title>Leetcode 997 找到小镇的法官</title>
      <link>https://Lu0key.github.io/post/leetcode-997-find-the-town-judge/</link>
      <pubDate>Thu, 25 Mar 2021 16:48:54 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/leetcode-997-find-the-town-judge/</guid>
      <description>找到小镇的法官((Find the Town Judge) 在一个小镇里，按从 1 到 N 标记了 N 个人。传言称，这些人中有一个是小镇上的秘密法官。
如果小镇的法官真的存在，那么：
1. 小镇的法官不相信任何人。2. 每个人（除了小镇法官外）都信任小镇的法官。3. 只有一个人同时满足属性 1 和属性 2 。 给定数组 trust，该数组由信任对 trust[i] = [a, b] 组成，表示标记为 a 的人信任标记为 b 的人。
如果小镇存在秘密法官并且可以确定他的身份，请返回该法官的标记。否则，返回 -1。
示例 1：
输入：N = 2, trust = [[1,2]]输出：2示例 2：
输入：N = 3, trust = [[1,3],[2,3]]输出：3示例 3：
输入：N = 3, trust = [[1,3],[2,3],[3,1]]输出：-1示例 4：
输入：N = 3, trust = [[1,2],[2,3]]输出：-1示例 5：</description>
    </item>
    
    <item>
      <title>Leetcode 367 有效的完全平方数</title>
      <link>https://Lu0key.github.io/post/leetcode-367-valid-perfect-square/</link>
      <pubDate>Thu, 25 Mar 2021 16:46:34 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/leetcode-367-valid-perfect-square/</guid>
      <description>有效的完全平方数(Valid Perfect Square) 给定一个 正整数 num ，编写一个函数，如果 num 是一个完全平方数，则返回 true ，否则返回 false 。
进阶：不要 使用任何内置的库函数，如 sqrt 。
示例 1：
输入：num = 16输出：true示例 2：
输入：num = 14输出：false提示：
 1 &amp;lt;= num &amp;lt;= 2^31 - 1  bool isPerfectSquare(int num){ for (int i = 0; i &amp;lt; 46341; ++i) { if (i*i == num) return true; if (i*i &amp;gt; num) return false; } return false; } 暴力！因为46341的平方会超过整数的最大值，因此我们用46341，或者用long long 之类的</description>
    </item>
    
    <item>
      <title>Leetcode 1232 缀点成线</title>
      <link>https://Lu0key.github.io/post/leetcode-1232-check-if-it-is-a-straight-line/</link>
      <pubDate>Thu, 25 Mar 2021 16:40:22 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/leetcode-1232-check-if-it-is-a-straight-line/</guid>
      <description>缀点成线(Check If It Is a Straight Line) 在一个 XY 坐标系中有一些点，我们用数组 coordinates 来分别记录它们的坐标，其中 coordinates[i] = [x, y] 表示横坐标为 x、纵坐标为 y 的点。
请你来判断，这些点是否在该坐标系中属于同一条直线上，是则返回 true，否则请返回 false。
示例 1： 输入：coordinates = [[1,2],[2,3],[3,4],[4,5],[5,6],[6,7]]输出：true示例 2： 输入：coordinates = [[1,1],[2,2],[3,4],[4,5],[5,6],[7,7]]输出：false提示：
 2 &amp;lt;= coordinates.length &amp;lt;= 1000 coordinates[i].length == 2 -10^4 &amp;lt;= coordinates[i][0], coordinates[i][1] &amp;lt;= 10^4 coordinates 中不含重复的点  bool checkStraightLine(int** coordinates, int coordinatesSize, int* coordinatesColSize){ for (int i = 0; i &amp;lt; coordinatesSize; ++i) { for (int j = i+1; j &amp;lt; coordinatesSize; ++j) { for (int k = j+1; k &amp;lt; coordinatesSize; ++k) { int x1 = coordinates[i][0]; int y1 = coordinates[i][1]; int x2 = coordinates[j][0]; int y2 = coordinates[j][1]; int x3 = coordinates[k][0]; int y3 = coordinates[k][1]; if ((y2-y1)*(x3-x1) !</description>
    </item>
    
    <item>
      <title>Leetcode 993 二叉树的堂兄弟结点</title>
      <link>https://Lu0key.github.io/post/leetcode-993-cousins-in-binary-tree/</link>
      <pubDate>Thu, 25 Mar 2021 16:38:13 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/leetcode-993-cousins-in-binary-tree/</guid>
      <description>二叉树的堂兄弟结点(Cousins in Binary Tree) 在二叉树中，根节点位于深度 0 处，每个深度为 k 的节点的子节点位于深度 k+1 处。
如果二叉树的两个节点深度相同，但 父节点不同 ，则它们是一对堂兄弟节点。
我们给出了具有唯一值的二叉树的根节点 root ，以及树中两个不同节点的值 x 和 y 。
只有与值 x 和 y 对应的节点是堂兄弟节点时，才返回 true 。否则，返回 false。
示例 1： 输入：root = [1,2,3,4], x = 4, y = 3输出：false示例 2： 输入：root = [1,2,3,null,4,null,5], x = 5, y = 4输出：true示例 3： 输入：root = [1,2,3,null,4], x = 2, y = 3输出：false提示：
 二叉树的节点数介于 2 到 100 之间。 每个节点的值都是唯一的、范围为 1 到 100 的整数。  /** * Definition for a binary tree node.</description>
    </item>
    
    <item>
      <title>Leetcode 169 多数元素</title>
      <link>https://Lu0key.github.io/post/leetcode-169-majority-element/</link>
      <pubDate>Thu, 25 Mar 2021 14:30:35 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/leetcode-169-majority-element/</guid>
      <description>多数元素(Majority Element) 给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n/2 ⌋ 的元素。
你可以假设数组是非空的，并且给定的数组总是存在多数元素。
示例 1：
输入：[3,2,3]输出：3示例 2：
输入：[2,2,1,1,1,2,2]输出：2进阶：
 尝试设计时间复杂度为 O(n)、空间复杂度为 O(1) 的算法解决此问题。  int majorityElement(int* nums, int numsSize){ while (true){ int i = rand() % numsSize; int count = 0; for(int j =0 ; j&amp;lt;numsSize; j++){ if(nums[j] == nums[i]){ count++; } } if (count &amp;gt; numsSize/2){ return nums[i]; } } return 0; } 因为有一半以上的概率获得的数字是占一半以上的元素，效率难以评估
int cmp(const void* a, const void* b){ return *(int *)a- *(int *)b; } int majorityElement(int* nums, int numsSize){ qsort(nums, numsSize, sizeof(int), cmp); return nums[numsSize/2]; } 看到这个题目，应该可以很自然的想到哈希表，但是C本身不自带，手动实现Hash表</description>
    </item>
    
    <item>
      <title>Leetcode 387 字符串中的第一个唯一字符</title>
      <link>https://Lu0key.github.io/post/leetcode-387-first-unique-character-in-a-string/</link>
      <pubDate>Thu, 25 Mar 2021 14:28:37 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/leetcode-387-first-unique-character-in-a-string/</guid>
      <description>字符串中的第一个唯一字符(First Unique Character in a String) 给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。
示例：
s = &amp;quot;leetcode&amp;quot;返回 0s = &amp;quot;loveleetcode&amp;quot;返回 2提示： 你可以假定该字符串只包含小写字母。
int firstUniqChar(char * s){ int sSize = strlen(s); for (int i = 0; i &amp;lt; sSize; i++){ if (s[i] == &amp;#39;-&amp;#39;) continue; bool isUnique = true; for(int j =i+1; j&amp;lt;sSize; j++){ if (s[j] == s[i]){ isUnique = false; s[j] = &amp;#39;-&amp;#39;; } } if (isUnique){ return i; } } return -1; } 这种时间复杂度为O(n^2)</description>
    </item>
    
    <item>
      <title>Leetcode 476 数字的补数</title>
      <link>https://Lu0key.github.io/post/leetcode-476-number-complement/</link>
      <pubDate>Thu, 25 Mar 2021 14:24:40 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/leetcode-476-number-complement/</guid>
      <description>数字的补数(Number Complement) 给你一个 正 整数 num ，输出它的补数。补数是对该数的二进制表示取反。
示例 1：
输入：num = 5输出：2解释：5 的二进制表示为 101（没有前导零位），其补数为 010。所以你需要输出 2 。示例 2：
输入：num = 1输出：0解释：1 的二进制表示为 1（没有前导零位），其补数为 0。所以你需要输出 0 。提示：
 给定的整数 num 保证在 32 位带符号整数的范围内。 num &amp;gt;= 1 你可以假定二进制数不包含前导零位。 本题与 1009 https://leetcode-cn.com/problems/complement-of-base-10-integer/ 相同  int findComplement(int num){ int firstOnePosition = -1; int ans = 0; for (int i =30; i&amp;gt;=0; i--){ int mask = (1 &amp;lt;&amp;lt; i); if(firstOnePosition&amp;lt;0 &amp;amp;&amp;amp; (num &amp;amp; mask)!</description>
    </item>
    
    <item>
      <title>Leetcode 383 赎金信</title>
      <link>https://Lu0key.github.io/post/leetcode-383-ransom-note/</link>
      <pubDate>Thu, 25 Mar 2021 14:21:59 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/leetcode-383-ransom-note/</guid>
      <description>赎金信(Ransom Not) 给定一个赎金信 (ransom) 字符串和一个杂志(magazine)字符串，判断第一个字符串 ransom 能不能由第二个字符串 magazines 里面的字符构成。如果可以构成，返回 true ；否则返回 false。
(题目说明：为了不暴露赎金信字迹，要从杂志上搜索各个需要的字母，组成单词来表达意思。杂志字符串中的每个字符只能在赎金信字符串中使用一次。)
示例 1：
输入：ransomNote = &amp;quot;a&amp;quot;, magazine = &amp;quot;b&amp;quot;输出：false示例 2：
输入：ransomNote = &amp;quot;aa&amp;quot;, magazine = &amp;quot;ab&amp;quot;输出：false示例 3：
输入：ransomNote = &amp;quot;aa&amp;quot;, magazine = &amp;quot;aab&amp;quot;输出：true提示：
 你可以假设两个字符串均只含有小写字母。  bool canConstruct(char * ransomNote, char * magazine){ int ransomNoteSize = strlen(ransomNote); int magazineSize = strlen(magazine); for(int i =0;i&amp;lt; ransomNoteSize; i++){ bool isFound = false; for(int j = 0; j &amp;lt; magazineSize; j++) { if(magazine[j] == ransomNote[i]) { isFound = true; magazine[j] = &amp;#39;-&amp;#39;; break; } } if (!</description>
    </item>
    
    <item>
      <title>Leetcode 278 第一个错误的版本</title>
      <link>https://Lu0key.github.io/post/leetcode-278-first-bad-version/</link>
      <pubDate>Thu, 25 Mar 2021 14:16:28 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/leetcode-278-first-bad-version/</guid>
      <description>第一个错误的版本(First Bad Version) 你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。
假设你有 n 个版本 [1, 2, ..., n]，你想找出导致之后所有版本出错的第一个错误的版本。
你可以通过调用 bool isBadVersion(version) 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。
示例:
给定 n = 5，并且 version = 4 是第一个错误的版本。调用 isBadVersion(3) -&amp;gt; false调用 isBadVersion(5) -&amp;gt; true调用 isBadVersion(4) -&amp;gt; true所以，4 是第一个错误的版本。 // The API isBadVersion is defined for you. // bool isBadVersion(int version);  int firstBadVersion(int n) { for (int ans = 1; ans &amp;lt;=n; ans++){ if(isBadVersion(ans) &amp;amp;&amp;amp; !isBadVersion(ans-1)){ return ans; } } return 0; } 上面这种方法是最直接的，但是相对的，但是超慢，会超时</description>
    </item>
    
    <item>
      <title>Leetcode 124 二叉树中的最大路径和</title>
      <link>https://Lu0key.github.io/post/leetcode-124-binary-tree-maximum-path-sum/</link>
      <pubDate>Tue, 23 Mar 2021 15:10:24 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/leetcode-124-binary-tree-maximum-path-sum/</guid>
      <description>二叉树中的最大路径和(Binary Tree Maximum Path Sum) 路径 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个 节点，且不一定经过根节点。
路径和 是路径中各节点值的总和。
给你一个二叉树的根节点 root ，返回其 最大路径和 。
示例 1： 输入：root = [1,2,3]输出：6解释：最优路径是 2 -&amp;gt; 1 -&amp;gt; 3 ，路径和为 2 + 1 + 3 = 6示例 2： 输入：root = [-10,9,20,null,null,15,7]输出：42解释：最优路径是 15 -&amp;gt; 20 -&amp;gt; 7 ，路径和为 15 + 20 + 7 = 42提示：
 树中节点数目范围是 [1, 3 * 10^4] -1000 &amp;lt;= Node.val &amp;lt;= 1000  /** * Definition for a binary tree node.</description>
    </item>
    
    <item>
      <title>Leetcode 221 最大正方形</title>
      <link>https://Lu0key.github.io/post/leetcode-221-maximal-square/</link>
      <pubDate>Tue, 23 Mar 2021 15:08:31 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/leetcode-221-maximal-square/</guid>
      <description>最大正方形(Maximal Square) 在一个由 &#39;0&#39; 和 &#39;1&#39; 组成的二维矩阵内，找到只包含 &#39;1&#39; 的最大正方形，并返回其面积。
示例 1：
输入：matrix = [[&amp;quot;1&amp;quot;,&amp;quot;0&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;0&amp;quot;,&amp;quot;0&amp;quot;],[&amp;quot;1&amp;quot;,&amp;quot;0&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;1&amp;quot;],[&amp;quot;1&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;1&amp;quot;],[&amp;quot;1&amp;quot;,&amp;quot;0&amp;quot;,&amp;quot;0&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;0&amp;quot;]]输出：4示例 2：
输入：matrix = [[&amp;quot;0&amp;quot;,&amp;quot;1&amp;quot;],[&amp;quot;1&amp;quot;,&amp;quot;0&amp;quot;]]输出：1示例 3：
输入：matrix = [[&amp;quot;0&amp;quot;]]输出：0提示：
 m == matrix.length n == matrix[i].length 1 &amp;lt;= m, n &amp;lt;= 300 matrix[i][j] 为 &#39;0&#39; 或 &#39;1&#39;  int min(int a, int b){ if (a&amp;lt;b){ return a; }else{ return b; } } bool noZero(char** matrix, int row ,int col ,int size){ for(int dr = 0;dr &amp;lt; size;dr++){ for(int dc = 0;dc &amp;lt; size; dc++){ if(matrix[row+dr][col+dc] == &amp;#39;0&amp;#39;){ return false; } } } return true; } int maximalSquare(char** matrix, int matrixSize, int* matrixColSize){ // if (matrixSize == 0) return 0;  int rows = matrixSize; int cols = matrixColSize[0]; int maxSize = 0; for(int row =0 ;row &amp;lt; rows;row++){ for(int col = 0;col&amp;lt;cols; col++){ for(int size =1;size&amp;lt;=min(rows-row,cols-col);size++){ if(noZero(matrix, row, col, size) &amp;amp;&amp;amp; size &amp;gt; maxSize){ maxSize = size; } } } } return maxSize * maxSize; } 勉强过了</description>
    </item>
    
    <item>
      <title>Leetcode 1143 最长公共子序列</title>
      <link>https://Lu0key.github.io/post/leetcode-1143-longest-common-subsequence/</link>
      <pubDate>Tue, 23 Mar 2021 15:04:39 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/leetcode-1143-longest-common-subsequence/</guid>
      <description>最长公共子序列(Longest Common Subsequence) 给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列的长度。
一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。 例如，&amp;ldquo;ace&amp;rdquo; 是 &amp;ldquo;abcde&amp;rdquo; 的子序列，但 &amp;ldquo;aec&amp;rdquo; 不是 &amp;ldquo;abcde&amp;rdquo; 的子序列。两个字符串的「公共子序列」是这两个字符串所共同拥有的子序列。
若这两个字符串没有公共子序列，则返回 0。
示例 1:
输入：text1 = &amp;quot;abcde&amp;quot;, text2 = &amp;quot;ace&amp;quot; 输出：3 解释：最长公共子序列是 &amp;quot;ace&amp;quot;，它的长度为 3。示例 2:
输入：text1 = &amp;quot;abc&amp;quot;, text2 = &amp;quot;abc&amp;quot;输出：3解释：最长公共子序列是 &amp;quot;abc&amp;quot;，它的长度为 3。示例 3:
输入：text1 = &amp;quot;abc&amp;quot;, text2 = &amp;quot;def&amp;quot;输出：0解释：两个字符串没有公共子序列，返回 0。提示:
 1 &amp;lt;= text1.length &amp;lt;= 1000 1 &amp;lt;= text2.length &amp;lt;= 1000 输入的字符串只含有小写英文字符。  int lcs(char* text1, char* text2, int m, int n) { if(m == 0||n == 0) return 0; if(text1[m-1] == text2[n-1]) { return lcs(text1,text2,m-1,n-1)+1; }else { int discard1 = lcs(text1, text2, m-1, n); int discard2 = lcs(text1, text2, m, n-1); if(discard1 &amp;gt; discard2){ return discard1; }else { return discard2; } } } int longestCommonSubsequence(char* text1, char* text2){ int len1 = strlen(text1); int len2 = strlen(text2); return lcs(text1, text2, len1, len2); } 但是这种方法显然会爆炸，递归太多，超时</description>
    </item>
    
    <item>
      <title>Leetcode 55 跳跃游戏</title>
      <link>https://Lu0key.github.io/post/leetcode-55-jump-game/</link>
      <pubDate>Tue, 23 Mar 2021 15:02:46 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/leetcode-55-jump-game/</guid>
      <description>跳跃游戏(Jump Game) 给定一个非负整数数组 nums ，你最初位于数组的 第一个下标 。
数组中的每个元素代表你在该位置可以跳跃的最大长度。
判断你是否能够到达最后一个下标。
示例 1：
输入：nums = [2,3,1,1,4]输出：true解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。示例 2：
输入：nums = [3,2,1,0,4]输出：false解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。提示：
 1 &amp;lt;= nums.length &amp;lt;= 3 * 10^4 0 &amp;lt;= nums[i] &amp;lt;= 10^5  bool canJump(int* nums, int numsSize){ int start = 0; printf(&amp;#34;%d\n&amp;#34;,start); while(start &amp;lt;numsSize){ int newIndex = -1; if(start+nums[start]&amp;gt;=numsSize-1) return true; for(int i =1;i&amp;lt;=nums[start];i++){ if(i+nums[start+i]&amp;gt;nums[start]){ if(newIndex == -1){ newIndex = i+start; }else if(i+nums[start +i]&amp;gt;newIndex-start+nums[newIndex]){ newIndex = i+start; } } } if(newIndex == -1) return false; start = newIndex; } return false; } yeah，写出来了，看看老师怎么写的</description>
    </item>
    
    <item>
      <title>Leetcode 16.25 LRU 缓存</title>
      <link>https://Lu0key.github.io/post/leetcode-16.25-lru-cache-lcci/</link>
      <pubDate>Tue, 23 Mar 2021 14:54:41 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/leetcode-16.25-lru-cache-lcci/</guid>
      <description>LRU 缓存(LRU Cache) 设计和构建一个“最近最少使用”缓存，该缓存会删除最近最少使用的项目。缓存应该从键映射到值(允许你插入和检索特定键对应的值)，并在初始化时指定最大容量。当缓存被填满时，它应该删除最近最少使用的项目。
它应该支持以下操作： 获取数据 get 和 写入数据 put 。
获取数据 get(key) - 如果密钥 (key) 存在于缓存中，则获取密钥的值（总是正数），否则返回 -1。 写入数据 put(key, value) - 如果密钥不存在，则写入其数据值。当缓存容量达到上限时，它应该在写入新数据之前删除最近最少使用的数据值，从而为新的数据值留出空间。
示例:
LRUCache cache = new LRUCache( 2 /* 缓存容量 */ );cache.put(1, 1);cache.put(2, 2);cache.get(1); // 返回 1cache.put(3, 3); // 该操作会使得密钥 2 作废cache.get(2); // 返回 -1 (未找到)cache.put(4, 4); // 该操作会使得密钥 1 作废cache.get(1); // 返回 -1 (未找到)cache.get(3); // 返回 3cache.get(4); // 返回 4自己实现一个简单的缓存</description>
    </item>
    
    <item>
      <title>Leetcode 201 数字范围按位与</title>
      <link>https://Lu0key.github.io/post/leetcode-201-bitwise-and-of-numbers-range/</link>
      <pubDate>Tue, 23 Mar 2021 14:52:40 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/leetcode-201-bitwise-and-of-numbers-range/</guid>
      <description>数字范围按位与(Bitwise AND of Numbers Range) 给你两个整数 left 和 right ，表示区间 [left, right] ，返回此区间内所有数字 按位与 的结果（包含 left 、right 端点）。
示例 1：
输入：left = 5, right = 7输出：4示例 2：
输入：left = 0, right = 0输出：0示例 3：
输入：left = 1, right = 2147483647输出：0提示：
 0 &amp;lt;= left &amp;lt;= right &amp;lt;= 2^31 - 1  int rangeBitwiseAnd(int left, int right){ if(left == 0) return 0; int a = right; for(int i = left;i&amp;lt;right;i++){ a &amp;amp;=i; } return a; } 这样显然会超时</description>
    </item>
    
    <item>
      <title>Leetcode 560 和为K的子数组</title>
      <link>https://Lu0key.github.io/post/leetcode-560-subarray-sum-equals-k/</link>
      <pubDate>Tue, 23 Mar 2021 14:50:23 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/leetcode-560-subarray-sum-equals-k/</guid>
      <description>和为K的子数组(Subarray Sum Equals K) 给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数。
示例 1 :
输入:nums = [1,1,1], k = 2输出: 2 , [1,1] 与 [1,1] 为两种不同的情况。说明 :
 数组的长度为 [1, 20,000]。 数组中元素的范围是 [-1000, 1000] ，且整数 k 的范围是 [-1e7, 1e7]。  int subarraySum(int* nums, int numsSize, int k){ int count = 0; for(int i =0;i&amp;lt;numsSize;i++){ int sum = 0; for(int j=i;j&amp;lt;numsSize;j++){ sum+=nums[j]; if(sum == k){ count++; } } } return count; } O(n^2) 会超时哦</description>
    </item>
    
    <item>
      <title>Leetcode 1008 前序遍历构造二叉搜索树</title>
      <link>https://Lu0key.github.io/post/leetcode-1008-construct-binary-search-tree-from-preorder-traversal/</link>
      <pubDate>Tue, 23 Mar 2021 14:47:50 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/leetcode-1008-construct-binary-search-tree-from-preorder-traversal/</guid>
      <description>前序遍历构造二叉搜索树(Construct Binary Search Tree from Preorder Traversal) 返回与给定前序遍历 preorder 相匹配的二叉搜索树（binary search tree）的根结点。
(回想一下，二叉搜索树是二叉树的一种，其每个节点都满足以下规则，对于 node.left 的任何后代，值总 &amp;lt; node.val，而 node.right 的任何后代，值总 &amp;gt; node.val。此外，前序遍历首先显示节点 node 的值，然后遍历 node.left，接着遍历 node.right。）
题目保证，对于给定的测试用例，总能找到满足要求的二叉搜索树。
示例：
输入：[8,5,1,7,10,12]输出：[8,5,10,1,7,null,12]提示：
 1 &amp;lt;= preorder.length &amp;lt; = 100 1 &amp;lt;= preorder[i] &amp;lt;= 10^8 preorder 中的值互不相同  /** * Definition for a binary tree node. * struct TreeNode { * int val; * struct TreeNode *left; * struct TreeNode *right; * }; */ struct TreeNode* bstFromPreorderRanged(int* preorder, int start, int end){ if(start == end) return NULL; struct TreeNode* root = malloc(sizeof(struct TreeNode)); root-&amp;gt;val = preorder[start]; int i = start+1; while (i&amp;lt;end &amp;amp;&amp;amp; preorder[i]&amp;lt;root-&amp;gt;val){ i++; } root-&amp;gt;left = bstFromPreorderRanged(preorder, start+1, i); root-&amp;gt;right = bstFromPreorderRanged(preorder,i,end); return root; } struct TreeNode* bstFromPreorder(int* preorder, int preorderSize){ return bstFromPreorderRanged(preorder,0,preorderSize); } 提高效率</description>
    </item>
    
    <item>
      <title>Leetcode 33 搜索旋转排序数组</title>
      <link>https://Lu0key.github.io/post/leetcode-33-search-in-rotated-sorted-array/</link>
      <pubDate>Tue, 23 Mar 2021 14:44:28 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/leetcode-33-search-in-rotated-sorted-array/</guid>
      <description>搜索旋转排序数组(Search in Rotated Sorted Array) 整数数组 nums 按升序排列，数组中的值 互不相同 。
在传递给函数之前，nums 在预先未知的某个下标 k（0 &amp;lt;= k &amp;lt; nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。
给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的索引，否则返回 -1 。
示例 1：
输入：nums = [4,5,6,7,0,1,2], target = 0输出：4示例 2：
输入：nums = [4,5,6,7,0,1,2], target = 3输出：-1示例 3：
输入：nums = [1], target = 0输出：-1提示：</description>
    </item>
    
    <item>
      <title>Leetcode 64 最小路径和</title>
      <link>https://Lu0key.github.io/post/leetcode-64-minimum-path-sum/</link>
      <pubDate>Tue, 23 Mar 2021 14:41:59 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/leetcode-64-minimum-path-sum/</guid>
      <description>最小路径和(Minimum Path Sum) 给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。
说明： 每次只能向下或者向右移动一步。
示例 1： 输入：grid = [[1,3,1],[1,5,1],[4,2,1]]输出：7解释：因为路径 1→3→1→1→1 的总和最小。示例 2：
输入：grid = [[1,2,3],[4,5,6]]输出：12提示：
 m == grid.length n == grid[i].length 1 &amp;lt;= m, n &amp;lt;= 200 0 &amp;lt;= grid[i][j] &amp;lt;= 100  int minPartialPathSum(int** grid,int** path,int ROWS,int COLS,int i,int j){ if (path[i][j]!=-1){ return path[i][j]; } int right = grid[i][j]; int down = grid[i][j]; if (i==ROWS-1&amp;amp;&amp;amp;j==COLS-1){ path[i][j] = grid[i][j]; return grid[i][j]; } if(j&amp;lt;COLS-1){ right +=minPartialPathSum(grid,path,ROWS,COLS,i,j+1); } if(i&amp;lt;ROWS-1){ down +=minPartialPathSum(grid,path,ROWS,COLS,i+1,j); } if (j==COLS-1){ path[i][j] = down; return down; } if (i==ROWS-1){ path[i][j] = right; return right; } int re = right&amp;lt;down?</description>
    </item>
    
    <item>
      <title>Leetcode 200 岛屿数量</title>
      <link>https://Lu0key.github.io/post/leetcode-200-number-of-islands/</link>
      <pubDate>Tue, 23 Mar 2021 14:39:02 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/leetcode-200-number-of-islands/</guid>
      <description>岛屿数量(Number of Islands) 给你一个由 &#39;1&#39;（陆地）和 &#39;0&#39;（水）组成的的二维网格，请你计算网格中岛屿的数量。
岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。
此外，你可以假设该网格的四条边均被水包围。
示例 1：
输入：grid = [[&amp;quot;1&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;0&amp;quot;],[&amp;quot;1&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;0&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;0&amp;quot;],[&amp;quot;1&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;0&amp;quot;,&amp;quot;0&amp;quot;,&amp;quot;0&amp;quot;],[&amp;quot;0&amp;quot;,&amp;quot;0&amp;quot;,&amp;quot;0&amp;quot;,&amp;quot;0&amp;quot;,&amp;quot;0&amp;quot;]]输出：1示例 2：
输入：grid = [[&amp;quot;1&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;0&amp;quot;,&amp;quot;0&amp;quot;,&amp;quot;0&amp;quot;],[&amp;quot;1&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;0&amp;quot;,&amp;quot;0&amp;quot;,&amp;quot;0&amp;quot;],[&amp;quot;0&amp;quot;,&amp;quot;0&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;0&amp;quot;,&amp;quot;0&amp;quot;],[&amp;quot;0&amp;quot;,&amp;quot;0&amp;quot;,&amp;quot;0&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;1&amp;quot;]]输出：3提示：
 m == grid.length n == grid[i].length 1 &amp;lt;= m, n &amp;lt;= 300 grid[i][j] 的值为 &#39;0&#39; 或 &#39;1&#39;  我们找到一个岛屿之后就把他清零，当所有数字都为0时，就表示结束了
const char WATER = &amp;#39;0&amp;#39;; const char LAND = &amp;#39;1&amp;#39;; const char NEW = &amp;#39;X&amp;#39;; const char USED = &amp;#39;O&amp;#39;; void floodFill(char** grid,int NUMBER_OF_ROWS,int NUMBER_OF_COLS,int i,int j){ if(i&amp;lt;0 || i&amp;gt;=NUMBER_OF_ROWS || j&amp;lt;0 || j&amp;gt;=NUMBER_OF_COLS||grid[i][j]!</description>
    </item>
    
    <item>
      <title>Leetcode 678 有效的括号字符串</title>
      <link>https://Lu0key.github.io/post/leetcode-678-valid-parenthesis-string/</link>
      <pubDate>Tue, 23 Mar 2021 14:30:43 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/leetcode-678-valid-parenthesis-string/</guid>
      <description>有效的括号字符串(Valid Parenthesis String) 给定一个只包含三种字符的字符串：（ ，） 和 *，写一个函数来检验这个字符串是否为有效字符串。有效字符串具有如下规则：
 任何左括号 ( 必须有相应的右括号 )。 任何右括号 ) 必须有相应的左括号 ( 。 左括号 ( 必须在对应的右括号之前 )。 * 可以被视为单个右括号 ) ，或单个左括号 ( ，或一个空字符串。 一个空字符串也被视为有效字符串。  示例 1:
输入: &amp;quot;()&amp;quot;输出: True示例 2:
输入: &amp;quot;(*)&amp;quot;输出: True示例 3:
输入: &amp;quot;(*))&amp;quot;输出: True注意:
 字符串大小将在 [1，100] 范围内。  bool checkVaildSubstring(char * s, int i, int j){ if(i &amp;gt; j) return true; if(s[i] == &amp;#39;)&amp;#39;) { return false; }else if( s[i] == &amp;#39;*&amp;#39;){ if (checkVaildSubstring(s, i+1,j)){ return true; } } for (int k=i+1;k&amp;lt;= j;k++){ if(s[k]==&amp;#39;)&amp;#39; || s[k] == &amp;#39;*&amp;#39;){ if(checkVaildSubstring(s,i+1,k-1) &amp;amp;&amp;amp; checkVaildSubstring(s,k+1,j)){ return true; } } } return false; } bool checkValidString(char * s){ return checkVaildSubstring(s,0,strlen(s)-1); } 这里会因为重复算相同的内容多次导致超时，因此我们可以用一个二维数组将算过的存起来，二维数组的i,j表示从索引i到索引j的这个子串是否计算过</description>
    </item>
    
    <item>
      <title>Leetcode 238 除自身以外数组的乘积</title>
      <link>https://Lu0key.github.io/post/leetcode-238-product-of-array-except-self/</link>
      <pubDate>Tue, 23 Mar 2021 14:27:37 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/leetcode-238-product-of-array-except-self/</guid>
      <description>除自身以外数组的乘积(Product of Array Except Self) 给你一个长度为 n 的整数数组 nums，其中 n &amp;gt; 1，返回输出数组 output ，其中 output[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积。
示例:
输入: [1,2,3,4]输出: [24,12,8,6]提示: 题目数据保证数组之中任意元素的全部前缀元素和后缀（甚至是整个数组）的乘积都在 32 位整数范围内。
说明: 请 不要使用除法，且在 O(n) 时间复杂度内完成此题。
进阶： 你可以在常数空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组不被视为额外空间。）
/** * Note: The returned array must be malloced, assume caller calls free(). */ int* productExceptSelf(int* nums, int numsSize, int* returnSize){ *returnSize = numsSize; int * result = malloc(sizeof(int)*numsSize); for (int i =0;i&amp;lt;numsSize;i++){ int left = 1; for(int j =0;j&amp;lt;=i-1;j++){ left *= nums[j]; } int right =1; for (int j =i+1;j&amp;lt;numsSize;j++){ right *=nums[j]; } result[i] = left*right; } return result; } int* productExceptSelf(int* nums, int numsSize, int* returnSize){ int *result = malloc(sizeof(int)*numsSize); int *lefts = malloc(sizeof(int)*numsSize); lefts[0]=1; for(int i =1;i&amp;lt;numsSize;i++){ lefts[i] = lefts[i-1]*nums[i-1]; } int *rights = malloc(sizeof(int)*numsSize); rights[numsSize-1]=1; for(int i =numsSize-2;i&amp;gt;=0;i--){ rights[i] = rights[i+1]*nums[i+1]; } // 这个for可以放在上面，right[i] 算完了就可以算result[i]了，然后少一个for循环  for (int i =0;i&amp;lt;numsSize;i++){ result[i] = lefts[i]*rights[i]; } *returnSize = numsSize; return result; } 题目问能不能不要额外的空间，然后返回的空间不算，因此我们先第一步简化</description>
    </item>
    
    <item>
      <title>Leetcode 525 连续数组</title>
      <link>https://Lu0key.github.io/post/leetcode-525-contiguous-array/</link>
      <pubDate>Tue, 23 Mar 2021 14:24:43 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/leetcode-525-contiguous-array/</guid>
      <description>连续数组(Contiguous Array) 给定一个二进制数组, 找到含有相同数量的 0 和 1 的最长连续子数组（的长度）。
示例 1:
输入: [0,1]输出: 2说明: [0, 1] 是具有相同数量0和1的最长连续子数组。示例 2:
输入: [0,1,0]输出: 2说明: [0, 1] (或 [1, 0]) 是具有相同数量0和1的最长连续子数组。注意: 给定的二进制数组的长度不会超过50000。
最粗暴的方式
int count0(int i,int j,int *nums) { int count = 0; for (int k =i; k&amp;lt;=j;k++){ if(nums[k] == 0){ count++; } } return count; } int count1(int i,int j,int *nums) { int count = 0; for (int k =i; k&amp;lt;=j;k++){ if(nums[k] == 1){ count++; } } return count; } int findMaxLength(int* nums, int numsSize){ int maxLength = 0; for (int i =0;i&amp;lt;numsSize;i++){ for(int j =i;j&amp;lt;numsSize;j++){ if(count0(i,j,nums) == count1(i,j,nums)){ int length = j-i+1; if (length &amp;gt; maxLength){ maxLength = length; } } } } return maxLength; } 但是这样会超时，毕竟O(n^3)</description>
    </item>
    
    <item>
      <title>Leetcode 1046 最后一块石头的重量</title>
      <link>https://Lu0key.github.io/post/leetcode-1046-last-stone-weight/</link>
      <pubDate>Tue, 23 Mar 2021 14:21:07 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/leetcode-1046-last-stone-weight/</guid>
      <description>最后一块石头的重量(Last Stone Weight) 有一堆石头，每块石头的重量都是正整数。
每一回合，从中选出两块 最重的 石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x &amp;lt;= y。那么粉碎的可能结果如下：
 如果 x == y，那么两块石头都会被完全粉碎； 如果 x != y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。  最后，最多只会剩下一块石头。返回此石头的重量。如果没有石头剩下，就返回 0。
示例：
输入：[2,7,4,1,8,1]输出：1解释：先选出 7 和 8，得到 1，所以数组转换为 [2,4,1,1,1]，再选出 2 和 4，得到 2，所以数组转换为 [2,1,1,1]，接着是 2 和 1，得到 1，所以数组转换为 [1,1,1]，最后选出 1 和 1，得到 0，最终数组转换为 [1]，这就是最后剩下那块石头的重量。提示：
 1 &amp;lt;= stones.length &amp;lt;= 30 1 &amp;lt;= stones[i] &amp;lt;= 1000  int extractMax(int *stones, int stonesSize) { int max = stones[0]; // 获取最大数  for (int i=1;i&amp;lt;stonesSize;i++){ if (stones[i]&amp;gt;max){ max = stones[i]; } } // 将第一个最大数位置置为0  for(int i =0;i&amp;lt;stonesSize;i++){ if(stones[i] == max){ stones[i]=0; break; } } return max; } void insert(int *stones, int stonesSize, int value) { for (int i =0;i&amp;lt;stonesSize;i++){ if(stones[i] == 0){ stones[i] = value; break; } } } int lastStoneWeight(int* stones, int stonesSize){ while(true) { // 第一大  int y = extractMax(stones, stonesSize); // 第二大  int x = extractMax(stones, stonesSize); if(x == 0) { return y; } if(x!</description>
    </item>
    
    <item>
      <title>Leetcode 543 Diameter of Binary Tree</title>
      <link>https://Lu0key.github.io/post/leetcode-543-diameter-of-binary-tree/</link>
      <pubDate>Sat, 20 Mar 2021 13:26:27 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/leetcode-543-diameter-of-binary-tree/</guid>
      <description>二叉树的直径(Diameter of Binary Tree) 给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。
示例 : 给定二叉树
 1/ \2 3/ \ 4 5 返回 3, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。
注意：两结点之间的路径长度是以它们之间边的数目表示。
/** * Definition for a binary tree node. * struct TreeNode { * int val; * struct TreeNode *left; * struct TreeNode *right; * }; */ int maxDepth(struct TreeNode * root){ if (root == NULL) return 0; int leftMax = maxDepth(root-&amp;gt;left); int rightMax = maxDepth(root-&amp;gt;right); if(leftMax&amp;gt;rightMax){ return leftMax+1; } return rightMax+1; } int diameterOfBinaryTree(struct TreeNode* root){ if (root == NULL) return 0; int middle = maxDepth(root-&amp;gt;left) + maxDepth(root-&amp;gt;right); int left = diameterOfBinaryTree(root-&amp;gt;left); int right = diameterOfBinaryTree(root-&amp;gt;right); int max = middle; if (left &amp;gt; max){ max = left; } if(right &amp;gt; max){ max = right; } return max; } 二叉树的最大深度(Maximum Depth of Binary Tree) 给定一个二叉树，找出其最大深度。</description>
    </item>
    
    <item>
      <title>Leetcode 155 Min Stack</title>
      <link>https://Lu0key.github.io/post/leetcode-155-min-stack/</link>
      <pubDate>Sat, 20 Mar 2021 13:22:09 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/leetcode-155-min-stack/</guid>
      <description>最小栈(Min Stack) 设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。
push(x) —— 将元素 x 推入栈中。pop() —— 删除栈顶的元素。top() —— 获取栈顶元素。getMin() —— 检索栈中的最小元素。 示例:
输入：[&amp;quot;MinStack&amp;quot;,&amp;quot;push&amp;quot;,&amp;quot;push&amp;quot;,&amp;quot;push&amp;quot;,&amp;quot;getMin&amp;quot;,&amp;quot;pop&amp;quot;,&amp;quot;top&amp;quot;,&amp;quot;getMin&amp;quot;][[],[-2],[0],[-3],[],[],[],[]]输出：[null,null,null,null,-3,null,0,-2]解释：MinStack minStack = new MinStack();minStack.push(-2);minStack.push(0);minStack.push(-3);minStack.getMin(); --&amp;gt; 返回 -3.minStack.pop();minStack.top(); --&amp;gt; 返回 0.minStack.getMin(); --&amp;gt; 返回 -2.提示：
 pop、top 和 getMin 操作总是在 非空栈 上调用。  C语言版:
/** * Your MinStack struct will be instantiated and called as such: * MinStack* obj = minStackCreate(); * minStackPush(obj, val); * minStackPop(obj); * int param_3 = minStackTop(obj); * int param_4 = minStackGetMin(obj); * minStackFree(obj); */ typedef struct { int * data; int * mins; int size; } MinStack; /** initialize your data structure here.</description>
    </item>
    
    <item>
      <title>Leetcode Backspace String Compare</title>
      <link>https://Lu0key.github.io/post/leetcode-backspace-string-compare/</link>
      <pubDate>Fri, 19 Mar 2021 17:42:46 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/leetcode-backspace-string-compare/</guid>
      <description>比较含退格的字符串(Backspace String Compare) 给定 S 和 T 两个字符串，当它们分别被输入到空白的文本编辑器后，判断二者是否相等，并返回结果。 # 代表退格字符。
注意：如果对空文本输入退格字符，文本继续为空。
示例 1：
输入：S = &amp;quot;ab#c&amp;quot;, T = &amp;quot;ad#c&amp;quot;输出：true解释：S 和 T 都会变成 “ac”。示例 2：
输入：S = &amp;quot;ab##&amp;quot;, T = &amp;quot;c#d#&amp;quot;输出：true解释：S 和 T 都会变成 “”。示例 3：
输入：S = &amp;quot;a##c&amp;quot;, T = &amp;quot;#a#c&amp;quot;输出：true解释：S 和 T 都会变成 “c”。示例 4：
输入：S = &amp;quot;a#c&amp;quot;, T = &amp;quot;b&amp;quot;输出：false解释：S 会变成 “c”，但 T 仍然是 “b”。提示：
 1 &amp;lt;= S.</description>
    </item>
    
    <item>
      <title>Leetcode 876 Middle of the Linked List</title>
      <link>https://Lu0key.github.io/post/leetcode-876-middle-of-the-linked-list/</link>
      <pubDate>Fri, 19 Mar 2021 16:54:41 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/leetcode-876-middle-of-the-linked-list/</guid>
      <description>链表的中间结点(Middle Of The Linked List) 给定一个头结点为 head 的非空单链表，返回链表的中间结点。
如果有两个中间结点，则返回第二个中间结点。
示例 1：
输入：[1,2,3,4,5]输出：此列表中的结点 3 (序列化形式：[3,4,5])返回的结点值为 3 。 (测评系统对该结点序列化表述是 [3,4,5])。注意，我们返回了一个 ListNode 类型的对象 ans，这样：ans.val = 3, ans.next.val = 4, ans.next.next.val = 5, 以及 ans.next.next.next = NULL.示例 2：
输入：[1,2,3,4,5,6]输出：此列表中的结点 4 (序列化形式：[4,5,6])由于该列表有两个中间结点，值分别为 3 和 4，我们返回第二个结点。提示：
 给定链表的结点数介于 1 和 100 之间。  C语言版:
/** * Definition for singly-linked list. * struct ListNode { * int val; * struct ListNode *next; * }; */ struct ListNode * middleNode(struct ListNode* head){ int length = 1; struct ListNode* curr = head; while(curr-&amp;gt;next!</description>
    </item>
    
    <item>
      <title>Leetcode 49 Group Anagrams</title>
      <link>https://Lu0key.github.io/post/leetcode-49-group-anagrams/</link>
      <pubDate>Tue, 16 Mar 2021 16:50:13 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/leetcode-49-group-anagrams/</guid>
      <description>字母异位词分组(Group Anagrams) 给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。
示例:
输入: [&amp;quot;eat&amp;quot;, &amp;quot;tea&amp;quot;, &amp;quot;tan&amp;quot;, &amp;quot;ate&amp;quot;, &amp;quot;nat&amp;quot;, &amp;quot;bat&amp;quot;]输出:[[&amp;quot;ate&amp;quot;,&amp;quot;eat&amp;quot;,&amp;quot;tea&amp;quot;],[&amp;quot;nat&amp;quot;,&amp;quot;tan&amp;quot;],[&amp;quot;bat&amp;quot;]]说明：
 所有输入均为小写字母。 不考虑答案输出的顺序。  C语言版:
/** * Return an array of arrays of size *returnSize. * The sizes of the arrays are returned as *returnColumnSizes array. * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free(). */ int cmpChar(const void*a ,const void *b){ return *(const char*)a - *(const char *)b; } typedef struct { char * original; char * sorted; }Pair; int cmpPair(const void * a, const void * b){ const Pair * pa = (const Pair *)a; const Pair * pb = (const Pair *)b; return strcmp(pa-&amp;gt;sorted, pb-&amp;gt;sorted); } char *** groupAnagrams(char ** strs, int strsSize, int* returnSize, int** returnColumnSizes){ Pair* pairs = malloc(sizeof(Pair)*strsSize); for(int i =0;i&amp;lt;strsSize;i++){ char *sorted_str = malloc(sizeof(char)*strlen(strs[i])+1); strcpy(sorted_str,strs[i]); qsort(sorted_str, strlen(strs[i]),sizeof(char),cmpChar); pairs[i].</description>
    </item>
    
    <item>
      <title>Leetcode 122 Best Time to Buy and Sell Stock Ii</title>
      <link>https://Lu0key.github.io/post/leetcode-122-best-time-to-buy-and-sell-stock-ii/</link>
      <pubDate>Tue, 16 Mar 2021 00:05:57 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/leetcode-122-best-time-to-buy-and-sell-stock-ii/</guid>
      <description>买卖股票的最佳时机II(Best Time To Buy And Sell Stock II) 给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。
设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。
注意: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
示例 1:
输入: [7,1,5,3,6,4]输出: 7解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。示例 2:
输入: [1,2,3,4,5]输出: 4解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。示例 3:</description>
    </item>
    
    <item>
      <title>Leetcode 283 Move Zeroes</title>
      <link>https://Lu0key.github.io/post/leetcode-283-move-zeroes/</link>
      <pubDate>Mon, 15 Mar 2021 16:56:34 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/leetcode-283-move-zeroes/</guid>
      <description>移动零(Move Zeroes) 给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。
示例:
输入: [0,1,0,3,12]输出: [1,3,12,0,0]说明:
 必须在原数组上操作，不能拷贝额外的数组。 尽量减少操作次数。  C语言版本:
void moveZeroes(int* nums, int numsSize){ while(true){ int count = 0; for (int i =0;i+1&amp;lt;numsSize;i++) { if(nums[i]==0 &amp;amp;&amp;amp; nums[i+1]!=0) { count++; int temp = nums[i]; nums[i] = nums[i+1]; nums[i+1] = temp; break; } } if (count==0)break; } } 这样会超时，去掉第一个break就能过
模仿冒泡排序:
void moveZeroes(int* nums, int numsSize){ for (int k=0;k&amp;lt;numsSize;k++){ for(int i=0;i+1&amp;lt;numsSize;i++){ if(nums[i] == 0 &amp;amp;&amp;amp; nums[i+1] !</description>
    </item>
    
    <item>
      <title>Leetcode 53 Maximum Subarray</title>
      <link>https://Lu0key.github.io/post/leetcode-53-maximum-subarray/</link>
      <pubDate>Mon, 15 Mar 2021 16:02:01 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/leetcode-53-maximum-subarray/</guid>
      <description>最大子序和(Maximum Subarray) 给定一个整数数组 nums，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
示例 1：
输入：nums = [-2,1,-3,4,-1,2,1,-5,4]输出：6解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。示例 2：
输入：nums = [1]输出：1示例 3：
输入：nums = [0]输出：0示例 4：
输入：nums = [-1]输出：-1示例 5：
输入：nums = [-100000]输出：-100000提示：
 $1\leqslant nums.length \leqslant 3 * 10^5$ $-10^5 \leqslant nums[i] \leqslant 10^5$  进阶：如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的 分治法 求解。
C语言版本:
int maxSubArray(int* nums, int numsSize){ int max=nums[0]; for (int i=0; i &amp;lt;numsSize;i++) { for (int j =i;j&amp;lt;numsSize;j++){ int sum = 0; for (int k =i;k&amp;lt;=j;k++){ sum += nums[k]; } if (sum&amp;gt;max){ max = sum; } } } return max; } 用这种方法会超时</description>
    </item>
    
    <item>
      <title>Leetcode 202 Happy Number</title>
      <link>https://Lu0key.github.io/post/leetcode-202-happy-number/</link>
      <pubDate>Mon, 15 Mar 2021 15:27:25 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/leetcode-202-happy-number/</guid>
      <description>快乐数(Happy Number) 编写一个算法来判断一个数 n 是不是快乐数。
「快乐数」定义为：
 对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。 然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。 如果 可以变为 1，那么这个数就是快乐数。  如果 n 是快乐数就返回 true ；不是，则返回 false 。
示例 1：
输入：19输出：true解释：1² + 9² = 828² + 2² = 686² + 8² = 1001² + 0² + 0² = 1示例 2：
输入：n = 2解释：2² = 44² = 161² + 6² = 373² + 7² = 585² + 8² = 898² + 9² = 1451² + 4² + 5² = 424² + 2² = 202² + 0² = 4 循环了，永远不会到1输出：false提示：</description>
    </item>
    
    <item>
      <title>Leetcode 136 Single Number</title>
      <link>https://Lu0key.github.io/post/leetcode-136-single-number/</link>
      <pubDate>Mon, 15 Mar 2021 14:36:31 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/leetcode-136-single-number/</guid>
      <description>只出现一次的数字(Single Number) 给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。
说明：
你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？
示例 1:
输入: [2,2,1]输出: 1示例 2:
输入: [4,1,2,1,2]输出: 4C的解法:
int singleNumber(int* nums, int numsSize){ for (int i =0;i&amp;lt;numsSize;i++){ int count = 0; for (int j=0;j&amp;lt;numsSize;j++){ if(nums[j]==nums[i]){ count++; } if(count==2)break; } if(count==1){ return nums[i]; } } return -1; } 用位运算:
int singleNumber(int* nums, int numsSize){ int n =nums[0]; for (int i =1;i&amp;lt;numsSize;i++){ n ^= nums[i]; } return n; } 之后再补Java的写法，都是类似的</description>
    </item>
    
  </channel>
</rss>
