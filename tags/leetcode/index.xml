<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>leetcode on 洛七的摸鱼池塘</title>
    <link>https://Lu0key.github.io/tags/leetcode/</link>
    <description>Recent content in leetcode on 洛七的摸鱼池塘</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 15 Mar 2021 16:02:01 +0800</lastBuildDate><atom:link href="https://Lu0key.github.io/tags/leetcode/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Leetcode 53 Maximum Subarray</title>
      <link>https://Lu0key.github.io/post/leetcode-53-maximum-subarray/</link>
      <pubDate>Mon, 15 Mar 2021 16:02:01 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/leetcode-53-maximum-subarray/</guid>
      <description>最大子序和(Maximum Subarray) 给定一个整数数组 nums，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
示例 1：
输入：nums = [-2,1,-3,4,-1,2,1,-5,4] 输出：6 解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。 示例 2：
输入：nums = [1] 输出：1 示例 3：
输入：nums = [0] 输出：0 示例 4：
输入：nums = [-1] 输出：-1 示例 5：
输入：nums = [-100000] 输出：-100000 提示：
 $1\leqslant nums.length \leqslant 3 * 10^5$ $-10^5 \leqslant nums[i] \leqslant 10^5$  进阶：如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的 分治法 求解。
C语言版本:
int maxSubArray(int* nums, int numsSize){ int max=nums[0]; for (int i=0; i &amp;lt;numsSize;i++) { for (int j =i;j&amp;lt;numsSize;j++){ int sum = 0; for (int k =i;k&amp;lt;=j;k++){ sum += nums[k]; } if (sum&amp;gt;max){ max = sum; } } } return max; } 用这种方法会超时</description>
    </item>
    
    <item>
      <title>Leetcode 202 Happy Number</title>
      <link>https://Lu0key.github.io/post/leetcode-202-happy-number/</link>
      <pubDate>Mon, 15 Mar 2021 15:27:25 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/leetcode-202-happy-number/</guid>
      <description>快乐数(Happy Number) 编写一个算法来判断一个数 n 是不是快乐数。
「快乐数」定义为：
 对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。 然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。 如果 可以变为 1，那么这个数就是快乐数。  如果 n 是快乐数就返回 true ；不是，则返回 false 。
示例 1：
输入：19 输出：true 解释： 1² + 9² = 82 8² + 2² = 68 6² + 8² = 100 1² + 0² + 0² = 1 示例 2：
输入：n = 2 解释： 2² = 4 4² = 16 1² + 6² = 37 3² + 7² = 58 5² + 8² = 89 8² + 9² = 145 1² + 4² + 5² = 42 4² + 2² = 20 2² + 0² = 4 循环了，永远不会到1 输出：false 提示：</description>
    </item>
    
    <item>
      <title>Leetcode 136 Single Number</title>
      <link>https://Lu0key.github.io/post/leetcode-136-single-number/</link>
      <pubDate>Mon, 15 Mar 2021 14:36:31 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/leetcode-136-single-number/</guid>
      <description>只出现一次的数字(Single Number) 给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。
说明：
你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？
示例 1:
输入: [2,2,1] 输出: 1 示例 2:
输入: [4,1,2,1,2] 输出: 4 C的解法:
int singleNumber(int* nums, int numsSize){ for (int i =0;i&amp;lt;numsSize;i++){ int count = 0; for (int j=0;j&amp;lt;numsSize;j++){ if(nums[j]==nums[i]){ count++; } if(count==2)break; } if(count==1){ return nums[i]; } } return -1; } 用位运算:
int singleNumber(int* nums, int numsSize){ int n =nums[0]; for (int i =1;i&amp;lt;numsSize;i++){ n ^= nums[i]; } return n; } 之后再补Java的写法，都是类似的</description>
    </item>
    
  </channel>
</rss>
