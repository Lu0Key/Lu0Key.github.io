<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>动态规划 on 洛七的摸鱼池塘</title>
    <link>https://Lu0key.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</link>
    <description>Recent content in 动态规划 on 洛七的摸鱼池塘</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 28 Feb 2024 21:50:49 +0800</lastBuildDate><atom:link href="https://Lu0key.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Leetcode 292 Nim 游戏</title>
      <link>https://Lu0key.github.io/post/lc-292-nim-game/</link>
      <pubDate>Wed, 28 Feb 2024 21:50:49 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/lc-292-nim-game/</guid>
      <description>292.Nim 游戏 你和你的朋友，两个人一起玩 Nim 游戏：
 桌子上有一堆石头。 你们轮流进行自己的回合， 你作为先手 。 每一回合，轮到的人拿掉 1 - 3 块石头。 拿掉最后一块石头的人就是获胜者。 假设你们每一步都是最优解。请编写一个函数，来判断你是否可以在给定石头数量为 n 的情况下赢得游戏。如果可以赢，返回 true；否则，返回 false 。  示例 1:
输入: n = 4
输出: false
解释: 以下是可能的结果:
 移除1颗石头。你的朋友移走了3块石头，包括最后一块。你的朋友赢了。 移除2个石子。你的朋友移走2块石头，包括最后一块。你的朋友赢了。 3.你移走3颗石子。你的朋友移走了最后一块石头。你的朋友赢了。 在所有结果中，你的朋友是赢家。  示例 2:
输入: n = 1
输出: true
示例 3:
输入: n = 2
输出: true
提示：
 1 &amp;lt;= n &amp;lt;= 2^31 - 1  Related Topics
 脑筋急转弯 数学 博弈  题目链接: link</description>
    </item>
    
    <item>
      <title>Leetcode 365 水壶问题</title>
      <link>https://Lu0key.github.io/post/lc-365-water-and-jug-problem/</link>
      <pubDate>Wed, 28 Feb 2024 21:35:19 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/lc-365-water-and-jug-problem/</guid>
      <description>365.水壶问题 有两个水壶，容量分别为 jug1Capacity 和 jug2Capacity 升。水的供应是无限的。确定是否有可能使用这两个壶准确得到 targetCapacity 升。
如果可以得到 targetCapacity 升水，最后请用以上水壶中的一或两个来盛放取得的 targetCapacity 升水。
你可以：
 装满任意一个水壶 清空任意一个水壶 从一个水壶向另外一个水壶倒水，直到装满或者倒空  示例 1:
输入: jug1Capacity = 3, jug2Capacity = 5, targetCapacity = 4
输出: true
示例 2:
输入: jug1Capacity = 2, jug2Capacity = 6, targetCapacity = 5
输出: false
示例 3:
输入: jug1Capacity = 1, jug2Capacity = 2, targetCapacity = 3
输出: true
提示：
 1 &amp;lt;= jug1Capacity, jug2Capacity, targetCapacity &amp;lt;= 10^6  Related Topics</description>
    </item>
    
    <item>
      <title>Leetcode 2861 最大合金数</title>
      <link>https://Lu0key.github.io/post/lc-2861-maximum-number-of-alloys/</link>
      <pubDate>Wed, 28 Feb 2024 21:29:15 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/lc-2861-maximum-number-of-alloys/</guid>
      <description>2861.最大合金数 假设你是一家合金制造公司的老板，你的公司使用多种金属来制造合金。现在共有 n 种不同类型的金属可以使用，并且你可以使用 k 台机器来制造合金。每台机器都需要特定数量的每种金属来创建合金。
对于第 i 台机器而言，创建合金需要 composition[i][j] 份 j 类型金属。最初，你拥有 stock[i] 份 i 类型金属，而每购入一份 i 类型金属需要花费 cost[i] 的金钱。
给你整数 n、k、budget，下标从 1 开始的二维数组 composition，两个下标从 1 开始的数组 stock 和 cost，请你在预算不超过 budget 金钱的前提下，最大化 公司制造合金的数量。
所有合金都需要由同一台机器制造。
返回公司可以制造的最大合金数。
示例 1:
输入: n = 3, k = 2, budget = 15, composition = [[1,1,1],[1,1,10]], stock = [0,0,0], cost = [1,2,3]
输出: 2
解释: 优的方法是使用第 1 台机器来制造合金。
要想制造 2 份合金，我们需要购买：
 2 份第 1 类金属。 2 份第 2 类金属。 2 份第 3 类金属。  总共需要 2 * 1 + 2 * 2 + 2 * 3 = 12 的金钱，小于等于预算 15 。</description>
    </item>
    
    <item>
      <title>Leetcode 2859 计算 K 置位下标对应元素的和</title>
      <link>https://Lu0key.github.io/post/lc-2859-sum-of-values-at-indices-with-k-set-bits/</link>
      <pubDate>Wed, 28 Feb 2024 21:15:49 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/lc-2859-sum-of-values-at-indices-with-k-set-bits/</guid>
      <description>2859.计算 K 置位下标对应元素的和 你一个下标从 0 开始的整数数组 nums 和一个整数 k 。
请你用整数形式返回 nums 中的特定元素之 和 ，这些特定元素满足：其对应下标的二进制表示中恰存在 k 个置位。
整数的二进制表示中的 1 就是这个整数的 置位 。
例如，21 的二进制表示为 10101 ，其中有 3 个置位。
示例 1:
输入: nums = [5,10,1,5,2], k = 1
输出: 13
解释: 下标的二进制表示是：
0 = 00021 = 00122 = 01023 = 01124 = 1002下标 1、2 和 4 在其二进制表示中都存在 k = 1 个置位。
因此，答案为 nums[1] + nums[2] + nums[4] = 13 。
示例 2:</description>
    </item>
    
    <item>
      <title>Leetcode 2809 使数组和小于等于 x 的最少时间</title>
      <link>https://Lu0key.github.io/post/lc-2809-minimum-time-to-make-array-sum-at-most-x/</link>
      <pubDate>Sat, 20 Jan 2024 00:07:08 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/lc-2809-minimum-time-to-make-array-sum-at-most-x/</guid>
      <description>2809.使数组和小于等于 x 的最少时间 给你两个长度相等下标从 0 开始的整数数组 nums1 和 nums2 。每一秒，对于所有下标 0 &amp;lt;= i &amp;lt; nums1.length ，nums1[i] 的值都增加 nums2[i] 。操作 完成后 ，你可以进行如下操作：
 选择任一满足 0 &amp;lt;= i &amp;lt; nums1.length 的下标 i ，并使 nums1[i] = 0 。  同时给你一个整数 x 。
请你返回使 nums1 中所有元素之和 小于等于 x 所需要的 最少 时间，如果无法实现，那么返回 -1 。
示例 1：
输入: nums1 = [1,2,3], nums2 = [1,2,3], x = 4
输出: 3
解释：
第 1 秒，我们对 i = 0 进行操作，得到 nums1 = [0,2+2,3+3] = [0,4,6] 。</description>
    </item>
    
    <item>
      <title>Leetcode 2171 拿出最少数目的魔法豆</title>
      <link>https://Lu0key.github.io/post/lc-2171-removing-minimum-number-of-magic-beans/</link>
      <pubDate>Thu, 18 Jan 2024 14:37:18 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/lc-2171-removing-minimum-number-of-magic-beans/</guid>
      <description>2171.拿出最少数目的魔法豆 给定一个 正整数 数组 beans ，其中每个整数表示一个袋子里装的魔法豆的数目。
请你从每个袋子中 拿出 一些豆子（也可以 不拿出），使得剩下的 非空 袋子中（即 至少还有一颗 魔法豆的袋子）魔法豆的数目 相等。一旦把魔法豆从袋子中取出，你不能再将它放到任何袋子中。
请返回你需要拿出魔法豆的 最少数目。
示例 1：
输入：beans = [4,1,6,5]
输出：4
解释：
 我们从有 1 个魔法豆的袋子中拿出 1 颗魔法豆。 剩下袋子中魔法豆的数目为：[4,0,6,5] 然后我们从有 6 个魔法豆的袋子中拿出 2 个魔法豆。 剩下袋子中魔法豆的数目为：[4,0,4,5] 然后我们从有 5 个魔法豆的袋子中拿出 1 个魔法豆。 剩下袋子中魔法豆的数目为：[4,0,4,4] 总共拿出了 1 + 2 + 1 = 4 个魔法豆，剩下非空袋子中魔法豆的数目相等。 没有比取出 4 个魔法豆更少的方案。  示例 2：
输入：beans = [2,10,3,2]
输出：7
解释：
 我们从有 2 个魔法豆的其中一个袋子中拿出 2 个魔法豆。 剩下袋子中魔法豆的数目为：[0,10,3,2] 然后我们从另一个有 2 个魔法豆的袋子中拿出 2 个魔法豆。 剩下袋子中魔法豆的数目为：[0,10,3,0] 然后我们从有 3 个魔法豆的袋子中拿出 3 个魔法豆。 剩下袋子中魔法豆的数目为：[0,10,0,0] 总共拿出了 2 + 2 + 3 = 7 个魔法豆，剩下非空袋子中魔法豆的数目相等。 没有比取出 7 个魔法豆更少的方案。  提示:</description>
    </item>
    
    <item>
      <title>Leetcode 2719 統計整數數目</title>
      <link>https://Lu0key.github.io/post/lc-2719-count-of-integers/</link>
      <pubDate>Tue, 16 Jan 2024 17:51:29 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/lc-2719-count-of-integers/</guid>
      <description>2719.統計整數數目 給你兩個數字字符串 num1 和 num2，以及兩個整數 max_sum 和 min_sum. 如果一個整數滿足一下條件，我們稱它是一個好整數：
 num1 &amp;lt;= x &amp;lt;= num2 min_sum &amp;lt;= digit_sum(x) &amp;lt;= max_sum  請你返回好整數的數目。答案可能很大，請返回答案對 10^9+7 取餘后的結果。
注意，digit_sum(x) 表示 x 各位數字之和。
示例 1：
输入：num1 = &amp;ldquo;1&amp;rdquo;, num2 = &amp;ldquo;12&amp;rdquo;, min_num = 1, max_num = 8
输出：11
解释：总共有 11 个整数的数位和在 1 到 8 之间，分别是 1,2,3,4,5,6,7,8,10,11 和 12 。所以我们返回 11 。
示例 2：
输入：num1 = &amp;ldquo;1&amp;rdquo;, num2 = &amp;ldquo;5&amp;rdquo;, min_num = 1, max_num = 5</description>
    </item>
    
  </channel>
</rss>
