<!doctype html>
<html lang="en-us">
  <head>
    <title>王道考研 数据结构 栈和队列 // 洛七的摸鱼池塘</title>
    <link rel="shortcut icon" href="/favicon.ico" />
    <meta charset="utf-8" />
    <meta name="generator" content="Hugo 0.81.0" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="洛七" />
    <meta name="description" content="" />
    <link rel="stylesheet" href="/css/main.min.0fb49e70a30412f97ddfc418e18fefef1d9fcdebe45f634dbbba768b00fe1eec.css" />
    

    
    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="王道考研 数据结构 栈和队列"/>
<meta name="twitter:description" content="栈和队列  栈和队列  定义 顺序栈  顺序栈-进栈 顺序表-出栈 顺序栈-读栈 顺序栈-共享栈 栈的链式实现   队列  队列-顺序存储 队列-入队 队列-出队 队列的链式实现 双端队列   栈-括号匹配 栈-表达式求值  原理 代码   栈的应用-递归 队列的应用 特殊矩阵的压缩存储  对称矩阵 三角矩阵 三对角矩阵 稀疏矩阵      定义 栈(stack) 是只允许一端进行插入或删除操作的线性表（是同一端）.
重要术语
 栈顶 栈底 空栈  特点：LIFO（Last In First Out）后进的先出
基本操作
 InitStack(&amp; S)：初始化栈。构造一个空栈S，分配内存空间。 DestroyStack(&amp; S)：销毁栈。销毁并释放栈S所占的内存空间。 Push(&amp;S, x)：进栈，若栈S未满，则将x加入使之成为新栈顶。 Pop(&amp;S, &amp;x)：出栈，若栈S非空，则弹出栈顶元素，并用x返回 GetTop(S, &amp;x)：读栈顶元素。若栈S非空，则用x返回栈顶元素  栈的差一般只访问栈顶元素   StackEmpty(S)：判断一个栈S是否为空，若为空，则返回true，否则返回false。  常考题型：判断合法的出栈的顺序（要满足先进后出，后进先出）"/>

    <meta property="og:title" content="王道考研 数据结构 栈和队列" />
<meta property="og:description" content="栈和队列  栈和队列  定义 顺序栈  顺序栈-进栈 顺序表-出栈 顺序栈-读栈 顺序栈-共享栈 栈的链式实现   队列  队列-顺序存储 队列-入队 队列-出队 队列的链式实现 双端队列   栈-括号匹配 栈-表达式求值  原理 代码   栈的应用-递归 队列的应用 特殊矩阵的压缩存储  对称矩阵 三角矩阵 三对角矩阵 稀疏矩阵      定义 栈(stack) 是只允许一端进行插入或删除操作的线性表（是同一端）.
重要术语
 栈顶 栈底 空栈  特点：LIFO（Last In First Out）后进的先出
基本操作
 InitStack(&amp; S)：初始化栈。构造一个空栈S，分配内存空间。 DestroyStack(&amp; S)：销毁栈。销毁并释放栈S所占的内存空间。 Push(&amp;S, x)：进栈，若栈S未满，则将x加入使之成为新栈顶。 Pop(&amp;S, &amp;x)：出栈，若栈S非空，则弹出栈顶元素，并用x返回 GetTop(S, &amp;x)：读栈顶元素。若栈S非空，则用x返回栈顶元素  栈的差一般只访问栈顶元素   StackEmpty(S)：判断一个栈S是否为空，若为空，则返回true，否则返回false。  常考题型：判断合法的出栈的顺序（要满足先进后出，后进先出）" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://Lu0key.github.io/post/%E7%8E%8B%E9%81%93%E8%80%83%E7%A0%94-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2021-02-06T22:08:19&#43;08:00" />
<meta property="article:modified_time" content="2021-02-06T22:08:19&#43;08:00" />



  </head>
  <body>
    <header class="app-header">
      <a href="https://Lu0key.github.io/"><img class="app-header-avatar" src="/avatar.jpg" alt="洛七" /></a>
      <span class="app-header-title">洛七的摸鱼池塘</span>
      <nav class="app-header-menu">
          <a class="app-header-menu-item" href="/tags/">Tags</a>
      </nav>
      <p>即将没书读的咸鱼</p>
    </header>
    <main class="app-container">
      
  <article class="post">
    <header class="post-header">
      <h1 class ="post-title">王道考研 数据结构 栈和队列</h1>
      <div class="post-meta">
        <div>
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar">
  <title>calendar</title>
  <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line>
</svg>
          Feb 6, 2021
        </div>
        <div>
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock">
  <title>clock</title>
  <circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline>
</svg>
          6 min read
        </div>
        <div>
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tag">
  <title>tag</title>
  <path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path><line x1="7" y1="7" x2="7.01" y2="7"></line>
</svg>
              <a class="tag" href="https://Lu0key.github.io/tags/%E8%80%83%E7%A0%94/">考研</a>
              <a class="tag" href="https://Lu0key.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a>
        </div>
      </div>
    </header>
    <div class="post-content">
      <h1 id="栈和队列">栈和队列</h1>
<!-- raw HTML omitted -->
<ul>
<li><a href="#%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97">栈和队列</a>
<ul>
<li><a href="#%E5%AE%9A%E4%B9%89">定义</a></li>
<li><a href="#%E9%A1%BA%E5%BA%8F%E6%A0%88">顺序栈</a>
<ul>
<li><a href="#%E9%A1%BA%E5%BA%8F%E6%A0%88-%E8%BF%9B%E6%A0%88">顺序栈-进栈</a></li>
<li><a href="#%E9%A1%BA%E5%BA%8F%E8%A1%A8-%E5%87%BA%E6%A0%88">顺序表-出栈</a></li>
<li><a href="#%E9%A1%BA%E5%BA%8F%E6%A0%88-%E8%AF%BB%E6%A0%88">顺序栈-读栈</a></li>
<li><a href="#%E9%A1%BA%E5%BA%8F%E6%A0%88-%E5%85%B1%E4%BA%AB%E6%A0%88">顺序栈-共享栈</a></li>
<li><a href="#%E6%A0%88%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AE%9E%E7%8E%B0">栈的链式实现</a></li>
</ul>
</li>
<li><a href="#%E9%98%9F%E5%88%97">队列</a>
<ul>
<li><a href="#%E9%98%9F%E5%88%97-%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8">队列-顺序存储</a></li>
<li><a href="#%E9%98%9F%E5%88%97-%E5%85%A5%E9%98%9F">队列-入队</a></li>
<li><a href="#%E9%98%9F%E5%88%97-%E5%87%BA%E9%98%9F">队列-出队</a></li>
<li><a href="#%E9%98%9F%E5%88%97%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AE%9E%E7%8E%B0">队列的链式实现</a></li>
<li><a href="#%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97">双端队列</a></li>
</ul>
</li>
<li><a href="#%E6%A0%88-%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D">栈-括号匹配</a></li>
<li><a href="#%E6%A0%88-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC">栈-表达式求值</a>
<ul>
<li><a href="#%E5%8E%9F%E7%90%86">原理</a></li>
<li><a href="#%E4%BB%A3%E7%A0%81">代码</a></li>
</ul>
</li>
<li><a href="#%E6%A0%88%E7%9A%84%E5%BA%94%E7%94%A8-%E9%80%92%E5%BD%92">栈的应用-递归</a></li>
<li><a href="#%E9%98%9F%E5%88%97%E7%9A%84%E5%BA%94%E7%94%A8">队列的应用</a></li>
<li><a href="#%E7%89%B9%E6%AE%8A%E7%9F%A9%E9%98%B5%E7%9A%84%E5%8E%8B%E7%BC%A9%E5%AD%98%E5%82%A8">特殊矩阵的压缩存储</a>
<ul>
<li><a href="#%E5%AF%B9%E7%A7%B0%E7%9F%A9%E9%98%B5">对称矩阵</a></li>
<li><a href="#%E4%B8%89%E8%A7%92%E7%9F%A9%E9%98%B5">三角矩阵</a></li>
<li><a href="#%E4%B8%89%E5%AF%B9%E8%A7%92%E7%9F%A9%E9%98%B5">三对角矩阵</a></li>
<li><a href="#%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5">稀疏矩阵</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- raw HTML omitted -->
<h2 id="定义">定义</h2>
<p><strong>栈</strong>(stack) 是只允许一端进行插入或删除操作的<strong>线性表</strong>（是同一端）.</p>
<p>重要术语</p>
<ul>
<li>栈顶</li>
<li>栈底</li>
<li>空栈</li>
</ul>
<p>特点：LIFO（Last In First Out）后进的先出</p>
<p>基本操作</p>
<ul>
<li>InitStack(&amp; S)：初始化栈。构造一个空栈S，分配内存空间。</li>
<li>DestroyStack(&amp; S)：销毁栈。销毁并释放栈S所占的内存空间。</li>
<li>Push(&amp;S, x)：进栈，若栈S未满，则将x加入使之成为新<strong>栈顶</strong>。</li>
<li>Pop(&amp;S, &amp;x)：出栈，若栈S非空，则弹出<strong>栈顶</strong>元素，并用x返回</li>
<li>GetTop(S, &amp;x)：读栈顶元素。若栈S非空，则用x返回栈顶元素
<ul>
<li>栈的差一般只访问栈顶元素</li>
</ul>
</li>
<li>StackEmpty(S)：判断一个栈S是否为空，若为空，则返回true，否则返回false。</li>
</ul>
<p>常考题型：判断合法的出栈的顺序（要满足先进后出，后进先出）</p>
<blockquote>
<p>n个不同元素进栈，出栈元素不同排列的个数为 $\dfrac{1}{n+1}C_{2n}^{n}$。<br>
上述公式成为卡特兰(Catalan)数，可用数学归纳法法证明。<br>
例如：有3个数据元素abc，有 $\dfrac{1}{4}\cdot\dfrac{6*5*4}{1*2*3}=5$ 种可能<br>
a进a出b进b出c进c出<br>
ab进b出c进c出<br>
abc进cba出<br>
a进a出bc进cb出<br>
ab进ba出c进c出</p>
</blockquote>
<h2 id="顺序栈">顺序栈</h2>
<p>定义</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">#define MaxSize 10 </span><span style="color:#75715e">// 定义栈中元素的最大个数
</span><span style="color:#75715e"></span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span>{
  ElemType data[MaxSize]; <span style="color:#75715e">// 静态数组存放栈中元素
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">int</span> top; <span style="color:#75715e">// 栈顶指针
</span><span style="color:#75715e"></span>}SqStack;
</code></pre></div><p>初始化栈：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">InitStack</span>(SqStack <span style="color:#f92672">&amp;</span>S){
  S.top <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>; <span style="color:#75715e">// 初始化栈顶指针 
</span><span style="color:#75715e"></span>}
</code></pre></div><p>判断栈空</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">StackEmpty</span>(SqStack S){
  <span style="color:#66d9ef">if</span>(S.top <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)
    <span style="color:#66d9ef">return</span> true;
  <span style="color:#66d9ef">else</span>
    <span style="color:#66d9ef">return</span> false;
}
</code></pre></div><h3 id="顺序栈-进栈">顺序栈-进栈</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">Push</span>(SqStack <span style="color:#f92672">&amp;</span>S, ElemType x){
  <span style="color:#66d9ef">if</span>(S.top <span style="color:#f92672">==</span> MaxSize <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)
    <span style="color:#66d9ef">return</span> false;
  S.top<span style="color:#f92672">++</span>; <span style="color:#75715e">// 指针加一
</span><span style="color:#75715e"></span>  S.data[S.top]<span style="color:#f92672">=</span>x;
  <span style="color:#75715e">// 上面这两句可以合成一句
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// S.data[++S.top] = x;
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">return</span> true;
}
</code></pre></div><h3 id="顺序表-出栈">顺序表-出栈</h3>
<p>返回了pop出来的元素</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">Pop</span>(SqStack <span style="color:#f92672">&amp;</span>S, ElemType <span style="color:#f92672">&amp;</span>x){
  <span style="color:#66d9ef">if</span>(S.top <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)
    <span style="color:#66d9ef">return</span> false;
  x <span style="color:#f92672">=</span> S.data[S.top];
  S.top<span style="color:#f92672">--</span>;
  <span style="color:#75715e">// 上面这两句可以合成一句
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// x = S.data[S.top--];
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">return</span> true;
}
</code></pre></div><h3 id="顺序栈-读栈">顺序栈-读栈</h3>
<p>获得栈顶元素</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">GetTop</span>(SqStack S, ElemType <span style="color:#f92672">&amp;</span>x){
  <span style="color:#66d9ef">if</span>(S.top <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)
    <span style="color:#66d9ef">return</span> fasle;
  x <span style="color:#f92672">=</span> S.data[S.top];
  <span style="color:#66d9ef">return</span> true;
}
</code></pre></div><p>top如果一开始设计为-1，那么top表示指向的栈顶元素，top一开始如果设计为零，那么top指向的位置是栈顶元素的下一个，也表示当前栈的元素个数</p>
<h3 id="顺序栈-共享栈">顺序栈-共享栈</h3>
<p>提高内存空间的利用率</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">#define MaxSize 10
</span><span style="color:#75715e"></span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span>{
  ElemType data[MaxSize];
  <span style="color:#66d9ef">int</span> top0; <span style="color:#75715e">// 0号栈栈顶指针
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">int</span> top1; <span style="color:#75715e">// 1号栈栈顶指针
</span><span style="color:#75715e"></span>}ShStack;
</code></pre></div><p>初始化栈</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">InitStack</span>(ShStack <span style="color:#f92672">&amp;</span>S){
  S.top0<span style="color:#f92672">=-</span><span style="color:#ae81ff">1</span>; <span style="color:#75715e">// 初始化栈顶指针
</span><span style="color:#75715e"></span>  S.top1<span style="color:#f92672">=</span>MaxSize;
}
</code></pre></div><p>相当于一个空间，两个栈分别把内容推到两头</p>
<h3 id="栈的链式实现">栈的链式实现</h3>
<p>感觉和头插法差不多，单链表只能操作头下一个结点</p>
<p>链头就是栈顶</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> Linknode{
  ElemType data;
  <span style="color:#66d9ef">struct</span> Linknode <span style="color:#f92672">*</span>next;
}<span style="color:#f92672">*</span>LiStack;
</code></pre></div><p>比较简单</p>
<h2 id="队列">队列</h2>
<p><strong>队列</strong>(Queue) 是只允许在一端进行插入，在另一端删除的<strong>线性表</strong></p>
<p>特点：先进队列的元素先出FIFO(First In First Out)<br>
重要术语</p>
<ul>
<li>队头：允许删除的一端</li>
<li>队尾：允许插入的一端</li>
<li>空队列</li>
</ul>
<p>基本操作</p>
<ul>
<li>InitQueue(&amp;Q)：初始化队列，构造一个空队列Q</li>
<li>DestroyQueue(&amp;Q)：销毁队列，销毁并释放队列Q所占的内存空间</li>
<li>EnQueue(&amp;Q, x)：入队，若队列Q未满，将x加入，使之成为新的队尾</li>
<li>DeQueue(&amp;Q, &amp;x)：出队，若队列Q非空，删除对头元素，并用x返回</li>
<li>GetHead(Q, &amp;x)：读队头元素，若队列Q非空，则将对头元素赋值给x</li>
<li>QueueEmpty(Q)：判断队列是否为空，若队列Q为空返回true，否则返回false</li>
</ul>
<p>DeQueue 和 GetHead 的区别在于GetHead不删除对头元素</p>
<p>队列和栈都是操作受限的线性表</p>
<h3 id="队列-顺序存储">队列-顺序存储</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">#define MaxiSize 10
</span><span style="color:#75715e"></span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span>{
  ElemType data[MaxSize]; <span style="color:#75715e">// 用静态数组存放队列元素
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">int</span> front, rear; <span style="color:#75715e">// 队头指针和队尾指针
</span><span style="color:#75715e"></span>}SqQueue;
</code></pre></div><p>顺序存储是指物理空间上的连续<br>
队尾指针是指向下一个存储的位置</p>
<p>初始化队列</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">InitQueue</span>(SqQueue <span style="color:#f92672">&amp;</span>Q){
  <span style="color:#75715e">// 初始时 对头、队尾指针指向0
</span><span style="color:#75715e"></span>  Q.rear <span style="color:#f92672">=</span> Q.front <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p>判断队列是否为空</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">QueueEmpty</span>(SqQueue Q){
  <span style="color:#66d9ef">if</span>(Q.rear <span style="color:#f92672">==</span> Q.front)
      <span style="color:#66d9ef">return</span> true;
  <span style="color:#66d9ef">else</span>
      <span style="color:#66d9ef">return</span> false;
}
</code></pre></div><h3 id="队列-入队">队列-入队</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">EnQueue</span>(SqQueue <span style="color:#f92672">&amp;</span>Q, ElemType x){
  <span style="color:#66d9ef">if</span>((Q.rear<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>)<span style="color:#f92672">%</span>MaxSize <span style="color:#f92672">==</span> Q.front)
    <span style="color:#66d9ef">return</span> false;
  Q.data[Q.rear] <span style="color:#f92672">=</span> x;
  Q,rear<span style="color:#f92672">=</span>(Q.rear<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>)<span style="color:#f92672">%</span>MaxSize;
  <span style="color:#66d9ef">return</span> true;
}
</code></pre></div><p>用这种方式实现的队列成为循环队列，用模运算将存储空间在逻辑上变成了“环状”，这样会浪费一个空间位置，可以通过给SqQueue增加一个size元素，来存储队列中元素的个数，来判断队列已满还是为空<br>
或者增加一个tag元素，用来表示最近一次的操作是插入还是删除，因为判空是通过<code>front == rear</code> 判断的，因此存了MaxSize个数据后，front会等于rear，因此有三种方法</p>
<ul>
<li>只存MaxSize-1个数据，这样只有为空的时候才会front==rear</li>
<li>队列结构里增加一个size元素表示队列里元素的个数</li>
<li>队列结构里增加一个tag元素表示最近一次操作，如果front== rear，那么tag表示删除则为空，tag表示插入则为满</li>
</ul>
<h3 id="队列-出队">队列-出队</h3>
<p>删除一个对头元素，并用x返回</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">DeQueue</span>(SqQueue <span style="color:#f92672">&amp;</span>Q, ElemType <span style="color:#f92672">&amp;</span>x){
  <span style="color:#66d9ef">if</span>(Q.rear <span style="color:#f92672">==</span> Q.front)
    <span style="color:#66d9ef">return</span> false;
  x <span style="color:#f92672">=</span> Q.data[Q.front];
  Q.front <span style="color:#f92672">=</span> (Q.front<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>)<span style="color:#f92672">%</span>MaxSize;
  <span style="color:#66d9ef">return</span> true;
}
</code></pre></div><p>获得对头元素的值，用x返回</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">GetHead</span>(SqQueue Q, ElemType <span style="color:#f92672">&amp;</span>x){
  <span style="color:#66d9ef">if</span>(Q.rear <span style="color:#f92672">==</span> Q.front)
    <span style="color:#66d9ef">return</span> false;
  x <span style="color:#f92672">=</span> Q.data[Q.front];
  <span style="color:#66d9ef">return</span> true;
}
</code></pre></div><p>队列元素个数</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">Length</span>(SqQueue Q){
  <span style="color:#66d9ef">return</span> (Q.rear<span style="color:#f92672">+</span>MaxSize<span style="color:#f92672">-</span>front)<span style="color:#f92672">%</span>MaxSize;
}
</code></pre></div><p>之前讲的都是队尾指针指向下一个存储的地址，也可以队尾指针指向队尾元素，此时的判空方法</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">(rear<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>)<span style="color:#f92672">%</span>MaxSize <span style="color:#f92672">==</span> front
</code></pre></div><p>但是同样的需要牺牲一个存储单元来避免两种状态（满，空）都会识别为空，解决方法和之前相同</p>
<ul>
<li>牺牲一个存储单元</li>
<li>增加辅助变量</li>
</ul>
<h3 id="队列的链式实现">队列的链式实现</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">// 链式队列结点 
</span><span style="color:#75715e"></span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> LinkNode{
  ElemType data;
  <span style="color:#66d9ef">struct</span> LinkNode <span style="color:#f92672">*</span>next;
}LinkNode;

<span style="color:#75715e">// 链式队列
</span><span style="color:#75715e"></span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span>{
  LinkNode <span style="color:#f92672">*</span>front, <span style="color:#f92672">*</span>rear;
}LinkQueue;
</code></pre></div><p>同样分为带头结点和不带头结点</p>
<p>初始化（带头结点）</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">InitQueue</span>(LinkQueue <span style="color:#f92672">&amp;</span>Q){
  <span style="color:#75715e">// 初始化时 front、rear都指向头结点
</span><span style="color:#75715e"></span>  Q.front <span style="color:#f92672">=</span> Q.rear <span style="color:#f92672">=</span> (LinkNode <span style="color:#f92672">*</span>)malloc(<span style="color:#66d9ef">sizeof</span>(LinkNode));
  Q.front<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> NULL;
}
</code></pre></div><p>判断队列是否为空</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">IsEmpty</span>(LinkQueue Q){
  <span style="color:#66d9ef">if</span>(Q.front <span style="color:#f92672">==</span> Q.rear)
    <span style="color:#66d9ef">return</span> true;
  <span style="color:#66d9ef">else</span>
    <span style="color:#66d9ef">return</span> false;
}
</code></pre></div><p>入队（带头结点）</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">EnQueue</span>(LinkQueue <span style="color:#f92672">&amp;</span>Q, ElemType x){
  LinkNode <span style="color:#f92672">*</span>s <span style="color:#f92672">=</span> (LinkNode <span style="color:#f92672">*</span>)malloc(<span style="color:#66d9ef">sizeof</span>(LinkNode));
  <span style="color:#66d9ef">if</span>(s <span style="color:#f92672">==</span> NULL)
    <span style="color:#66d9ef">return</span> false;
  s<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">=</span> x;
  s<span style="color:#f92672">-&gt;</span>next<span style="color:#f92672">=</span> NULL;
  Q.rear<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> s; <span style="color:#75715e">// 新节点插入到rear之后
</span><span style="color:#75715e"></span>  Q.rear <span style="color:#f92672">=</span> s;       <span style="color:#75715e">// 修改表尾指针
</span><span style="color:#75715e"></span>}
</code></pre></div><p>出队（带头结点）</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">DeQueue</span>(LinkQueue <span style="color:#f92672">&amp;</span>Q, ElemType <span style="color:#f92672">&amp;</span>x){
  <span style="color:#66d9ef">if</span>(Q.front <span style="color:#f92672">==</span> Q.rear)
    <span style="color:#66d9ef">return</span> false;
  LinkNode <span style="color:#f92672">*</span>p <span style="color:#f92672">=</span> Q.front<span style="color:#f92672">-&gt;</span>next;
  x <span style="color:#f92672">=</span> p<span style="color:#f92672">-&gt;</span>data; <span style="color:#75715e">// 用变量x返回队头元素
</span><span style="color:#75715e"></span>  Q.front<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> p<span style="color:#f92672">-&gt;</span>next;
  <span style="color:#66d9ef">if</span>(Q.rear <span style="color:#f92672">==</span> p){ <span style="color:#75715e">// 如果此次时最后一个结点出队
</span><span style="color:#75715e"></span>    Q.rear <span style="color:#f92672">=</span> Q.front; <span style="color:#75715e">// 修改rear指针
</span><span style="color:#75715e"></span>  }
  free(p);  <span style="color:#75715e">// 释放结点空间
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">return</span> true;
}
</code></pre></div><p>初始化（不带头结点）</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">InitQueue</span>(LinkQueue <span style="color:#f92672">&amp;</span>Q){
  <span style="color:#75715e">// 初始化时 front、rear 都指向NULL
</span><span style="color:#75715e"></span>  Q.front <span style="color:#f92672">=</span> NULL;
  Q.rear <span style="color:#f92672">=</span> NULL;
}
</code></pre></div><p>判断队列是否为空（不带头结点）</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">IsEmpty</span>(LinkQueue Q){
  <span style="color:#66d9ef">if</span>(Q.front <span style="color:#f92672">==</span> NULL)
    <span style="color:#66d9ef">return</span> true;
  <span style="color:#66d9ef">else</span>
    <span style="color:#66d9ef">return</span> false;
}
</code></pre></div><p>入队（不带头结点）</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">EnQueue</span>(LinkQueue <span style="color:#f92672">&amp;</span>Q, ElemType x){
  LinkNode <span style="color:#f92672">*</span>s <span style="color:#f92672">=</span> (LinkNode <span style="color:#f92672">*</span>)malloc(<span style="color:#66d9ef">sizeof</span>(LinkNode));
  s<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">=</span> x;
  s<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span>NULL;
  <span style="color:#66d9ef">if</span>(Q.front <span style="color:#f92672">==</span> NULL){<span style="color:#75715e">// 对第一个元素特殊处理
</span><span style="color:#75715e"></span>    Q.front <span style="color:#f92672">=</span> s;
    Q.rear<span style="color:#f92672">=</span>s;
  } <span style="color:#66d9ef">else</span> {
    Q.rear<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> s;
    Q.rear <span style="color:#f92672">=</span> s;
  }
}
</code></pre></div><p>出队（不带头结点）</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">DeQueue</span>(LinkQueue <span style="color:#f92672">&amp;</span>Q, ElemType <span style="color:#f92672">&amp;</span>x){
  <span style="color:#66d9ef">if</span>(Q.front <span style="color:#f92672">==</span> NULL)
    <span style="color:#66d9ef">return</span> false; <span style="color:#75715e">// 空队
</span><span style="color:#75715e"></span>  LinkNode <span style="color:#f92672">*</span>p <span style="color:#f92672">=</span> Q.front;
  x <span style="color:#f92672">=</span> p<span style="color:#f92672">-&gt;</span>data;
  Q.front <span style="color:#f92672">=</span> p<span style="color:#f92672">-&gt;</span>next;
  <span style="color:#66d9ef">if</span>(Q.rear <span style="color:#f92672">==</span> p){
    Q.front <span style="color:#f92672">=</span> NULL;
    Q.rear <span style="color:#f92672">=</span> NULL;
  }
  free(p);
  <span style="color:#66d9ef">return</span> true;
}
</code></pre></div><h3 id="双端队列">双端队列</h3>
<p><strong>双端队列</strong>是允许从两端插入、两端删除的线性表。<br>
<strong>输入受限</strong>的双端队列是只允许从一段插入，两端删除的线性表。<br>
<strong>输出受限</strong>的双端队列是只允许两端插入，一端删除的线性表。</p>
<p>常考输出序列的合法性，主要是自己分析orz</p>
<h2 id="栈-括号匹配">栈-括号匹配</h2>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">// 初始化栈
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">InitStack</span>(SqStack <span style="color:#f92672">&amp;</span>S)

<span style="color:#75715e">// 判断栈是否为空
</span><span style="color:#75715e"></span><span style="color:#66d9ef">bool</span> StackEmpty(SqStack S)

<span style="color:#75715e">// 新元素入栈
</span><span style="color:#75715e"></span><span style="color:#66d9ef">bool</span> Push(SqStack <span style="color:#f92672">&amp;</span>S, <span style="color:#66d9ef">char</span> x)

<span style="color:#75715e">// 栈顶元素出栈，用x返回
</span><span style="color:#75715e"></span><span style="color:#66d9ef">bool</span> Pop(SqStack <span style="color:#f92672">&amp;</span>S, <span style="color:#66d9ef">char</span> <span style="color:#f92672">&amp;</span>x)

<span style="color:#66d9ef">bool</span> brancketCheck(<span style="color:#66d9ef">char</span> str[], <span style="color:#66d9ef">int</span> length){
  SqStack S;
  InitStack(S);
  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; i<span style="color:#f92672">&lt;</span>length; i<span style="color:#f92672">++</span>){
    <span style="color:#66d9ef">if</span>(str[i] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;(&#39;</span> <span style="color:#f92672">||</span> str[i] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;[&#39;</span> <span style="color:#f92672">||</span> str[i] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;{&#39;</span>){
      Push(S, str[i]); <span style="color:#75715e">// 扫描到左括号，入栈
</span><span style="color:#75715e"></span>    } <span style="color:#66d9ef">else</span> {
      <span style="color:#66d9ef">if</span>(StackEmpty(S))
        <span style="color:#66d9ef">return</span> false;
      <span style="color:#66d9ef">char</span> topElem;
      Pop(S, topElem);
      <span style="color:#75715e">// 这边我觉得前后交换一下可能会更好，以为按下面这种方式比较如果输入中有不是括号的就检测不出来了
</span><span style="color:#75715e"></span>      <span style="color:#66d9ef">if</span>(str[i] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;)&#34;</span> <span style="color:#f92672">&amp;&amp;</span> topElem<span style="color:#f92672">!=</span> <span style="color:#e6db74">&#39;(&#39;</span>)
        <span style="color:#66d9ef">return</span> false;
      <span style="color:#66d9ef">if</span>(str[i] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;]&#34;</span> <span style="color:#f92672">&amp;&amp;</span> topElem<span style="color:#f92672">!=</span> <span style="color:#e6db74">&#39;[&#39;</span>)
        <span style="color:#66d9ef">return</span> false;
      <span style="color:#66d9ef">if</span>(str[i] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;}&#34;</span> <span style="color:#f92672">&amp;&amp;</span> topElem<span style="color:#f92672">!=</span> <span style="color:#e6db74">&#39;{&#39;</span>)
        <span style="color:#66d9ef">return</span> false;
    }
    <span style="color:#66d9ef">return</span> StackEmpty(S); <span style="color:#75715e">// 检索完全部括号后，说明匹配成功
</span><span style="color:#75715e"></span>  }
}
</code></pre></div><h2 id="栈-表达式求值">栈-表达式求值</h2>
<h3 id="原理">原理</h3>
<p>Reverse Polish notation 逆波兰表达式=后缀表达式<br>
Polish notation 波兰表达式=前缀表达式</p>
<p>中缀表达式就是操作符在两个操作数中间，比如1 + 1<br>
后缀表达式就是操作符在两个操作数后面，比如1 1 +
前缀表达式就是操作符在两个操作数前面，比如+ 1 1</p>
<p><code>a+b-c</code> 的后缀表达式是 <code>a b + c -</code><br>
<code>a+b-c</code> 的前缀表达式是 <code>- + a b c</code><br>
一个表达式的后缀表达式和前缀表达式是不唯一的<br>
<code>a+b-c*d</code> 的后缀表达式是 <code>a b+ c d* -</code><br>
<code>a+b-c*d</code> 的前缀缀表达式是 <code>-+a b * c d</code></p>
<p>中缀表达式转后缀表达式的方法：</p>
<ul>
<li>确定中缀表达式中各个运算符的运算顺序</li>
<li>确定下一个运算符，按照【左操作数 右操作数 运算符】 的方式组成一个新的操作数</li>
<li>如果还有运算符没被处理，就继续上一步</li>
</ul>
<p>因为运算顺序不唯一，因此对应的后缀表达式也不唯一</p>
<p>“左优先”原则：只要左边的运算符能计算，那就优先计算最左边的，这样可以保证运算顺序的唯一性</p>
<p>比如：</p>
<blockquote>
<p>A+B-C*D/E+F 转化为<br>
A B + C D * E / - F +</p>
</blockquote>
<p>我们要怎么样计算这样一个后缀表达式呢？<br>
以上面的例子为例：<br>
先将A，B压入栈中，读到一个操作符，则弹出两次栈顶元素，进行计算，再压入栈中，即：</p>
<ul>
<li>压入A</li>
<li>压入B</li>
<li>读到+号</li>
<li>弹出B</li>
<li>弹出A</li>
<li>计算A+B，并压入栈中</li>
<li>压入C</li>
<li>压入D</li>
<li>读到*号</li>
<li>弹出D</li>
<li>弹出C</li>
<li>计算C*D，并压入栈中</li>
<li>压入E</li>
<li>读到/号</li>
<li>弹出E</li>
<li>弹出C*D</li>
<li>计算C*D/E，并压入栈中</li>
<li>读到-号</li>
<li>弹出C*D/E</li>
<li>弹出A+B</li>
<li>计算(A+B)-(C*D/E)，并压入栈中</li>
<li>压入F</li>
<li>读到+号</li>
<li>弹出F</li>
<li>弹出(A+B)-(C*D/E)</li>
<li>计算(A+B)-(C*D/E)+F并压入栈中</li>
<li>扫描结束，得到最后结果(A+B)-(C*D/E)+F</li>
</ul>
<p>中缀表达式转换成前缀表达式：</p>
<ul>
<li>确定中缀表达式中各个运算符的运算顺序</li>
<li>选择下一个运算符，按照【运算符 左操作数 右操作数】 的方式组合成一个新的操作数</li>
<li>如果还有运算符没有被处理，就继续上一步</li>
</ul>
<p>“右优先”原则：只要右边的运算符能先计算，就优先计算右边的</p>
<p>比如</p>
<blockquote>
<p>A+B*(C-D)-E/F 转化为</p>
<ul>
<li>A - * B- C D / E F</li>
</ul>
</blockquote>
<ul>
<li>从右往左扫描，直到处理完所有的元素</li>
<li>若扫描到操作数则压入栈，并回到上一步，否则执行下一步</li>
<li>若扫描到运算符，则弹出两个栈顶元素，指向相应运算，运算结果压会栈中，返回第一步</li>
</ul>
<p>基本和后缀表达式一致</p>
<h3 id="代码">代码</h3>
<p>中缀表达式转后缀表达式</p>
<ul>
<li>初始化一个栈，用于保存暂时还不能确定运算顺序的运算符</li>
<li>从左到右处理各个元素，直到末尾，可能遇到三种情况
<ul>
<li>遇到操作数，直接加入后缀表达式</li>
<li>遇到界限夫。遇到“(” 直接入栈；遇到&quot;)&quot; 则依次弹出栈内运算符并加入后缀表达式，直到弹出&quot;(&quot;.注意 &ldquo;(&rdquo; 不加入后缀表达式</li>
<li>遇到运算符。依次弹出栈中<strong>优先级</strong>高于或等于当前运算符的所有运算符，并加入后缀表达式，若碰到“(” 或栈空则停止。之后再把当前运算符入栈。</li>
</ul>
</li>
</ul>
<p>按上述方法处理完所有字符后，将栈中剩余运算符依次弹出，并加入后缀表达式。</p>
<p>例子：</p>
<blockquote>
<p>A+B-C*D/E+F <br>
开始扫描<br>
A 加入后缀表达式<br>
 后缀表达式：A<br>
 栈：空<br>
扫描到+号，由于栈空，于是把+号压入栈中<br>
 后缀表达式：A<br>
 栈：+<br>
扫描到B，加入后缀表达式<br>
 后缀表达式：A B<br>
 栈：+<br>
扫描到-号，弹出+号加入后缀表达式，压入-号<br>
 后缀表达式：A B +<br>
 栈：-<br>
扫描到C，压入栈中<br>
 后缀表达式：A B + C<br>
 栈：-<br>
扫描到 * 号，-号比、*号优先级低，*直接压入栈中<br>
 后缀表达式：A B + C<br>
 栈：- *<br>
扫描到D，加入后缀表达式<br>
 后缀表达式：A B + C D<br>
 栈：- *<br>
扫描到/，弹出*，弹出-，把、压入栈中<br>
 后缀表达式：A B + C D *<br>
 栈：- /<br>
扫描到E，加入后缀表达式<br>
 后缀表达式：A B + C D * E<br>
 栈：- /<br>
扫描到+，弹出/，弹出-，压入 +<br>
 后缀表达式：A B + C D * E / - 
 栈：+<br>
扫描到F，加入后缀表达式<br>
 后缀表达式：A B + C D * E / - F
 栈：+<br>
扫描结束，弹出+，加入后缀表达式<br>
 后缀表达式：A B + C D * E / - F +
 栈：空</p>
</blockquote>
<p>大概这样一个过程，得到后缀表达式</p>
<p>带有括号的例子</p>
<blockquote>
<p>A + B*(C-D)-E/F<br>
跳过前面类似的几步<br>
扫描到(，压入栈中<br>
 后缀表达式：A B<br>
 栈：+ * (<br>
扫描到C，加入后缀表达式<br>
 后缀表达式：A B C<br>
 栈：+ * (<br>
扫描到-，压入栈中，遇到(，直接压入栈<br>
 后缀表达式：A B C<br>
 栈：+ * ( -<br>
扫描到D，加入后缀表达式<br>
 后缀表达式：A B C D<br>
 栈：+ * ( -<br>
扫描到)，弹出-，加入后缀表达式。弹出(<br>
 后缀表达式：A B C D -<br>
 栈：+ *<br>
扫描到-，弹出*，弹出-，压入-<br>
 后缀表达式：A B C D - * +<br>
 栈：-<br>
扫描到E，加入后缀表达式<br>
 后缀表达式：A B C D - E<br>
 栈：-<br>
扫描到/，压入栈中<br>
 后缀表达式：A B C D - E<br>
 栈：- /<br>
扫描到F，加入后缀表达式<br>
 后缀表达式：A B C D - E F<br>
 栈：- /<br>
扫描结束，弹出/， 弹出-<br>
 后缀表达式：A B C D - E F / -<br>
 栈：空</p>
</blockquote>
<p>这样我们就通过栈得到了由中缀表达式得到后缀表达式的算法</p>
<p>在生成后缀表达式的同时可以计算值</p>
<h2 id="栈的应用-递归">栈的应用-递归</h2>
<p>函数调用的特点：最后被调用的函数最先执行结束（LIFO）</p>
<p>函数调用时，需要用一个栈存储：</p>
<ul>
<li>调用返回地址</li>
<li>实参</li>
<li>局部变量</li>
</ul>
<p>适合用“递归”算法解决的：可以把原问题转换为属性相同，但规模较小的问题：</p>
<ul>
<li>计算正整数的阶乘</li>
<li>计算斐波那契数列</li>
</ul>
<p>递归调用时，函数调用栈可称为“递归工作栈”<br>
没进入一层递归，就将递归调用所需信息压入栈顶<br>
每退出一层递归，就从栈顶弹出相应信息</p>
<p>太多层递归可能会导致栈溢出，可能会包含很多的重复运算</p>
<h2 id="队列的应用">队列的应用</h2>
<ul>
<li>树的层次遍历<br>
到“树”之后还会再提到，这里只做了解</li>
<li>图的广度优先遍历</li>
<li>在操作系统中的应用</li>
</ul>
<p>多个进程争抢着使用有限的系统资源时，FCFS（First Come First Service，先进来先服务）是一种常用策略。</p>
<h2 id="特殊矩阵的压缩存储">特殊矩阵的压缩存储</h2>
<p>特殊矩阵：</p>
<ul>
<li>对称矩阵</li>
<li>三角矩阵</li>
<li>三对角矩阵</li>
<li>稀疏矩阵</li>
</ul>
<p>二维数组的存储策略：行优先存储、列优先存储</p>
<p>一个2×2的矩阵
行优先存储：（0，0）、（0，1）、（1，0）、（1，1）<br>
列优先存储：（0，0）、（1，0）、（0，1）、（1，1）</p>
<h3 id="对称矩阵">对称矩阵</h3>
<p>对称矩阵的压缩存储，由于对阵矩阵的特殊性，因此只需要存储上三角区域即可，按行优先原则将各元素存入一维数组B中即可<br>
基于行优先：</p>
<table>
<thead>
<tr>
<th>B[0]</th>
<th>B[1]</th>
<th>B[2]</th>
<th>&hellip;</th>
<th>B[n-1]</th>
<th>B[n]</th>
<th>&hellip;</th>
</tr>
</thead>
<tbody>
<tr>
<td>a11</td>
<td>a12</td>
<td>a13</td>
<td>&hellip;</td>
<td>a1n</td>
<td>a22</td>
<td>&hellip;</td>
</tr>
</tbody>
</table>
<p>这样只需要存n(n+1)/2个元素即可，具体访问的时候可以做一个映射</p>
<h3 id="三角矩阵">三角矩阵</h3>
<p>三角矩阵是下三角矩阵为任意数，上三角区域除去对角线为相同的常数，因此我们可以在对称矩阵的基础上加一个位置，存放这个常量，其他都一样</p>
<h3 id="三对角矩阵">三对角矩阵</h3>
<p>三对角矩阵又被叫做带状矩阵，除了主对角线左边和右边以外的元素都为0。按行优先原则，只存储带状部分</p>
<h3 id="稀疏矩阵">稀疏矩阵</h3>
<p>非零元素远远小于矩阵的元素的个数<br>
顺序存储：通过三元组存储&lt;行，列，值&gt;，</p>
<p>链式存储：十字链表法<br>
存了五个数据：行、列、值、指向同列下一个元素、下指向同行下一个元素</p>

    </div>
    <div class="post-footer">
      
    </div>
  </article>

    </main>
  </body>
</html>
