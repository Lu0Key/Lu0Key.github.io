<!doctype html>
<html lang="en-us">
  <head>
    <title>王道考研 数据结构 串 // 洛七的摸鱼池塘</title>
    <link rel="shortcut icon" href="/favicon.ico" />
    <meta charset="utf-8" />
    <meta name="generator" content="Hugo 0.115.4">
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="洛七" />
    <meta name="description" content="" />
    <link rel="stylesheet" href="/css/main.min.d08c6ce68432c68a64d84cb426dfdecab702035f91a5d580831f23f76c040a05.css" />

    
    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="王道考研 数据结构 串"/>
<meta name="twitter:description" content="串 串 定义 存储结构 顺序存储 链式存储 基本操作 求子串 比较字符串 定位操作 朴素模式匹配算法 KMP 算法 KMP算法优化 定义 串，即字符串（String）是由零个或者多个字符组成的有限序列。一般记为 S = &lsquo;a1a2&hellip;a_n&rsquo; ($n\geqslant0$)
其中，S是串名，单引号括起来的字符序列是串的值；$a_i$可以是字母、数字或者其他字符；串中字符的个数n称为串的长度。n=0 时的串称为空串（用 $\varnothing$ 表示）
字串：串中任意个连续的字符组成的子序列
主串：包含字串的串
字符在主串中的位置：字符在串中的序号
字串在主串中的位置：字串的第一个字符在主串中的位置
位序是从1开始，而不是0开始
串是一种特殊的线性表，数据元素之间呈线性关系
串的数据对象限定为字符集（如中文字符、英文字符、数字字符、标点字符等）
串的基本操作，如增删改查通常以字串为操作对象
串的基本操作
StrAssign(&amp;T, chars)：赋值操作，把串T赋值为chars StrCopy(&amp;T, S)：复制操作。由串S复制得到串T StrEmpty(S)：判空操作。若S为空串，则返回true，否则返回false StrLength(S)：求串长，返回串S的元素个数 ClearString(&amp;S)：清空操作。将S清为空串 DestroyString(&amp;S)：销毁串。将串S销毁，回收存储空间 Concat(&amp;T, S1, S2)：串联接。用T返回由S1和S2联接而成的新串 SubString(&amp;sub, S, pos, len)：求字串，用sub但会串S的第pos个字符起长度为len的子串 Index(S, T)：定位操作。若主串S中存在与串T值相同的子串，则返回它在主串S中第一次出现的位置；否则函数值为0 StrCompare(S, T)：比较操作。若S&gt;T，则返回值&gt;0，若S=T，则返回值=0，若S&lt; T，则返回值&lt;0 这个比较是一个字符一个字符比较的，那字符怎么比较呢？
ASCII字符编码，将数字与字符一一对应，因此比较字符实际上就是比较字符对应的数字
乱码问题：
不同的编码规则可能会导致乱码
存储结构 顺序存储 静态数组实现（定长顺序存储）
#define MAXLEN 255 // 预定义最大串为255 typedef struct{ char ch[MAXLEN];// 每个分量存储一个字符 int length; // 串的实际长度 }SString; 动态数组实现（堆分配存储）"/>

    <meta property="og:title" content="王道考研 数据结构 串" />
<meta property="og:description" content="串 串 定义 存储结构 顺序存储 链式存储 基本操作 求子串 比较字符串 定位操作 朴素模式匹配算法 KMP 算法 KMP算法优化 定义 串，即字符串（String）是由零个或者多个字符组成的有限序列。一般记为 S = &lsquo;a1a2&hellip;a_n&rsquo; ($n\geqslant0$)
其中，S是串名，单引号括起来的字符序列是串的值；$a_i$可以是字母、数字或者其他字符；串中字符的个数n称为串的长度。n=0 时的串称为空串（用 $\varnothing$ 表示）
字串：串中任意个连续的字符组成的子序列
主串：包含字串的串
字符在主串中的位置：字符在串中的序号
字串在主串中的位置：字串的第一个字符在主串中的位置
位序是从1开始，而不是0开始
串是一种特殊的线性表，数据元素之间呈线性关系
串的数据对象限定为字符集（如中文字符、英文字符、数字字符、标点字符等）
串的基本操作，如增删改查通常以字串为操作对象
串的基本操作
StrAssign(&amp;T, chars)：赋值操作，把串T赋值为chars StrCopy(&amp;T, S)：复制操作。由串S复制得到串T StrEmpty(S)：判空操作。若S为空串，则返回true，否则返回false StrLength(S)：求串长，返回串S的元素个数 ClearString(&amp;S)：清空操作。将S清为空串 DestroyString(&amp;S)：销毁串。将串S销毁，回收存储空间 Concat(&amp;T, S1, S2)：串联接。用T返回由S1和S2联接而成的新串 SubString(&amp;sub, S, pos, len)：求字串，用sub但会串S的第pos个字符起长度为len的子串 Index(S, T)：定位操作。若主串S中存在与串T值相同的子串，则返回它在主串S中第一次出现的位置；否则函数值为0 StrCompare(S, T)：比较操作。若S&gt;T，则返回值&gt;0，若S=T，则返回值=0，若S&lt; T，则返回值&lt;0 这个比较是一个字符一个字符比较的，那字符怎么比较呢？
ASCII字符编码，将数字与字符一一对应，因此比较字符实际上就是比较字符对应的数字
乱码问题：
不同的编码规则可能会导致乱码
存储结构 顺序存储 静态数组实现（定长顺序存储）
#define MAXLEN 255 // 预定义最大串为255 typedef struct{ char ch[MAXLEN];// 每个分量存储一个字符 int length; // 串的实际长度 }SString; 动态数组实现（堆分配存储）" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://Lu0key.github.io/post/%E7%8E%8B%E9%81%93%E8%80%83%E7%A0%94-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%B8%B2/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2021-02-06T22:10:51+08:00" />
<meta property="article:modified_time" content="2021-02-06T22:10:51+08:00" />


  </head>
  <body>
    <header class="app-header">
      <a href="https://Lu0key.github.io/"><img class="app-header-avatar" src="/avatar.jpg" alt="洛七" /></a>
      <span class="app-header-title">洛七的摸鱼池塘</span>
      <nav class="app-header-menu">
          <a class="app-header-menu-item" href="/tags/">Tags</a>
      </nav>
      <p>即将没书读的咸鱼</p>
    </header>
    <main class="app-container">
      
  <article class="post">
    <header class="post-header">
      <h1 class ="post-title">王道考研 数据结构 串</h1>
      <div class="post-meta">
        <div>
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar">
  <title>calendar</title>
  <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line>
</svg>
          Feb 6, 2021
        </div>
        <div>
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock">
  <title>clock</title>
  <circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline>
</svg>
          3 min read
        </div>
        <div>
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tag">
  <title>tag</title>
  <path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path><line x1="7" y1="7" x2="7.01" y2="7"></line>
</svg>
              <a class="tag" href="https://Lu0key.github.io/tags/%E8%80%83%E7%A0%94/">考研</a>
              <a class="tag" href="https://Lu0key.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a>
        </div>
      </div>
    </header>
    <div class="post-content">
      <h1 id="串">串</h1>
<!-- raw HTML omitted -->
<ul>
<li><a href="#%E4%B8%B2">串</a>
<ul>
<li><a href="#%E5%AE%9A%E4%B9%89">定义</a></li>
<li><a href="#%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84">存储结构</a>
<ul>
<li><a href="#%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8">顺序存储</a></li>
<li><a href="#%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8">链式存储</a></li>
</ul>
</li>
<li><a href="#%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C">基本操作</a>
<ul>
<li><a href="#%E6%B1%82%E5%AD%90%E4%B8%B2">求子串</a></li>
<li><a href="#%E6%AF%94%E8%BE%83%E5%AD%97%E7%AC%A6%E4%B8%B2">比较字符串</a></li>
<li><a href="#%E5%AE%9A%E4%BD%8D%E6%93%8D%E4%BD%9C">定位操作</a></li>
</ul>
</li>
<li><a href="#%E6%9C%B4%E7%B4%A0%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95">朴素模式匹配算法</a></li>
<li><a href="#kmp-%E7%AE%97%E6%B3%95">KMP 算法</a></li>
<li><a href="#kmp%E7%AE%97%E6%B3%95%E4%BC%98%E5%8C%96">KMP算法优化</a></li>
</ul>
</li>
</ul>
<!-- raw HTML omitted -->
<h2 id="定义">定义</h2>
<p>串，即字符串（String）是由零个或者多个字符组成的有限序列。一般记为
S = &lsquo;a1a2&hellip;a_n&rsquo;  ($n\geqslant0$)</p>
<p>其中，S是串名，单引号括起来的字符序列是串的值；$a_i$可以是字母、数字或者其他字符；串中字符的个数n称为串的长度。n=0 时的串称为空串（用 $\varnothing$ 表示）</p>
<p>字串：串中任意个连续的字符组成的子序列<br>
主串：包含字串的串<br>
字符在主串中的位置：字符在串中的序号<br>
字串在主串中的位置：字串的第一个字符在主串中的位置<br>
位序是从1开始，而不是0开始</p>
<p>串是一种特殊的线性表，数据元素之间呈线性关系</p>
<p>串的数据对象限定为字符集（如中文字符、英文字符、数字字符、标点字符等）</p>
<p>串的基本操作，如增删改查<strong>通常以字串为操作对象</strong></p>
<p>串的基本操作</p>
<ul>
<li>StrAssign(&amp;T, chars)：赋值操作，把串T赋值为chars</li>
<li>StrCopy(&amp;T, S)：复制操作。由串S复制得到串T</li>
<li>StrEmpty(S)：判空操作。若S为空串，则返回true，否则返回false</li>
<li>StrLength(S)：求串长，返回串S的元素个数</li>
<li>ClearString(&amp;S)：清空操作。将S清为空串</li>
<li>DestroyString(&amp;S)：销毁串。将串S销毁，回收存储空间</li>
<li>Concat(&amp;T, S1, S2)：串联接。用T返回由S1和S2联接而成的新串</li>
<li>SubString(&amp;sub, S, pos, len)：求字串，用sub但会串S的第pos个字符起长度为len的子串</li>
<li>Index(S, T)：定位操作。若主串S中存在与串T值相同的子串，则返回它在主串S中第一次出现的位置；否则函数值为0</li>
<li>StrCompare(S, T)：比较操作。若S&gt;T，则返回值&gt;0，若S=T，则返回值=0，若S&lt; T，则返回值&lt;0</li>
</ul>
<p>这个比较是一个字符一个字符比较的，那字符怎么比较呢？<br>
ASCII字符编码，将数字与字符一一对应，因此比较字符实际上就是比较字符对应的数字</p>
<p>乱码问题：<br>
不同的编码规则可能会导致乱码</p>
<h2 id="存储结构">存储结构</h2>
<h3 id="顺序存储">顺序存储</h3>
<p>静态数组实现（定长顺序存储）</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#define MAXLEN 255  </span><span style="color:#75715e">// 预定义最大串为255
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">char</span> ch[MAXLEN];<span style="color:#75715e">// 每个分量存储一个字符
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> length;     <span style="color:#75715e">// 串的实际长度
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}SString;
</span></span></code></pre></div><p>动态数组实现（堆分配存储）</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>ch;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> length;
</span></span><span style="display:flex;"><span>}HString;
</span></span><span style="display:flex;"><span>HString S;
</span></span><span style="display:flex;"><span>S.ch <span style="color:#f92672">=</span> (<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>)<span style="color:#a6e22e">malloc</span>(MAXLEN <span style="color:#f92672">*</span> <span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">char</span>));
</span></span><span style="display:flex;"><span>S.length <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; 
</span></span></code></pre></div><h3 id="链式存储">链式存储</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> StringNode{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">char</span> ch; <span style="color:#75715e">// 每个结点存1个字符
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">struct</span> String <span style="color:#f92672">*</span> next;
</span></span><span style="display:flex;"><span>}StringNode, <span style="color:#f92672">*</span>String;
</span></span></code></pre></div><p>这种方式存储密度低：每个字符1B，每个结构指针4B</p>
<p>改进版，提高存储密度：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> StringNode{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">char</span> ch[<span style="color:#ae81ff">4</span>];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> StringNode <span style="color:#f92672">*</span> next;
</span></span><span style="display:flex;"><span>}StringNode, <span style="color:#f92672">*</span> String;
</span></span></code></pre></div><h2 id="基本操作">基本操作</h2>
<h3 id="求子串">求子串</h3>
<p>基于顺序存储，静态数组实现的</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">SubString</span>(SStriuing <span style="color:#f92672">&amp;</span>Sub, SString S, <span style="color:#66d9ef">int</span> pos, <span style="color:#66d9ef">int</span> len){
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 子串范围越界
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (pos<span style="color:#f92672">+</span>len<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span><span style="color:#f92672">&gt;</span>S.length)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span>pos; i<span style="color:#f92672">&lt;</span>pos<span style="color:#f92672">+</span>len; i<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>        Sub.ch[i<span style="color:#f92672">-</span>pos<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> S.ch[i];
</span></span><span style="display:flex;"><span>    Sub.length <span style="color:#f92672">=</span> len;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="比较字符串">比较字符串</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">StrCompare</span>(SString S, SString T) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>, i<span style="color:#f92672">&lt;=</span>S.length <span style="color:#f92672">&amp;&amp;</span> i<span style="color:#f92672">&lt;=</span>T.length; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (S.ch[i]<span style="color:#f92672">!=</span>T.ch[i])
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> S.ch[i]<span style="color:#f92672">-</span>T.ch[i];
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 扫描过的所有字符都相同，则长度长的串更大
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> S.length <span style="color:#f92672">-</span> T.length;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="定位操作">定位操作</h3>
<p>若主串S中存在与串T值相同的子串，则返回它在主串S中第一次出现的位置，否则函数值为0</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">Index</span>(SString S, SString T){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>, n<span style="color:#f92672">=</span><span style="color:#a6e22e">StrLength</span>(S), m<span style="color:#f92672">=</span><span style="color:#a6e22e">StrLength</span>(T);
</span></span><span style="display:flex;"><span>    SString sub; <span style="color:#75715e">// 用于暂存子串
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">while</span>(i<span style="color:#f92672">&lt;</span>n<span style="color:#f92672">-</span>m<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">SubString</span>(sub, S, i, m);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(<span style="color:#a6e22e">StrCompare</span>(sub, T)<span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>            i<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> i; <span style="color:#75715e">// 返回子串在主串的位置
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>; <span style="color:#75715e">// S中不存在与T相等的子串
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><h2 id="朴素模式匹配算法">朴素模式匹配算法</h2>
<p>串的模式匹配：在主串中找到模式串相同的子串，并返回其所在位置。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">Index</span>(SString S, SString T){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> k<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span>k,j<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(i<span style="color:#f92672">&lt;=</span>S.length <span style="color:#f92672">&amp;&amp;</span> j<span style="color:#f92672">&lt;=</span>T.length){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(S.ch[i]<span style="color:#f92672">==</span>T.ch[j]){
</span></span><span style="display:flex;"><span>            i<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>            j<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>        }<span style="color:#66d9ef">else</span>{
</span></span><span style="display:flex;"><span>            k<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>            i<span style="color:#f92672">=</span>k;
</span></span><span style="display:flex;"><span>            j<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(j<span style="color:#f92672">&gt;</span>T.length)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> k;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>朴素模式匹配算法性能<br>
最好情况时间复杂度O(n)<br>
最坏情况时间复杂度O(nm)<br>
最好情况：子串之前第一个字符就不匹配<br>
最坏情况：总是匹配到第一个字符</p>
<p>朴素模式匹配算法，每次回溯都只往后移动一次</p>
<h2 id="kmp-算法">KMP 算法</h2>
<p>思想：主串不回溯，只有模式串指针回溯</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">Index_KMP</span>(SString S, SString T, <span style="color:#66d9ef">int</span> next []){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>,j<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (i<span style="color:#f92672">&lt;=</span>S.length <span style="color:#f92672">&amp;&amp;</span> j<span style="color:#f92672">&lt;=</span>T.length) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(j<span style="color:#f92672">==</span><span style="color:#ae81ff">0</span><span style="color:#f92672">||</span>S.ch[i]<span style="color:#f92672">==</span>T.ch[j]){
</span></span><span style="display:flex;"><span>            i<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>            j<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>            j<span style="color:#f92672">=</span>next[j];
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (j<span style="color:#f92672">&gt;</span>T.length)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> i<span style="color:#f92672">-</span>T.length;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>    
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>上面我们会发现一个next数组，下面就是如何算next数组的方法，next数组是用来决定不同匹配位置匹配不上的时候向右移动多少格</p>
<p>串的前缀：包含第一个字符，且不包含最后一个字符的子串<br>
串的后缀：包含最后一个字符，且不包含第一个字符的子串<br>
当第j个字符匹配失败，由前1~j-1个字符组成的串记为S，则：<br>
next[j] = S 的最长相等前后缀长度+1<br>
特别地，next[1]=0</p>
<table>
<thead>
<tr>
<th>序号j</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
</tr>
</thead>
<tbody>
<tr>
<td>模式串</td>
<td>a</td>
<td>b</td>
<td>a</td>
<td>b</td>
<td>a</td>
<td>a</td>
</tr>
<tr>
<td>next[j]</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
</tr>
</tbody>
</table>
<blockquote>
<p>第1个匹配不成功，直接0<br>
第2个匹配不成功，前后缀长度都是0，加1，于是为1<br>
第3个匹配不成功，前缀a，后缀b，相等长度为0，加1，于是为1<br>
第4个匹配不成功，前缀ab，后缀ba，最长相等长度为1，加1，于是为2<br>
第5个匹配不成功，前缀为aba，后缀为bab，最长相等为ab，长度为2，加1，于是为3<br>
第6个匹配不成功，前缀为abab，后缀为baba，最长相等为aba，长度为3，加1，于是为4</p>
</blockquote>
<p>求模式串T的next数组</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">get_next</span>(SString T, <span style="color:#66d9ef">int</span> next[]){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>, j<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    next[<span style="color:#ae81ff">1</span>]<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(i<span style="color:#f92672">&lt;</span>T.length) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(j<span style="color:#f92672">==</span><span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span> T.ch[i] <span style="color:#f92672">==</span> T.ch[j]){
</span></span><span style="display:flex;"><span>            i<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>            j<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 若pi=pj，则 next[j+1]=next[j] + 1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            next[i] <span style="color:#f92672">=</span> j;
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 否则令 j=next[j]，循环继续
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            j <span style="color:#f92672">=</span> next[j];
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="kmp算法优化">KMP算法优化</h2>
<p>只是优化了next数组，将next数组优化成nextval数组</p>
<p>主要代码为</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>nextval[<span style="color:#ae81ff">1</span>]<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (T.ch[next[j]]<span style="color:#f92672">==</span>T.ch[j]) {
</span></span><span style="display:flex;"><span>    nextval[j] <span style="color:#f92672">=</span> nextval[next[j]];
</span></span><span style="display:flex;"><span>} <span style="color:#66d9ef">else</span>{
</span></span><span style="display:flex;"><span>    nextval[j] <span style="color:#f92672">=</span> next[j]
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>先手算出next数组，比如</p>
<table>
<thead>
<tr>
<th>序号j</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
</tr>
</thead>
<tbody>
<tr>
<td>模式串</td>
<td>a</td>
<td>b</td>
<td>a</td>
<td>b</td>
<td>a</td>
<td>a</td>
</tr>
<tr>
<td>next[j]</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
</tr>
</tbody>
</table>
<p>然后</p>
<table>
<thead>
<tr>
<th>序号j</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
</tr>
</thead>
<tbody>
<tr>
<td>模式串</td>
<td>a</td>
<td>b</td>
<td>a</td>
<td>b</td>
<td>a</td>
<td>a</td>
</tr>
<tr>
<td>next[j]</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
</tr>
<tr>
<td>nextval[j]</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>4</td>
</tr>
</tbody>
</table>
<blockquote>
<p>判断过程<br>
T.ch[next[2]]是a，T.ch[2]是b<br>
因此nextval[2]=next[2]=1<br>
T.ch[next[3]]是a，T.ch[3]是a<br>
因此nextval[3]=nextval[next[3]]=nextval[1]=0<br>
T.ch[next[4]]是b，T.ch[4]是b<br>
因此nextval[4]=nextval[next[4]]=nextval[2]=1<br>
T.ch[next[5]]是a，T.ch[5]是a<br>
因此nextval[5]=nextval[next[5]]=nextval[3]=0<br>
T.ch[next[6]]是b，T.ch[6]是a<br>
因此nextval[6]=next[6]=4</p>
</blockquote>

    </div>
    <div class="post-footer">
      
    </div>
  </article>

    </main>
  </body>
</html>
