<!doctype html>
<html lang="en-us">
  <head>
    <title>王道考研 数据结构 绪论 // 洛七的摸鱼池塘</title>
    <link rel="shortcut icon" href="/favicon.ico" />
    <meta charset="utf-8" />
    <meta name="generator" content="Hugo 0.115.4">
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="洛七" />
    <meta name="description" content="" />
    <link rel="stylesheet" href="/css/main.min.d08c6ce68432c68a64d84cb426dfdecab702035f91a5d580831f23f76c040a05.css" />

    
    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="王道考研 数据结构 绪论"/>
<meta name="twitter:description" content="绪论 学什么 如何用程序代码把现实世界的问题信息化 如何用计算机高效地处理这些信息从而创造价值 基本概念 数据 数据是信息的载体，是描述客观事物属性的数、字符及所有能输入到计算机中并被计算机程序识别和处理的符号的集合。数据是计算机程序加工的原料。
数据元素、数据项 数据元素是数据的基本单位，通常作为一个整体进行考虑和处理。
一个数据元素可由若干个数据项组成，数据项是构成数据元素的不可分割的最小单位。
数据结构、数据对象 结构 是各个元素之间的关系
数据结构 是相互之间存在一种或者多种特定关系的数据元素的集合。
数据对象 是具有相同性质的数据元素的集合，是数据的一个子集。
数据结构的三要素 逻辑结构
集合 各个元素同属一个集合，别无其他关系 线性结构 数据元素之间是一对一的关系，除了第一个元素，所有元素都有唯一前驱，除了最后一个元素，所有元素都有唯一后继 树形结构 数据元素之间是一对多的关系 图状结构（网状结构） 数据元素之间是多对多的关系 物理结构（存储结构）
顺序存储 存储位置相邻 链式存储 借助元素存储地址的指针来辨识元素之间的逻辑关系 索引存储 索引表，索引表中的每项称为索引项(关键字，地址) 散列存储 通过元素的关键字直接计算出该元素的存储地址，又称哈希（Hash）存储 数据的运算
运算的实现是针对存储结构的 若采用顺序存储，则各个数据元素在物理上必须是连续的；若采用非顺序存储，则各个数据元素在物理上可以是离散的。
数据的存储结构会影响存储空间分配的方便程度
数据类型、抽象数据类型：
数据类型 是一个值的集合和定义在此集合上的一组操作的总称。
原子类型。其值不可再分的数据类型。 结构类型。其值可以再分解为若干成分的数据类型。 抽象数据类型(Abstract Data Type, ADT) 是抽象数据组织与之相关的操作。
算法 算法的特性：
有穷性 必须在执行有穷步之后结束，且每一步都可以在有穷时间内完成。 算法必须是有穷的，而程序可以是无穷的 确定性 相同的输入只能得到相同的输出 可行性 算法中描述的操作都可以通过已经实现的基本运算执行有限次来实现 输入 一个算法有零个或者多个输入，这些输入取自于某个特定的对象的集合。 输出 一个算个有一个或者多个输出，这些输出是与输入有着某种特定关系的量。 “好”的算法的特性：
正确性 算法应能够正确地解决求解问题。 可读性 算法应具有良好的可读性，以帮助人们理解（无歧义） 健壮性 输入非法数据时，算法能适当地做出反应或进行处理，而不会产生莫名其妙的输出结果。 高效率与低存储量需求 时、空间复杂度低 时间复杂度 无法运行结束统计运行时间来判断算法的时间开销，比如：导弹发射之类的。并且在结束之前你不知道他还要运行多久，因此希望算法复杂度能够在运行前计算出来"/>

    <meta property="og:title" content="王道考研 数据结构 绪论" />
<meta property="og:description" content="绪论 学什么 如何用程序代码把现实世界的问题信息化 如何用计算机高效地处理这些信息从而创造价值 基本概念 数据 数据是信息的载体，是描述客观事物属性的数、字符及所有能输入到计算机中并被计算机程序识别和处理的符号的集合。数据是计算机程序加工的原料。
数据元素、数据项 数据元素是数据的基本单位，通常作为一个整体进行考虑和处理。
一个数据元素可由若干个数据项组成，数据项是构成数据元素的不可分割的最小单位。
数据结构、数据对象 结构 是各个元素之间的关系
数据结构 是相互之间存在一种或者多种特定关系的数据元素的集合。
数据对象 是具有相同性质的数据元素的集合，是数据的一个子集。
数据结构的三要素 逻辑结构
集合 各个元素同属一个集合，别无其他关系 线性结构 数据元素之间是一对一的关系，除了第一个元素，所有元素都有唯一前驱，除了最后一个元素，所有元素都有唯一后继 树形结构 数据元素之间是一对多的关系 图状结构（网状结构） 数据元素之间是多对多的关系 物理结构（存储结构）
顺序存储 存储位置相邻 链式存储 借助元素存储地址的指针来辨识元素之间的逻辑关系 索引存储 索引表，索引表中的每项称为索引项(关键字，地址) 散列存储 通过元素的关键字直接计算出该元素的存储地址，又称哈希（Hash）存储 数据的运算
运算的实现是针对存储结构的 若采用顺序存储，则各个数据元素在物理上必须是连续的；若采用非顺序存储，则各个数据元素在物理上可以是离散的。
数据的存储结构会影响存储空间分配的方便程度
数据类型、抽象数据类型：
数据类型 是一个值的集合和定义在此集合上的一组操作的总称。
原子类型。其值不可再分的数据类型。 结构类型。其值可以再分解为若干成分的数据类型。 抽象数据类型(Abstract Data Type, ADT) 是抽象数据组织与之相关的操作。
算法 算法的特性：
有穷性 必须在执行有穷步之后结束，且每一步都可以在有穷时间内完成。 算法必须是有穷的，而程序可以是无穷的 确定性 相同的输入只能得到相同的输出 可行性 算法中描述的操作都可以通过已经实现的基本运算执行有限次来实现 输入 一个算法有零个或者多个输入，这些输入取自于某个特定的对象的集合。 输出 一个算个有一个或者多个输出，这些输出是与输入有着某种特定关系的量。 “好”的算法的特性：
正确性 算法应能够正确地解决求解问题。 可读性 算法应具有良好的可读性，以帮助人们理解（无歧义） 健壮性 输入非法数据时，算法能适当地做出反应或进行处理，而不会产生莫名其妙的输出结果。 高效率与低存储量需求 时、空间复杂度低 时间复杂度 无法运行结束统计运行时间来判断算法的时间开销，比如：导弹发射之类的。并且在结束之前你不知道他还要运行多久，因此希望算法复杂度能够在运行前计算出来" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://Lu0key.github.io/post/%E7%8E%8B%E9%81%93%E8%80%83%E7%A0%94-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BB%AA%E8%AE%BA/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2021-01-22T19:09:34+08:00" />
<meta property="article:modified_time" content="2021-01-22T19:09:34+08:00" />


  </head>
  <body>
    <header class="app-header">
      <a href="https://Lu0key.github.io/"><img class="app-header-avatar" src="/avatar.jpg" alt="洛七" /></a>
      <span class="app-header-title">洛七的摸鱼池塘</span>
      <nav class="app-header-menu">
          <a class="app-header-menu-item" href="/tags/">Tags</a>
      </nav>
      <p>即将没书读的咸鱼</p>
    </header>
    <main class="app-container">
      
  <article class="post">
    <header class="post-header">
      <h1 class ="post-title">王道考研 数据结构 绪论</h1>
      <div class="post-meta">
        <div>
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar">
  <title>calendar</title>
  <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line>
</svg>
          Jan 22, 2021
        </div>
        <div>
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock">
  <title>clock</title>
  <circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline>
</svg>
          2 min read
        </div>
        <div>
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tag">
  <title>tag</title>
  <path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path><line x1="7" y1="7" x2="7.01" y2="7"></line>
</svg>
              <a class="tag" href="https://Lu0key.github.io/tags/%E8%80%83%E7%A0%94/">考研</a>
              <a class="tag" href="https://Lu0key.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a>
        </div>
      </div>
    </header>
    <div class="post-content">
      <h1 id="绪论">绪论</h1>
<h2 id="学什么">学什么</h2>
<ul>
<li>如何用程序代码把现实世界的问题信息化</li>
<li>如何用计算机高效地处理这些信息从而创造价值</li>
</ul>
<h2 id="基本概念">基本概念</h2>
<h3 id="数据">数据</h3>
<blockquote>
<p><strong>数据</strong>是信息的载体，是描述客观事物属性的数、字符及所有能输入到计算机中并被计算机程序识别和处理的符号的集合。数据是计算机程序加工的原料。</p>
</blockquote>
<h3 id="数据元素数据项">数据元素、数据项</h3>
<blockquote>
<p><strong>数据元素</strong>是数据的基本单位，通常作为一个整体进行考虑和处理。<br>
一个<strong>数据元素</strong>可由若干个<strong>数据项</strong>组成，数据项是构成数据元素的不可分割的最小单位。</p>
</blockquote>
<h3 id="数据结构数据对象">数据结构、数据对象</h3>
<blockquote>
<p><strong>结构</strong> 是各个元素之间的关系<br>
<strong>数据结构</strong> 是相互之间存在一种或者多种特定关系的数据元素的集合。<br>
<strong>数据对象</strong> 是具有相同性质的数据元素的集合，是数据的一个子集。</p>
</blockquote>
<h3 id="数据结构的三要素">数据结构的三要素</h3>
<ul>
<li>
<p>逻辑结构</p>
<ul>
<li>集合
<ul>
<li>各个元素同属一个集合，别无其他关系</li>
</ul>
</li>
<li>线性结构
<ul>
<li>数据元素之间是一对一的关系，除了第一个元素，所有元素都有唯一前驱，除了最后一个元素，所有元素都有唯一后继</li>
</ul>
</li>
<li>树形结构
<ul>
<li>数据元素之间是一对多的关系</li>
</ul>
</li>
<li>图状结构（网状结构）
<ul>
<li>数据元素之间是多对多的关系</li>
</ul>
</li>
</ul>
</li>
<li>
<p>物理结构（存储结构）</p>
<ul>
<li>顺序存储
<ul>
<li>存储位置相邻</li>
</ul>
</li>
<li>链式存储
<ul>
<li>借助元素存储地址的指针来辨识元素之间的逻辑关系</li>
</ul>
</li>
<li>索引存储
<ul>
<li>索引表，索引表中的每项称为索引项(关键字，地址)</li>
</ul>
</li>
<li>散列存储
<ul>
<li>通过元素的关键字直接计算出该元素的存储地址，又称哈希（Hash）存储</li>
</ul>
</li>
</ul>
</li>
<li>
<p>数据的运算</p>
<ul>
<li>运算的实现是针对存储结构的</li>
</ul>
</li>
<li>
<p>若采用顺序存储，则各个数据元素在物理上必须是连续的；若采用非顺序存储，则各个数据元素在物理上可以是离散的。</p>
</li>
<li>
<p>数据的存储结构会影响存储空间分配的方便程度</p>
</li>
</ul>
<p>数据类型、抽象数据类型：</p>
<blockquote>
<p><strong>数据类型</strong> 是一个值的集合和定义在此集合上的一组操作的总称。</p>
<ul>
<li>原子类型。其值不可再分的数据类型。</li>
<li>结构类型。其值可以再分解为若干成分的数据类型。</li>
</ul>
<p><strong>抽象数据类型</strong>(Abstract Data Type, ADT) 是抽象数据组织与之相关的操作。</p>
</blockquote>
<h2 id="算法">算法</h2>
<p>算法的特性：</p>
<ul>
<li>有穷性
<ul>
<li>必须在执行有穷步之后结束，且每一步都可以在有穷时间内完成。</li>
<li>算法必须是有穷的，而程序可以是无穷的</li>
</ul>
</li>
<li>确定性
<ul>
<li>相同的输入只能得到相同的输出</li>
</ul>
</li>
<li>可行性
<ul>
<li>算法中描述的操作都可以通过已经实现的基本运算执行有限次来实现</li>
</ul>
</li>
<li>输入
<ul>
<li>一个算法有零个或者多个输入，这些输入取自于某个特定的对象的集合。</li>
</ul>
</li>
<li>输出
<ul>
<li>一个算个有一个或者多个输出，这些输出是与输入有着某种特定关系的量。</li>
</ul>
</li>
</ul>
<p>“好”的算法的特性：</p>
<ul>
<li>正确性
<ul>
<li>算法应能够正确地解决求解问题。</li>
</ul>
</li>
<li>可读性
<ul>
<li>算法应具有良好的可读性，以帮助人们理解（无歧义）</li>
</ul>
</li>
<li>健壮性
<ul>
<li>输入非法数据时，算法能适当地做出反应或进行处理，而不会产生莫名其妙的输出结果。</li>
</ul>
</li>
<li>高效率与低存储量需求
<ul>
<li>时、空间复杂度低</li>
</ul>
</li>
</ul>
<h2 id="时间复杂度">时间复杂度</h2>
<p>无法运行结束统计运行时间来判断算法的时间开销，比如：导弹发射之类的。并且在结束之前你不知道他还要运行多久，因此希望算法复杂度能够在运行前计算出来</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">print_point</span>(<span style="color:#66d9ef">int</span> n){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(i<span style="color:#f92672">&lt;=</span>n){
</span></span><span style="display:flex;"><span>        i<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>cout<span style="color:#f92672">&lt;&lt;</span> i <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>T(3000)=1+3001+3000*2=9000+2(3001 为比较的次数)<br>
T(n)=3n+2<br>
当 n 充分大时，我们只保留阶数最高的，且系数忽略，既<br>
T(n)=O(n)，例如上面的程序 T(n)=O(n)<br>
加法规则：<br>
$T(n)=T_1(n)+T_2(n)=O(f(n))+O(g(n))=O(\max(f(n), g(n)))$<br>
乘法规则：<br>
$T(n)=T_1(n)\times T_2(n)=O(f(n))\times O(g(n))=O(f(n)\times g(n))$</p>
<p>e.g. $T_3(n)=n^3+n^2\log_2n=O(n^3)+O(n^2\log_2n)=O(n^3)$</p>
<p>数量级比较:<br>
$O(1)&lt;O(\log_2n)&lt;O(n)&lt;O(n^k)&lt;O(2^n)&lt;O(n!)&lt;O(n^n)$<br>
其中 $k$ 为大于1的整数.</p>
<ul>
<li>顺序执行的代码只会影响常数项，可以忽略</li>
<li>只需挑循环中的一个基本操作分析他的执行次数与 $n$ 的关系即可</li>
<li>如果有多层嵌套循环，只需关注最深层循环循环了几次</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">print_point</span>(<span style="color:#66d9ef">int</span> n){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(i<span style="color:#f92672">&lt;=</span>n){
</span></span><span style="display:flex;"><span>        i<span style="color:#f92672">=</span>i<span style="color:#f92672">*</span><span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>cout<span style="color:#f92672">&lt;&lt;</span> i <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>设最深层循环的语句执行 x 次，则由循环条件可知，循环结束时是满足 $2^x&gt;n$ 的最小正整数 x，其中 $x=\lfloor\log_2n\rfloor+1$，因此  $T(n)=O(x)=O(\log_2n)$</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> flag[n];<span style="color:#75715e">//数组中乱序存放了1-n的正整数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">find_elem</span>(<span style="color:#66d9ef">int</span> flag[], <span style="color:#66d9ef">int</span> n){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; i<span style="color:#f92672">&lt;</span>n; i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(flag[i]<span style="color:#f92672">==</span>n){
</span></span><span style="display:flex;"><span>            std<span style="color:#f92672">::</span>cout<span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;找到元素了&#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>最好情况：元素 n 在第一个位置<br>
最坏情况：元素 n 在最后一个位置<br>
平均情况：假设元素 n 在任意一个位置的概率相同为 $\dfrac{1}{n}$.<br>
平均情况循环的次数 $x=(1+2+\cdots+n)\dfrac{1}{n}=\dfrac{1+n}{2}$<br>
因此，最好时间复杂度 T(n)=O(1)<br>
最坏时间复杂度 T(n)=O(n)<br>
平均时间复杂度 T(n)=O(n)<br>
一般不考虑最好时间复杂度.</p>
<h2 id="空间复杂度">空间复杂度</h2>
<p>程序运行时需要的内存空间：</p>
<ul>
<li>程序代码(与问题规模无关)</li>
<li>局部变量、参数</li>
</ul>
<p>之前的算法，需要的空间与问题规模无关，因此空间复杂度为 O(1)，下面看看与空间复杂度相关的算法</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test</span>(<span style="color:#66d9ef">int</span> n){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> flag[n];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> i;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// ....
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>上面这个代码的空间复杂度 S(n)=O(n)</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test</span>(<span style="color:#66d9ef">int</span> n){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> flag[n][n];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> other[n];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> i;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>空间复杂度 $S(n)=O(n^2)+O(n)+O(1)=O(n^2)$<br>
同样满足加法规则</p>
<p><strong>函数调用同样会带来内存开销</strong>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test</span>(<span style="color:#66d9ef">int</span> n){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> a,b,c;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(n<span style="color:#f92672">&gt;</span><span style="color:#ae81ff">1</span>){
</span></span><span style="display:flex;"><span>        test(n<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> n <span style="color:#f92672">&lt;&lt;</span>std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>递归调用带来内存开销<br>
注：与函数调用栈相关。<br>
这个空间复杂为 S(n)=O(n)</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test</span>(<span style="color:#66d9ef">int</span> n){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> flag[n];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(n<span style="color:#f92672">&gt;</span><span style="color:#ae81ff">1</span>){
</span></span><span style="display:flex;"><span>        test(n<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> n <span style="color:#f92672">&lt;&lt;</span>std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>这个空间复杂度为 $1+2+\cdots+n=\dfrac{n(n+1)}{2}$<br>
$S(n)=O(n^2)$</p>
<hr>
<p>时间、空间复杂度主要考虑与问题规模相关的部分.</p>

    </div>
    <div class="post-footer">
      
    </div>
  </article>

    </main>
  </body>
</html>
