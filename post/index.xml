<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on 洛七的摸鱼池塘</title>
    <link>https://Lu0key.github.io/post/</link>
    <description>Recent content in Posts on 洛七的摸鱼池塘</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 04 Mar 2024 17:16:58 +0800</lastBuildDate><atom:link href="https://Lu0key.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Ubuntu 服务器防火墙</title>
      <link>https://Lu0key.github.io/post/ubuntu-firewall/</link>
      <pubDate>Mon, 04 Mar 2024 17:16:58 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/ubuntu-firewall/</guid>
      <description>实验室用的服务器是 firewall, 但是偶尔会有需求需要开放端口, 因此记一下, 避免每次反复查
查询开放的端口
# 查询已开放的端口 sudo firewall-cmd --list-ports # 开放新的端口 sudo firewall-cmd --zone=public --add-port=8080/tcp --permanent # 重新加载防火墙配置 sudo firewall-cmd --reload 一般用这三条就够了.</description>
    </item>
    
    <item>
      <title>Java IO 基础</title>
      <link>https://Lu0key.github.io/post/basic-java-io/</link>
      <pubDate>Sat, 02 Mar 2024 22:07:15 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/basic-java-io/</guid>
      <description>文件 文件就是保存数据的地方。
 流: 数据在数据源(文件)和程序(内存)之间经历的路径 输入流：数据从数据源(文件)到程序(内存)的路径 输出流: 数据从程序(内存)到数据源(文件)的路径  常用的文件操作  new File(String pathname): 根据路径构建一个 File 对象 new File(File parent, String child): 根据父目录文件+子路径构建 new File(String parent, String child): 根据父目录+子路径构建  import org.junit.Test; import java.io.File; import java.io.IOException; // 演示创建文件 public class FileCreate { public static void main(String[] args) { } // 方式1  @Test public void create01() { String filePath = &amp;#34;f:\\news1.txt&amp;#34;; File file = new File(filePath); try { // 执行了这个方法才会在磁盘创建  file.</description>
    </item>
    
    <item>
      <title>Redis 离线安装</title>
      <link>https://Lu0key.github.io/post/redis-offline-installation/</link>
      <pubDate>Fri, 01 Mar 2024 15:53:03 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/redis-offline-installation/</guid>
      <description>下载 需要以下内容
 redis make build-essential pkg-config libdpkg-perl  安装 tar -zxvf redis-7.2.2.tar.gz cd redis-7.2.2 make test &amp;amp;&amp;amp; make # Command &amp;#39;make&amp;#39; not found, but can be installed with: # sudo apt install make # version 4.3-4.1build1, or # sudo apt install make-guile # version 4.3-4.1build1 # 因此需要为离线环境安装 make sudo apt-get download make # 这里能下下来 make 所需的 deb 包, 到时候迁移到离线环境 sudo dpkg -i make_4.3-4.1build1_amd64.deb # 然后再回到 redis 进行测试 sudo make test &amp;amp;&amp;amp; make # /bin/sh: 1: cc: not found # make[1]: *** [Makefile:436: adlist.</description>
    </item>
    
    <item>
      <title>Leetcode 2583 二叉树中的第 K 大层和</title>
      <link>https://Lu0key.github.io/post/lc-2583-kth-largest-sum-in-a-binary-tree/</link>
      <pubDate>Wed, 28 Feb 2024 22:46:15 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/lc-2583-kth-largest-sum-in-a-binary-tree/</guid>
      <description>2583.二叉树中的第 K 大层和 给你一棵二叉树的根节点 root 和一个正整数 k 。
树中的 层和 是指 同一层 上节点值的总和。
返回树中第 k 大的层和（不一定不同）。如果树少于 k 层，则返回 -1 。
注意，如果两个节点与根节点的距离相同，则认为它们在同一层。
示例 1:
输入: root = [5,8,9,2,1,3,7,4,6], k = 2
输出: 13
解释: 树中每一层的层和分别是：
 Level 1: 5 Level 2: 8 + 9 = 17 Level 3: 2 + 1 + 3 + 7 = 13 Level 4: 4 + 6 = 10 第 2 大的层和等于 13 。  示例 2:</description>
    </item>
    
    <item>
      <title>Leetcode 889 根据前序和后序遍历构造二叉树</title>
      <link>https://Lu0key.github.io/post/lc-889-construct-binary-tree-from-preorder-and-postorder-traversal/</link>
      <pubDate>Wed, 28 Feb 2024 22:43:59 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/lc-889-construct-binary-tree-from-preorder-and-postorder-traversal/</guid>
      <description>889. 根据前序和后序遍历构造二叉树 给定两个整数数组, preorder 和 postorder ，其中 preorder 是一个具有 无重复 值的二叉树的前序遍历，postorder 是同一棵树的后序遍历，重构并返回二叉树。
如果存在多个答案，您可以返回其中 任何 一个。
示例 1:
输入: preorder = [1,2,4,5,3,6,7], postorder = [4,5,2,6,7,3,1]
输出: [1,2,3,4,5,6,7]
示例 2:
输入: preorder = [1], postorder = [1]
输出: [1]
提示：
 1 &amp;lt;= preorder.length &amp;lt;= 30 1 &amp;lt;= preorder[i] &amp;lt;= preorder.length preorder 中所有值都 不同 postorder.length == preorder.length 1 &amp;lt;= postorder[i] &amp;lt;= postorder.length postorder 中所有值都 不同 保证 preorder 和 postorder 是同一棵二叉树的前序遍历和后序遍历  Related Topics</description>
    </item>
    
    <item>
      <title>Leetcode 106 从中序与后序遍历序列构造二叉树</title>
      <link>https://Lu0key.github.io/post/lc-106-construct-binary-tree-from-inorder-and-postorder-traversal/</link>
      <pubDate>Wed, 28 Feb 2024 22:42:06 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/lc-106-construct-binary-tree-from-inorder-and-postorder-traversal/</guid>
      <description>106.从中序与后序遍历序列构造二叉树 给定两个整数数组 inorder 和 postorder ，其中 inorder 是二叉树的中序遍历， postorder 是同一棵树的后序遍历，请你构造并返回这颗 二叉树 。
示例 1:
输入: inorder = [9,3,15,20,7], postorder = [9,15,7,20,3]
输出: [3,9,20,null,null,15,7]
示例 2:
输入: inorder = [-1], postorder = [-1]
输出: [-1]
提示：
 1 &amp;lt;= inorder.length &amp;lt;= 3000 postorder.length == inorder.length -3000 &amp;lt;= inorder[i], postorder[i] &amp;lt;= 3000 inorder 和 postorder 都由 不同 的值组成 postorder 中每一个值都在 inorder 中 inorder 保证是树的中序遍历 postorder 保证是树的后序遍历  Related Topics
 树 数组 哈希表 分治 二叉树  题目链接: link</description>
    </item>
    
    <item>
      <title>Leetcode 105 从前序与中序遍历序列构造二叉树</title>
      <link>https://Lu0key.github.io/post/lc-105-construct-binary-tree-from-preorder-and-inorder-traversal/</link>
      <pubDate>Wed, 28 Feb 2024 22:40:00 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/lc-105-construct-binary-tree-from-preorder-and-inorder-traversal/</guid>
      <description>105.从前序与中序遍历序列构造二叉树 给定两个整数数组 preorder 和 inorder ，其中 preorder 是二叉树的先序遍历， inorder 是同一棵树的 中序遍历，请构造二叉树并返回其根节点。
示例 1:
输入: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]
输出: [3,9,20,null,null,15,7]
示例 2:
输入: preorder = [-1], inorder = [-1]
输出: [-1]
提示：
 1 &amp;lt;= preorder.length &amp;lt;= 3000 inorder.length == preorder.length -3000 &amp;lt;= preorder[i], inorder[i] &amp;lt;= 3000 preorder 和 inorder 均 无重复 元素 inorder 均出现在 preorder preorder 保证 为二叉树的前序遍历序列 inorder 保证 为二叉树的中序遍历序列  Related Topics
 树 数组 哈希表 分治 二叉树  题目链接: link</description>
    </item>
    
    <item>
      <title>Leetcode 590 N 叉树的后序遍历</title>
      <link>https://Lu0key.github.io/post/lc-590-n-ary-tree-postorder-traversal/</link>
      <pubDate>Wed, 28 Feb 2024 22:37:43 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/lc-590-n-ary-tree-postorder-traversal/</guid>
      <description>589.N 叉树的后序遍历 给定一个 n 叉树的根节点 root ，返回 其节点值的 后序遍历 。
n 叉树 在输入中按层序遍历进行序列化表示，每组子节点由空值 null 分隔（请参见示例）。
示例 1:
输入: root = [1,null,3,2,4,null,5,6]
输出: [5,6,3,2,4,1]
示例 2:
输入: root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]
输出: [2,6,14,11,7,3,12,8,4,13,9,10,5,1]
提示：
 节点总数在范围 [0, 10^4] 内 0 &amp;lt;= Node.val &amp;lt;= 10^4 n 叉树的高度小于或等于 1000  Related Topics
 栈 树 深度优先搜索  题目链接: link
解答 本题的难度是 Easy.
也是后序遍历的定义.
代码如下:
class Solution { private List&amp;lt;Integer&amp;gt; result = new ArrayList&amp;lt;&amp;gt;(); public List&amp;lt;Integer&amp;gt; postorder(Node root) { dfs(root); return result; } private void dfs(Node node){ if (node == null) {return;} for (Node child:node.</description>
    </item>
    
    <item>
      <title>Leetcode 589 N 叉树的前序遍历</title>
      <link>https://Lu0key.github.io/post/lc-589-n-ary-tree-preorder-traversal/</link>
      <pubDate>Wed, 28 Feb 2024 22:33:50 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/lc-589-n-ary-tree-preorder-traversal/</guid>
      <description>589.N 叉树的前序遍历 给定一个 n 叉树的根节点 root ，返回 其节点值的 前序遍历 。
n 叉树 在输入中按层序遍历进行序列化表示，每组子节点由空值 null 分隔（请参见示例）。
示例 1:
输入: root = [1,null,3,2,4,null,5,6]
输出: [1,3,5,6,2,4]
示例 2:
输入: root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]
输出: [1,2,3,6,7,11,14,4,8,12,5,9,13,10]
提示：
 节点总数在范围 [0, 10^4] 内 0 &amp;lt;= Node.val &amp;lt;= 10^4 n 叉树的高度小于或等于 1000  Related Topics
 栈 树 深度优先搜索  题目链接: link
解答 本题的难度是 Easy.
也是前序遍历的定义.
代码如下:
class Solution { private List&amp;lt;Integer&amp;gt; result = new ArrayList&amp;lt;&amp;gt;(); public List&amp;lt;Integer&amp;gt; preorder(Node root) { dfs(root); return result; } private void dfs(Node node){ if (node == null) {return;} result.</description>
    </item>
    
    <item>
      <title>Leetcode 429 N 叉树的层序遍历</title>
      <link>https://Lu0key.github.io/post/lc-429-n-ary-tree-level-order-traversal/</link>
      <pubDate>Wed, 28 Feb 2024 22:25:43 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/lc-429-n-ary-tree-level-order-traversal/</guid>
      <description>429.N 叉树的层序遍历 给定一个 N 叉树，返回其节点值的层序遍历。（即从左到右，逐层遍历）。
树的序列化输入是用层序遍历，每组子节点都由 null 值分隔（参见示例）。
示例 1:
输入: root = [1,null,3,2,4,null,5,6]
输出: [[1],[3,2,4],[5,6]]
示例 2:
输入: root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]
输出: [[1],[2,3,4,5],[6,7,8,9,10],[11,12,13],[14]]
提示：
 树的高度不会超过 1000 树的节点总数在 [0, 10^4] 之间  Related Topics
 树 广度优先搜索  题目链接: link
解答 本题的难度是 Medium.
这题和层序遍历二叉树本质上是一样的, 只不过是多了一个子节点的遍历, 怎么这几天都是层序遍历.
代码如下:
class Solution { private List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; result = new ArrayList&amp;lt;&amp;gt;(); public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; levelOrder(Node root) { subLevelOrder(root, 0); return result; } private void subLevelOrder(Node node, int depth){ if(node == null) {return;} if(result.</description>
    </item>
    
    <item>
      <title>Leetcode 103 二叉树的锯齿形层序遍历</title>
      <link>https://Lu0key.github.io/post/lc-103-binary-tree-zigzag-level-order-traversal/</link>
      <pubDate>Wed, 28 Feb 2024 22:23:36 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/lc-103-binary-tree-zigzag-level-order-traversal/</guid>
      <description>103.二叉树的锯齿形层序遍历 给你二叉树的根节点 root ，返回其节点值的 锯齿形层序遍历 。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）
示例 1:
输入: root = [3,9,20,null,null,15,7]
输出: [[15,7],[9,20],[3]]
示例 2:
输入: root = [1]
输出: [[1]]
示例 3:
输入: root = []
输出: []
提示：
 树中节点数目在范围 [0, 2000] 内 100 &amp;lt;= Node.val &amp;lt;= 100  Related Topics
 树 广度优先搜索 二叉树  题目链接: link
解答 本题的难度是 Medium.
也是写了很抽象的代码, 都不知道自己脑子那几天在想什么? 太怪了.
代码如下:
class Solution { private HashMap&amp;lt;Integer, ArrayList&amp;lt;Integer&amp;gt;&amp;gt; hashMap = new HashMap&amp;lt;&amp;gt;(); private int maxDepth = -1; public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; zigzagLevelOrder(TreeNode root) { List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; result = new ArrayList&amp;lt;&amp;gt;(); levelOrder(root, 0); for (int i = 0; i &amp;lt;= maxDepth; i++) { ArrayList&amp;lt;Integer&amp;gt; list = hashMap.</description>
    </item>
    
    <item>
      <title>Leetcode 107 二叉树的层序遍历II</title>
      <link>https://Lu0key.github.io/post/lc-107-binary-tree-level-order-traversal-ii/</link>
      <pubDate>Wed, 28 Feb 2024 22:21:40 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/lc-107-binary-tree-level-order-traversal-ii/</guid>
      <description>107.二叉树的层序遍历II 给你二叉树的根节点 root ，返回其节点值 自底向上的层序遍历 。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）
示例 1:
输入: root = [3,9,20,null,null,15,7]
输出: [[15,7],[9,20],[3]]
示例 2:
输入: root = [1]
输出: [[1]]
示例 3:
输入: root = []
输出: []
提示：
 树中节点数目在范围 [0, 2000] 内 1000 &amp;lt;= Node.val &amp;lt;= 1000  Related Topics
 树 广度优先搜索 二叉树  题目链接: link
解答 本题的难度是 Medium.
一开始写的很抽象, 先创建一个 HashMap, 然后记录最大深度, 然后再倒序插入到 result 里.
代码如下:
class Solution { private int maxDepth = -1; HashMap&amp;lt;Integer, ArrayList&amp;lt;Integer&amp;gt;&amp;gt; hashMap = new HashMap(); public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; levelOrderBottom(TreeNode root) { levelOrder(root, 0); List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; result = new ArrayList&amp;lt;&amp;gt;(); for (int i = maxDepth; i &amp;gt;= 0 ; i--) { result.</description>
    </item>
    
    <item>
      <title>Leetcode 102 二叉树的层序遍历</title>
      <link>https://Lu0key.github.io/post/lc-102-binary-tree-level-order-traversal/</link>
      <pubDate>Wed, 28 Feb 2024 22:18:42 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/lc-102-binary-tree-level-order-traversal/</guid>
      <description>102.二叉树的层序遍历 给你二叉树的根节点 root ，返回其节点值的 层序遍历 。 （即逐层地，从左到右访问所有节点）。
示例 1:
输入: root = [3,9,20,null,null,15,7]
输出: [[3],[9,20],[15,7]]
示例 2:
输入: root = [1]
输出: [[1]]
示例 3:
输入: root = []
输出: []
提示：
 树中节点数目在范围 [0, 2000] 内 -1000 &amp;lt;= Node.val &amp;lt;= 1000  Related Topics
 树 广度优先搜索 二叉树  题目链接: link
解答 本题的难度是 Medium.
之前做 Hot100 的时候做过了, 直接复制之前的代码 E:), 感觉妙妙妙, 因为这样很自然地就是层序遍历了.
代码如下:
class Solution { List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; lists = new ArrayList&amp;lt;&amp;gt;(); public List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; levelOrder(TreeNode root) { ceng(0, root); return lists; } private void ceng(int cengIndex, TreeNode node){ if(node == null ){return ;} if(lists.</description>
    </item>
    
    <item>
      <title>Leetcode 987 二叉树的垂序遍历</title>
      <link>https://Lu0key.github.io/post/lc-987-vertical-order-traversal-of-a-binary-tree/</link>
      <pubDate>Wed, 28 Feb 2024 22:16:13 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/lc-987-vertical-order-traversal-of-a-binary-tree/</guid>
      <description>987.二叉树的垂序遍历 给你二叉树的根结点 root ，请你设计算法计算二叉树的 垂序遍历 序列。
对位于 (row, col) 的每个结点而言，其左右子结点分别位于 (row + 1, col - 1) 和 (row + 1, col + 1) 。树的根结点位于 (0, 0) 。
二叉树的 垂序遍历 从最左边的列开始直到最右边的列结束，按列索引每一列上的所有结点，形成一个按出现位置从上到下排序的有序列表。如果同行同列上有多个结点，则按结点的值从小到大进行排序。
返回二叉树的 垂序遍历 序列。
示例 1:
输入: root = [3,9,20,null,null,15,7]
输出: [[9],[3,15],[20],[7]]
解释:
列 -1 ：只有结点 9 在此列中。
列 0 ：只有结点 3 和 15 在此列中，按从上到下顺序。
列 1 ：只有结点 20 在此列中。
列 2 ：只有结点 7 在此列中。
示例 2:
输入: root = [1,2,3,4,5,6,7]</description>
    </item>
    
    <item>
      <title>Leetcode 145 二叉树的后序遍历</title>
      <link>https://Lu0key.github.io/post/lc-145-binary-tree-postorder-traversal/</link>
      <pubDate>Wed, 28 Feb 2024 22:14:20 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/lc-145-binary-tree-postorder-traversal/</guid>
      <description>145.二叉树的后序遍历 给你一棵二叉树的根节点 root ，返回其节点值的 后序遍历 。
示例 1:
输入: root = [1,null,2,3]
输出: [3,2,1]
示例 2:
输入: root = []
输出: []
示例 3:
输入: root = [1]
输出: [1]
提示：
 树中节点的数目在范围 [0, 100] 内 100 &amp;lt;= Node.val &amp;lt;= 100  进阶：递归算法很简单，你可以通过迭代算法完成吗？
Related Topics
 栈 树 深度优先搜索 二叉树  题目链接: link
解答 本题的难度是 Easy.
最近感觉是捅了树窝了, 这题和前两天的题目一样, 都只是定义.
代码如下:
class Solution { public List&amp;lt;Integer&amp;gt; postorderTraversal(TreeNode root) { List&amp;lt;Integer&amp;gt; result = new ArrayList&amp;lt;&amp;gt;(); middleOrder(result, root); return result; } private void middleOrder(List&amp;lt;Integer&amp;gt; result, TreeNode node){ if(node == null){return;} if(node.</description>
    </item>
    
    <item>
      <title>Leetcode 144 二叉树的前序遍历</title>
      <link>https://Lu0key.github.io/post/lc-144-binary-tree-inorder-traversal/</link>
      <pubDate>Wed, 28 Feb 2024 22:11:49 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/lc-144-binary-tree-inorder-traversal/</guid>
      <description>144. 二叉树的前序遍历 给你二叉树的根节点 root ，返回它节点值的 前序 遍历。
示例 1:
输入: root = [1,null,2,3]
输出: [1,2,3]
示例 2:
输入: root = []
输出: []
示例 3:
输入: root = [1]
输出: [1]
还有两个示例就不放了&amp;hellip; 没啥意义
提示：
 树中节点数目在范围 [0, 100] 内 -100 &amp;lt;= Node.val &amp;lt;= 100  Related Topics
 栈 树 深度优先搜索 二叉树  题目链接: link
解答 本题的难度是 Easy.
和之前那题一样, 也没啥好说的, 纯纯定义.
class Solution { private List&amp;lt;Integer&amp;gt; list = new ArrayList&amp;lt;&amp;gt;(); public List&amp;lt;Integer&amp;gt; preorderTraversal(TreeNode root) { preorder(root); return list; } private void preorder(TreeNode node) { if(node==null){return;} list.</description>
    </item>
    
    <item>
      <title>Leetcode 94 二叉树的中序遍历</title>
      <link>https://Lu0key.github.io/post/lc-94-binary-tree-inorder-traversal/</link>
      <pubDate>Wed, 28 Feb 2024 22:10:10 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/lc-94-binary-tree-inorder-traversal/</guid>
      <description>94. 二叉树的中序遍历 给定一个二叉树的根节点 root ，返回 它的 中序 遍历 。
示例 1:
输入: root = [1,null,2,3]
输出: [1,3,2]
示例 2:
输入: root = []
输出: []
示例 3:
输入: root = [1]
输出: [1]
提示：
 树中节点数目在范围 [0, 100] 内 -100 &amp;lt;= Node.val &amp;lt;= 100  Related Topics
 栈 树 深度优先搜索 二叉树  题目链接: link
解答 本题的难度是 Easy.
这题太基础了, 甚至一时间都不知道该怎么讲, 属于树的入门题了, 纯纯定义.
class Solution { public List&amp;lt;Integer&amp;gt; inorderTraversal(TreeNode root) { List&amp;lt;Integer&amp;gt; result = new ArrayList&amp;lt;&amp;gt;(); middleOrder(result, root); return result; } private void middleOrder(List&amp;lt;Integer&amp;gt; result, TreeNode node){ if(node == null){return;} if(node.</description>
    </item>
    
    <item>
      <title>Leetcode 236 二叉树的最近公共祖先</title>
      <link>https://Lu0key.github.io/post/lc-236-lowest-common-ancestor-of-a-binary-tree/</link>
      <pubDate>Wed, 28 Feb 2024 22:07:21 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/lc-236-lowest-common-ancestor-of-a-binary-tree/</guid>
      <description>236. 二叉树的最近公共祖先 给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。
百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”
示例 1:
输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
输出: 3
解释: 节点 5 和节点 1 的最近公共祖先是节点 3 。
示例 2:
输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
输出: 5
解释: 节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。
示例 3:
输入: root = [1,2], p = 1, q = 2</description>
    </item>
    
    <item>
      <title>Leetcode 993 二叉树的堂兄弟节点</title>
      <link>https://Lu0key.github.io/post/lc-993-cousins-in-binary-tree/</link>
      <pubDate>Wed, 28 Feb 2024 22:04:55 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/lc-993-cousins-in-binary-tree/</guid>
      <description>993.二叉树的堂兄弟节点 在二叉树中, 根节点位于深度 0 处，每个深度为 k 的节点的子节点位于深度 k+1 处。
如果二叉树的两个节点深度相同，但 父节点不同 ，则它们是一对堂兄弟节点。
我们给出了具有唯一值的二叉树的根节点 root ，以及树中两个不同节点的值 x 和 y 。
只有与值 x 和 y 对应的节点是堂兄弟节点时，才返回 true 。否则，返回 false。
示例 1:
输入: root = [1,2,3,4], x = 4, y = 3
输出: false
示例 2:
输入: root = [1,2,3,null,4,null,5], x = 5, y = 4
输出: true
示例 3:
输入: root = [1,2,3,null,4], x = 2, y = 3
输出: false
提示：</description>
    </item>
    
    <item>
      <title>Leetcode 2641 二叉树的堂兄弟节点 II</title>
      <link>https://Lu0key.github.io/post/lc-2641-cousins-in-binary-tree-ii/</link>
      <pubDate>Wed, 28 Feb 2024 22:02:26 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/lc-2641-cousins-in-binary-tree-ii/</guid>
      <description>2641.二叉树的堂兄弟节点 II 给你一棵二叉树的根 root ，请你将每个节点的值替换成该节点的所有 堂兄弟节点值的和 。
如果两个节点在树中有相同的深度且它们的父节点不同，那么它们互为 堂兄弟 。
请你返回修改值之后，树的根 root 。
注意，一个节点的深度指的是从树根节点到这个节点经过的边数。
示例 1:
输入: root = [5,4,9,1,10,null,7]
输出: [0,0,0,7,7,null,11]
解释: 上图展示了初始的二叉树和修改每个节点的值之后的二叉树。
 值为 5 的节点没有堂兄弟，所以值修改为 0 。 值为 4 的节点没有堂兄弟，所以值修改为 0 。 值为 9 的节点没有堂兄弟，所以值修改为 0 。 值为 1 的节点有一个堂兄弟，值为 7 ，所以值修改为 7 。 值为 10 的节点有一个堂兄弟，值为 7 ，所以值修改为 7 。 值为 7 的节点有两个堂兄弟，值分别为 1 和 10 ，所以值修改为 11 。  示例 2:
输入: root = [3,1,2]</description>
    </item>
    
    <item>
      <title>Leetcode LCP30 魔塔游戏</title>
      <link>https://Lu0key.github.io/post/lc-lcp30-%E9%AD%94%E5%A1%94%E6%B8%B8%E6%88%8F/</link>
      <pubDate>Wed, 28 Feb 2024 21:57:09 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/lc-lcp30-%E9%AD%94%E5%A1%94%E6%B8%B8%E6%88%8F/</guid>
      <description>LCP30.魔塔游戏 小扣当前位于魔塔游戏第一层，共有 N 个房间，编号为 0 ~ N-1。每个房间的补血道具/怪物对于血量影响记于数组 nums，其中正数表示道具补血数值，即血量增加对应数值；负数表示怪物造成伤害值，即血量减少对应数值；0 表示房间对血量无影响。
小扣初始血量为 1，且无上限。假定小扣原计划按房间编号升序访问所有房间补血/打怪，为保证血量始终为正值，小扣需对房间访问顺序进行调整，每次仅能将一个怪物房间（负数的房间）调整至访问顺序末尾。请返回小扣最少需要调整几次，才能顺利访问所有房间。若调整顺序也无法访问完全部房间，请返回 -1。
示例 1:
输入: nums = [100,100,100,-250,-60,-140,-50,-50,100,150]
输出: 1
解释: 初始血量为 1。至少需要将 nums[3] 调整至访问顺序末尾以满足要求.
示例 2:
输入: nums = [-200,-300,400,0]
输出: -1
解释: 调整访问顺序也无法完成全部房间的访问。
提示：
 1 &amp;lt;= nums.length &amp;lt;= 10^5 -10^5 &amp;lt;= nums[i] &amp;lt;= 10^5  Related Topics
 贪心 数组 堆(优先队列)  题目链接: link
解答 本题的难度是 Medium.
这里的话我们可以考虑贪心算法, 从左到右遍历, 如果当前的血量小于 0 我们才考虑调整. 那这边我们当然是希望如果能够调整当然是能调整次数越少越好, 因此肯定选择把前面扣血最多的负数移到最后面, 因此其实我们相当于是需要维护一个最小堆, 因为只有负值才会放到堆里. 这样我们就可以每次取出堆顶的元素, 然后把血量加上这个值, 然后再把这个值放到最后面.</description>
    </item>
    
    <item>
      <title>Leetcode 1696 跳跃游戏 VI</title>
      <link>https://Lu0key.github.io/post/lc-1696-jump-game-vi/</link>
      <pubDate>Wed, 28 Feb 2024 21:54:36 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/lc-1696-jump-game-vi/</guid>
      <description>1696.跳跃游戏 VI 给你一个下标从 0 开始的整数数组 nums 和一个整数 k 。
一开始你在下标 0 处。每一步，你最多可以往前跳 k 步，但你不能跳出数组的边界。也就是说，你可以从下标 i 跳到 [i + 1， min(n - 1, i + k)] 包含 两个端点的任意位置。
你的目标是到达数组最后一个位置（下标为 n - 1 ），你的 得分 为经过的所有数字之和。
请你返回你能得到的 最大得分 。
示例 1:
输入: nums = [**1**,**-1**,-2,**4**,-7,**3**], k = 2
输出: 7
解释: 你可以选择子序列 [1,-1,4,3] （上面加粗的数字），和为 7 。
示例 2:
输入: nums = [**10**,-5,-2,**4**,0,**3**], k = 3
输出: 17
解释: 你可以选择子序列 [10,4,3] （上面加粗数字），和为 17 。</description>
    </item>
    
    <item>
      <title>Leetcode 292 Nim 游戏</title>
      <link>https://Lu0key.github.io/post/lc-292-nim-game/</link>
      <pubDate>Wed, 28 Feb 2024 21:50:49 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/lc-292-nim-game/</guid>
      <description>292.Nim 游戏 你和你的朋友，两个人一起玩 Nim 游戏：
 桌子上有一堆石头。 你们轮流进行自己的回合， 你作为先手 。 每一回合，轮到的人拿掉 1 - 3 块石头。 拿掉最后一块石头的人就是获胜者。 假设你们每一步都是最优解。请编写一个函数，来判断你是否可以在给定石头数量为 n 的情况下赢得游戏。如果可以赢，返回 true；否则，返回 false 。  示例 1:
输入: n = 4
输出: false
解释: 以下是可能的结果:
 移除1颗石头。你的朋友移走了3块石头，包括最后一块。你的朋友赢了。 移除2个石子。你的朋友移走2块石头，包括最后一块。你的朋友赢了。 3.你移走3颗石子。你的朋友移走了最后一块石头。你的朋友赢了。 在所有结果中，你的朋友是赢家。  示例 2:
输入: n = 1
输出: true
示例 3:
输入: n = 2
输出: true
提示：
 1 &amp;lt;= n &amp;lt;= 2^31 - 1  Related Topics
 脑筋急转弯 数学 博弈  题目链接: link</description>
    </item>
    
    <item>
      <title>Leetcode 2670 找出不同元素数目差数组</title>
      <link>https://Lu0key.github.io/post/lc-2670-find-the-distinct-difference-array/</link>
      <pubDate>Wed, 28 Feb 2024 21:44:34 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/lc-2670-find-the-distinct-difference-array/</guid>
      <description>2670.找出不同元素数目差数组 给你一个下标从 0 开始的数组 nums ，数组长度为 n 。
nums 的 不同元素数目差 数组可以用一个长度为 n 的数组 diff 表示，其中 diff[i] 等于前缀 nums[0, ..., i] 中不同元素的数目 减去 后缀 nums[i + 1, ..., n - 1] 中不同元素的数目。
返回 nums 的 不同元素数目差 数组。
注意 nums[i, ..., j] 表示 nums 的一个从下标 i 开始到下标 j 结束的子数组（包含下标 i 和 j 对应元素）。特别需要说明的是，如果 i &amp;gt; j ，则 nums[i, ..., j] 表示一个空子数组。
示例 1:
输入: nums = [1,2,3,4,5]
输出: [-3,-1,1,3,5]
解释:
对于 i = 0，前缀中有 1 个不同的元素，而在后缀中有 4 个不同的元素。因此，diff[0] = 1 - 4 = -3 。</description>
    </item>
    
    <item>
      <title>Leetcode 365 水壶问题</title>
      <link>https://Lu0key.github.io/post/lc-365-water-and-jug-problem/</link>
      <pubDate>Wed, 28 Feb 2024 21:35:19 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/lc-365-water-and-jug-problem/</guid>
      <description>365.水壶问题 有两个水壶，容量分别为 jug1Capacity 和 jug2Capacity 升。水的供应是无限的。确定是否有可能使用这两个壶准确得到 targetCapacity 升。
如果可以得到 targetCapacity 升水，最后请用以上水壶中的一或两个来盛放取得的 targetCapacity 升水。
你可以：
 装满任意一个水壶 清空任意一个水壶 从一个水壶向另外一个水壶倒水，直到装满或者倒空  示例 1:
输入: jug1Capacity = 3, jug2Capacity = 5, targetCapacity = 4
输出: true
示例 2:
输入: jug1Capacity = 2, jug2Capacity = 6, targetCapacity = 5
输出: false
示例 3:
输入: jug1Capacity = 1, jug2Capacity = 2, targetCapacity = 3
输出: true
提示：
 1 &amp;lt;= jug1Capacity, jug2Capacity, targetCapacity &amp;lt;= 10^6  Related Topics</description>
    </item>
    
    <item>
      <title>Leetcode 2861 最大合金数</title>
      <link>https://Lu0key.github.io/post/lc-2861-maximum-number-of-alloys/</link>
      <pubDate>Wed, 28 Feb 2024 21:29:15 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/lc-2861-maximum-number-of-alloys/</guid>
      <description>2861.最大合金数 假设你是一家合金制造公司的老板，你的公司使用多种金属来制造合金。现在共有 n 种不同类型的金属可以使用，并且你可以使用 k 台机器来制造合金。每台机器都需要特定数量的每种金属来创建合金。
对于第 i 台机器而言，创建合金需要 composition[i][j] 份 j 类型金属。最初，你拥有 stock[i] 份 i 类型金属，而每购入一份 i 类型金属需要花费 cost[i] 的金钱。
给你整数 n、k、budget，下标从 1 开始的二维数组 composition，两个下标从 1 开始的数组 stock 和 cost，请你在预算不超过 budget 金钱的前提下，最大化 公司制造合金的数量。
所有合金都需要由同一台机器制造。
返回公司可以制造的最大合金数。
示例 1:
输入: n = 3, k = 2, budget = 15, composition = [[1,1,1],[1,1,10]], stock = [0,0,0], cost = [1,2,3]
输出: 2
解释: 优的方法是使用第 1 台机器来制造合金。
要想制造 2 份合金，我们需要购买：
 2 份第 1 类金属。 2 份第 2 类金属。 2 份第 3 类金属。  总共需要 2 * 1 + 2 * 2 + 2 * 3 = 12 的金钱，小于等于预算 15 。</description>
    </item>
    
    <item>
      <title>Leetcode 2859 计算 K 置位下标对应元素的和</title>
      <link>https://Lu0key.github.io/post/lc-2859-sum-of-values-at-indices-with-k-set-bits/</link>
      <pubDate>Wed, 28 Feb 2024 21:15:49 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/lc-2859-sum-of-values-at-indices-with-k-set-bits/</guid>
      <description>2859.计算 K 置位下标对应元素的和 你一个下标从 0 开始的整数数组 nums 和一个整数 k 。
请你用整数形式返回 nums 中的特定元素之 和 ，这些特定元素满足：其对应下标的二进制表示中恰存在 k 个置位。
整数的二进制表示中的 1 就是这个整数的 置位 。
例如，21 的二进制表示为 10101 ，其中有 3 个置位。
示例 1:
输入: nums = [5,10,1,5,2], k = 1
输出: 13
解释: 下标的二进制表示是：
0 = 00021 = 00122 = 01023 = 01124 = 1002下标 1、2 和 4 在其二进制表示中都存在 k = 1 个置位。
因此，答案为 nums[1] + nums[2] + nums[4] = 13 。
示例 2:</description>
    </item>
    
    <item>
      <title>检测服务器状态</title>
      <link>https://Lu0key.github.io/post/detect-server-status/</link>
      <pubDate>Wed, 28 Feb 2024 17:14:54 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/detect-server-status/</guid>
      <description>检测服务器状态脚本
主打一个抽象, 代码如下:
from flask import Flask, request, redirect, url_for, session, render_template import psutil import subprocess app = Flask(__name__) app.secret_key = &amp;#39;keyyyyy&amp;#39; # 设置一个随机的密钥来加密 session 数据 def get_cpu_usage(): # 显示cpu型号 return &amp;#39;{}%&amp;#39;.format(psutil.cpu_percent(interval=1)) def bytes_to_gb(bytes): return bytes / (1024 ** 3) def get_mem_usage(): return &amp;#39;{:.2f}/{} GB({}%)&amp;#39;.format(bytes_to_gb(psutil.virtual_memory().used), int(bytes_to_gb(psutil.virtual_memory().total)), psutil.virtual_memory().percent) def get_gpu_info(): try: result = subprocess.run([&amp;#39;nvidia-smi&amp;#39;, &amp;#39;--query-gpu=index,name,memory.total,memory.used,memory.free,utilization.gpu,utilization.memory&amp;#39;, &amp;#39;--format=csv,noheader,nounits&amp;#39;], capture_output=True, text=True).stdout.strip() except Exception as e: if &amp;#34;No such file or directory: &amp;#39;nvidia-smi&amp;#39;&amp;#34; in str(e): return {&amp;#39;id&amp;#39;:[&amp;#39;无显卡&amp;#39;], &amp;#39;gpu_mem_usage&amp;#39;: [], &amp;#39;gpu_utilization&amp;#39;: []} else: print(e) return {&amp;#39;id&amp;#39;:[&amp;#39;未知显卡错误&amp;#39;], &amp;#39;gpu_mem_usage&amp;#39;: [], &amp;#39;gpu_utilization&amp;#39;: []} # print(result) if &amp;#34;NVIDIA-SMI has failed &amp;#34; in result: return {&amp;#39;id&amp;#39;:[&amp;#39;显卡驱动异常&amp;#39;], &amp;#39;gpu_mem_usage&amp;#39;: [&amp;#39;N/A&amp;#39;], &amp;#39;gpu_utilization&amp;#39;: [&amp;#39;N/A&amp;#39;]} elif &amp;#34;Unable to determine the device handle&amp;#34; in result: return {&amp;#39;id&amp;#39;:[&amp;#39;显卡状态异常&amp;#39;], &amp;#39;gpu_mem_usage&amp;#39;: [&amp;#39;N/A&amp;#39;], &amp;#39;gpu_utilization&amp;#39;: [&amp;#39;N/A&amp;#39;]} else: gpu_info = result.</description>
    </item>
    
    <item>
      <title>Linux Nvidia 显卡掉驱动</title>
      <link>https://Lu0key.github.io/post/linux-nvidia-driver-failed/</link>
      <pubDate>Wed, 28 Feb 2024 16:45:30 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/linux-nvidia-driver-failed/</guid>
      <description>环境: Ubuntu 22.04
很恶心的一个问题, 经常掉驱动
# 看到这个就恶心 nvidia-smi # NVIDIA-SMI has failed because it couldn&amp;#39;t communicate with the NVIDIA driver. Make sure that the latest NVIDIA driver is installed and running. 目前可能的一个原因是服务器重启之后自动更新了内核版本, 导致驱动与内核版本不匹配, 很抽象
这里主要记录禁止内核自动升级, 和已经升级了的解决尝试
禁止内核自动升级 # 关闭内核自动升级 sudo apt-mark hold linux-image-generic linux-headers-generic # 以后如果要恢复 # sudo apt-mark unhold linux-image-generic linux-headers-generic # 先看看现在的 Linux 内核版本 uname -r # 6.5.0-18-generic 尝试解决 原来都是直接下新的驱动就OK了, 这次安装新的驱动不行可能是因为要求的 gcc 版本更高了, 但是电脑里没有新版的 gcc
看了别人很多解决方案, 这里还是选择不重启的方法
两种选择:</description>
    </item>
    
    <item>
      <title>Ubuntu 开机自启</title>
      <link>https://Lu0key.github.io/post/ubuntu-start-automatically-at-boot/</link>
      <pubDate>Wed, 28 Feb 2024 16:10:46 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/ubuntu-start-automatically-at-boot/</guid>
      <description>因为有些服务需要开机自启, 因此记录一下
环境: Ubuntu 22.04
方法一 这是最后成功的方法
先写好 shell 脚本, 然后在 /etc/profile 文件里面最后一行加上 bash xxx.sh 即可
目前还没实验 xxx.sh 需要什么样的权限才能用, 目前给的是 775, 今天事情处理完再多做几个实验
还要实验一下 shell 脚本的 开头是不是一定要 #!/bin/bash
方法二 这个是网上推荐的方法, 但是我没有成功, 不知道问题在哪里
[Unit] Description=Your Service Description After=network.target [Service] Type=simple ExecStart=/path/to/your/script.sh Restart=on-failure RestartSec=3s [Install] WantedBy=multi-user.target 这里 restart 只在异常退出的时候使用, 因为这个脚本只是启动服务的, 服务启动结束就完了, 不需要这个脚本一直执行.
然后保存文件并执行
sudo systemctl daemon-reload sudo systemctl restart your-service-name.service sudo systemctl status your-service-name # 可以通过这个查看日志, 如果失败了 sudo journalctl -u your-service-name.service 这里看 status 时发现, 都可以执行, 除了用 nohup python xxx 一直有问题不知道为什么, 就是执行不了, 前面后面的都能执行, 之后看看去掉 nohup 能不能执行, 不知道会不会与这个相关.</description>
    </item>
    
    <item>
      <title>Leetcode 2765 最长交替子数组</title>
      <link>https://Lu0key.github.io/post/lc-2765-longest-alternating-subarray/</link>
      <pubDate>Tue, 23 Jan 2024 23:43:58 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/lc-2765-longest-alternating-subarray/</guid>
      <description>2765.最长交替子数组 给你一个下标从 0 开始的整数数组 nums 。如果 nums 中长度为 m 的子数组 s 满足以下条件，我们称它是一个 交替子数组 ：
 m 大于 1 。 s_1 = s_0 + 1 。 下标从 0 开始的子数组 s 与数组 [s_0, s1, s_0, s_1,...,s_{(m-1) % 2}] 一样。也就是说，s1 - s0 = 1 ，s2 - s1 = -1 ，s3 - s2 = 1 ，s4 - s3 = -1 ，以此类推，直到 s[m - 1] - s[m - 2] = (-1)^m 。 请你返回 nums 中所有 交替 子数组中，最长的长度，如果不存在交替子数组，请你返回 -1 。  子数组是一个数组中一段连续 非空 的元素序列。</description>
    </item>
    
    <item>
      <title>Ubuntu docker 安装</title>
      <link>https://Lu0key.github.io/post/ubuntu_docker_%E5%AE%89%E8%A3%85/</link>
      <pubDate>Tue, 23 Jan 2024 21:57:17 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/ubuntu_docker_%E5%AE%89%E8%A3%85/</guid>
      <description>实验室最近技术调研需要用到 Docker , 因此这里记录一下安装 docker 的流程
内容全部来源于docker 从入门到实践
安装 # 卸载旧版本 sudo apt-get remove docker docker-engine docker.io # 使用 APT 安装 sudo apt-get update sudo apt-get install apt-transport-https ca-certificates curl gnupg lsb-release 添加软件源的 GPG 密钥
# 为了确认所下载软件包的合法性，需要添加软件源的 GPG 密钥。 # 这里使用国内源 curl -fsSL https://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg # 官方源 # curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg 添加 docker 软件源
# 向 sources.list 中添加 Docker 软件源 echo &amp;#34;deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.</description>
    </item>
    
    <item>
      <title>服务器ssh配置</title>
      <link>https://Lu0key.github.io/post/%E6%9C%8D%E5%8A%A1%E5%99%A8ssh%E9%85%8D%E7%BD%AE/</link>
      <pubDate>Tue, 23 Jan 2024 21:32:58 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/%E6%9C%8D%E5%8A%A1%E5%99%A8ssh%E9%85%8D%E7%BD%AE/</guid>
      <description>因为所在网络环境老安全了, 因此为了方便访问, 记一下几个常用的设置。
先查看有没有安装 openssh-server(因为这里我用的是Ubuntu, CentOs可能是别的)
# 在安装了的里面找 apt list --installed | grep openssh-server 例如装了的就是
openssh-server/jammy-updates,jammy-security,now 1:8.9p1-3ubuntu0.6 amd64 [已安装] 如果没装就装一下
sudo apt-get update sudo apt-get install openssh-server 修改文件
sudo vim /etc/ssh/sshd_config # 把原本 PermitRootLogin prohitbit-password # 改成 PermitRootLogin yes # 感觉下面这个重启也不是必须的 systemctl restart sshd 改了这些其他都可以通过ssh远程改了.</description>
    </item>
    
    <item>
      <title>Leetcode 670 最大交换</title>
      <link>https://Lu0key.github.io/post/lc-670-maximum-swap/</link>
      <pubDate>Mon, 22 Jan 2024 23:27:38 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/lc-670-maximum-swap/</guid>
      <description>670.最大交换 给定一个非负整数，你至多可以交换一次数字中的任意两位。返回你能得到的最大值。
示例 1:
输入: 2736
输出: 7236
解释: 交换数字2和数字7。
示例 2:
输入: 9973
输出: 9973
解释: 不需要交换。
注意:
 给定数字的范围是 [0, 10^8]  Related Topics
 贪心 数学  题目链接: link
解答 本题的难度是 Medium.
首先很自然的想法，当然是越高位的被换成越大越好, 因此我们从左到右遍历, 对于每一位来看, 这一位的右边有没有更大的, 如果有就把右边最大的和当前位进行换, 如果没有, 说明当前遍历过的数字已经是最大的了, 就要看看后面的了. 当然右边同时有两个是最大的, 那么当然是选位更小的那个数字, 因此从右向左遍历.
比如: 96177, 9 的右边没有比 9 更大的了, 因此跳到 6, 右边最大的为 7, 因此我们要找最大的应该用最低位, 即个位的 7. 得到结果, 97176。
代码如下:
class Solution { public int maximumSwap(int num) { String s = Integer.</description>
    </item>
    
    <item>
      <title>Leetcode 2788 按分隔符拆分字符串</title>
      <link>https://Lu0key.github.io/post/lc-2788-split-strings-by-separator/</link>
      <pubDate>Sat, 20 Jan 2024 15:24:45 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/lc-2788-split-strings-by-separator/</guid>
      <description>2788.按分隔符拆分字符串 给你一个字符串数组 words 和一个字符 separator ，请你按 separator 拆分 words 中的每个字符串。
返回一个由拆分后的新字符串组成的字符串数组，不包括空字符串 。
注意
 separator 用于决定拆分发生的位置，但它不包含在结果字符串中。 拆分可能形成两个以上的字符串。 结果字符串必须保持初始相同的先后顺序。  示例 1:
输入: words = [&amp;ldquo;one.two.three&amp;rdquo;,&amp;ldquo;four.five&amp;rdquo;,&amp;ldquo;six&amp;rdquo;], separator = &amp;ldquo;.&amp;rdquo;
输出: [&amp;ldquo;one&amp;rdquo;,&amp;ldquo;two&amp;rdquo;,&amp;ldquo;three&amp;rdquo;,&amp;ldquo;four&amp;rdquo;,&amp;ldquo;five&amp;rdquo;,&amp;ldquo;six&amp;rdquo;]
解释: 在本示例中，我们进行下述拆分：
&amp;ldquo;one.two.three&amp;rdquo; 拆分为 &amp;ldquo;one&amp;rdquo;, &amp;ldquo;two&amp;rdquo;,
&amp;ldquo;three&amp;rdquo; &amp;ldquo;four.five&amp;rdquo; 拆分为 &amp;ldquo;four&amp;rdquo;,
&amp;ldquo;five&amp;rdquo; &amp;ldquo;six&amp;rdquo; 拆分为 &amp;ldquo;six&amp;rdquo;
因此，结果数组为 [&amp;ldquo;one&amp;rdquo;,&amp;ldquo;two&amp;rdquo;,&amp;ldquo;three&amp;rdquo;,&amp;ldquo;four&amp;rdquo;,&amp;ldquo;five&amp;rdquo;,&amp;ldquo;six&amp;rdquo;] 。
示例 2:
输入: words = [&amp;quot;$easy$&amp;quot;,&amp;quot;$problem$&amp;quot;], separator = &amp;ldquo;$&amp;rdquo;
输出: [&amp;ldquo;easy&amp;rdquo;,&amp;ldquo;problem&amp;rdquo;]
解释: 在本示例中，我们进行下述拆分：
&amp;ldquo;$easy$&amp;rdquo; 拆分为 &amp;ldquo;easy&amp;rdquo;（不包括空字符串）
&amp;ldquo;$problem$&amp;rdquo; 拆分为 &amp;ldquo;problem&amp;rdquo;（不包括空字符串）
因此，结果数组为 [&amp;ldquo;easy&amp;rdquo;,&amp;ldquo;problem&amp;rdquo;] 。
示例 3:</description>
    </item>
    
    <item>
      <title>Leetcode 2809 使数组和小于等于 x 的最少时间</title>
      <link>https://Lu0key.github.io/post/lc-2809-minimum-time-to-make-array-sum-at-most-x/</link>
      <pubDate>Sat, 20 Jan 2024 00:07:08 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/lc-2809-minimum-time-to-make-array-sum-at-most-x/</guid>
      <description>2809.使数组和小于等于 x 的最少时间 给你两个长度相等下标从 0 开始的整数数组 nums1 和 nums2 。每一秒，对于所有下标 0 &amp;lt;= i &amp;lt; nums1.length ，nums1[i] 的值都增加 nums2[i] 。操作 完成后 ，你可以进行如下操作：
 选择任一满足 0 &amp;lt;= i &amp;lt; nums1.length 的下标 i ，并使 nums1[i] = 0 。  同时给你一个整数 x 。
请你返回使 nums1 中所有元素之和 小于等于 x 所需要的 最少 时间，如果无法实现，那么返回 -1 。
示例 1：
输入: nums1 = [1,2,3], nums2 = [1,2,3], x = 4
输出: 3
解释：
第 1 秒，我们对 i = 0 进行操作，得到 nums1 = [0,2+2,3+3] = [0,4,6] 。</description>
    </item>
    
    <item>
      <title>Leetcode 2171 拿出最少数目的魔法豆</title>
      <link>https://Lu0key.github.io/post/lc-2171-removing-minimum-number-of-magic-beans/</link>
      <pubDate>Thu, 18 Jan 2024 14:37:18 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/lc-2171-removing-minimum-number-of-magic-beans/</guid>
      <description>2171.拿出最少数目的魔法豆 给定一个 正整数 数组 beans ，其中每个整数表示一个袋子里装的魔法豆的数目。
请你从每个袋子中 拿出 一些豆子（也可以 不拿出），使得剩下的 非空 袋子中（即 至少还有一颗 魔法豆的袋子）魔法豆的数目 相等。一旦把魔法豆从袋子中取出，你不能再将它放到任何袋子中。
请返回你需要拿出魔法豆的 最少数目。
示例 1：
输入：beans = [4,1,6,5]
输出：4
解释：
 我们从有 1 个魔法豆的袋子中拿出 1 颗魔法豆。 剩下袋子中魔法豆的数目为：[4,0,6,5] 然后我们从有 6 个魔法豆的袋子中拿出 2 个魔法豆。 剩下袋子中魔法豆的数目为：[4,0,4,5] 然后我们从有 5 个魔法豆的袋子中拿出 1 个魔法豆。 剩下袋子中魔法豆的数目为：[4,0,4,4] 总共拿出了 1 + 2 + 1 = 4 个魔法豆，剩下非空袋子中魔法豆的数目相等。 没有比取出 4 个魔法豆更少的方案。  示例 2：
输入：beans = [2,10,3,2]
输出：7
解释：
 我们从有 2 个魔法豆的其中一个袋子中拿出 2 个魔法豆。 剩下袋子中魔法豆的数目为：[0,10,3,2] 然后我们从另一个有 2 个魔法豆的袋子中拿出 2 个魔法豆。 剩下袋子中魔法豆的数目为：[0,10,3,0] 然后我们从有 3 个魔法豆的袋子中拿出 3 个魔法豆。 剩下袋子中魔法豆的数目为：[0,10,0,0] 总共拿出了 2 + 2 + 3 = 7 个魔法豆，剩下非空袋子中魔法豆的数目相等。 没有比取出 7 个魔法豆更少的方案。  提示:</description>
    </item>
    
    <item>
      <title>Leetcode 2744 最大字符串配对数目</title>
      <link>https://Lu0key.github.io/post/lc-2744-find-maximum-number-of-string-pairs/</link>
      <pubDate>Wed, 17 Jan 2024 10:46:40 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/lc-2744-find-maximum-number-of-string-pairs/</guid>
      <description>2744.最大字符串配对数目 给你一个下标从 0 开始的数组 words ，数组中包含 互不相同 的字符串。
如果字符串 words[i] 与字符串 words[j] 满足以下条件，我们称它们可以匹配：
 字符串 words[i] 等于 words[j] 的反转字符串. 0 &amp;lt;= i &amp;lt; j &amp;lt; words.length  请你返回数组 words 中的 最大 匹配数目。
注意，每个字符串最多匹配一次。
示例 1：
示例 1：
输入：words = [&amp;ldquo;cd&amp;rdquo;,&amp;ldquo;ac&amp;rdquo;,&amp;ldquo;dc&amp;rdquo;,&amp;ldquo;ca&amp;rdquo;,&amp;ldquo;zz&amp;rdquo;]
输出：2 解释：在此示例中，我们可以通过以下方式匹配 2 对字符串：
 我们将第 0 个字符串与第 2 个字符串匹配，因为 word[0] 的反转字符串是 &amp;ldquo;dc&amp;rdquo; 并且等于 words[2]。 我们将第 1 个字符串与第 3 个字符串匹配，因为 word[1] 的反转字符串是 &amp;ldquo;ca&amp;rdquo; 并且等于 words[3]。  可以证明最多匹配数目是 2 。
示例 2:</description>
    </item>
    
    <item>
      <title>Leetcode 2719 統計整數數目</title>
      <link>https://Lu0key.github.io/post/lc-2719-count-of-integers/</link>
      <pubDate>Tue, 16 Jan 2024 17:51:29 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/lc-2719-count-of-integers/</guid>
      <description>2719.統計整數數目 給你兩個數字字符串 num1 和 num2，以及兩個整數 max_sum 和 min_sum. 如果一個整數滿足一下條件，我們稱它是一個好整數：
 num1 &amp;lt;= x &amp;lt;= num2 min_sum &amp;lt;= digit_sum(x) &amp;lt;= max_sum  請你返回好整數的數目。答案可能很大，請返回答案對 10^9+7 取餘后的結果。
注意，digit_sum(x) 表示 x 各位數字之和。
示例 1：
输入：num1 = &amp;ldquo;1&amp;rdquo;, num2 = &amp;ldquo;12&amp;rdquo;, min_num = 1, max_num = 8
输出：11
解释：总共有 11 个整数的数位和在 1 到 8 之间，分别是 1,2,3,4,5,6,7,8,10,11 和 12 。所以我们返回 11 。
示例 2：
输入：num1 = &amp;ldquo;1&amp;rdquo;, num2 = &amp;ldquo;5&amp;rdquo;, min_num = 1, max_num = 5</description>
    </item>
    
    <item>
      <title>Leetcode 82 删除排序链表中的重复元素Ⅱ</title>
      <link>https://Lu0key.github.io/post/lc-82-remove-duplicates-from-sorted-list-ii/</link>
      <pubDate>Mon, 15 Jan 2024 14:24:03 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/lc-82-remove-duplicates-from-sorted-list-ii/</guid>
      <description>82.删除排序链表中的重复元素Ⅱ 给定一个已排序的链表的头 head ， 给定一个已排序的链表的头 head ， 删除原始链表中所有重复数字的节点，只留下不同的数字 。返回已排序的链表。
示例 1：
示例 1：
输入: head = head = [1,2,3,3,4,4,5]
输出: [1,2,5]
示例 2:
输入: head = [1,1,1,2,3]
输出: [2,3]
提示：
 链表中节点数目在范围 [0, 300] 内 -100 &amp;lt;= Node.val &amp;lt;= 100 题目数据保证链表已经按升序 排列  Related Topics
 链表 双指针  题目链接: link
解答 这题虽然是 Medium，但是和昨天的 Easy 其实差不多，只是在删除了多余的节点外还要删除自己本身。
首先用最粗暴的方式，先遍历一遍所有节点，看看哪些节点只出现过一次，然后重建一遍链表。实现包括但不限于使用HashMap存每个元素出现的次数；一个长201的count数组统计每种可能的元素出现的次数；两个集合分别存出现过的节点和出现不止一次的节点，然后两个集合做差，最后通过筛选出来的结果重新构造节点，时间复杂度都是 O(N), 但是空间复杂度差一点。这些方法对于算法学习没什么帮助，因此直接选择更优的方法。
题目给出的链表本身就是升序的，因此我们只需要看当前节点与下一个节点的值是否相同，如果相同就跳过下一个节点，并且用一个值 isDelete 标记一下当前这个节点需要删除，然后继续此流程直到当前节点和下一个节点的值不同时，根据标记值 isDelete 判断是否要删除当前节点。
但是此方法只能当下一个节点存在时才能持续，因此结束了循环还要单独判断一下边界，因为有步骤需要跳过当前节点，因此需要记录当前节点的上一个节点，需要一个参数 pre 用于存储上一个节点。代码如下：
/** * Definition for singly-linked list.</description>
    </item>
    
    <item>
      <title>Leetcode 83 删除排序链表中的重复元素</title>
      <link>https://Lu0key.github.io/post/lc-83-remove-duplicates-from-sorted-list/</link>
      <pubDate>Sun, 14 Jan 2024 14:07:16 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/lc-83-remove-duplicates-from-sorted-list/</guid>
      <description>83.删除排序链表中的重复元素 给定一个已排序的链表的头 head ， 删除所有重复的元素，使每个元素只出现一次 。返回已排序的链表。
示例 1：
输入: head = [1,1,2]
输出: [1,2]
示例 2:
输入: head = [1,1,2,3,3]
输出: [1,2,3]
提示：
 链表中节点数目在范围 [0, 300] 内 -100 &amp;lt;= Node.val &amp;lt;= 100 题目数据保证链表已经按升序 排列  Related Topics
 链表  题目链接: link
解答 这题不愧是 Easy ，没有什么弯弯绕绕，因此只需要看看下一个和当前这个节点的值一不一样，如果一样就跳过下一个节点，如果不一样就当前节点跳到下一个节点，因为只要一直保持当前节点和下一个节点不一样就能保证只出现一次。
/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} * ListNode(int val) { this.</description>
    </item>
    
    <item>
      <title>Linux 更新显卡驱动</title>
      <link>https://Lu0key.github.io/post/linux-%E6%9B%B4%E6%96%B0%E6%98%BE%E5%8D%A1%E9%A9%B1%E5%8A%A8/</link>
      <pubDate>Mon, 31 Jul 2023 23:31:10 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/linux-%E6%9B%B4%E6%96%B0%E6%98%BE%E5%8D%A1%E9%A9%B1%E5%8A%A8/</guid>
      <description>最近经常更新老机器上的显卡驱动, 记录一下.
 更新显卡驱动 更新CUDA 更新 Cudnn  更新显卡驱动 先去官网下载最新的显卡驱动, 放到服务器上, 然后执行
sudo chmod u+x ./NNVIDIA-Linux-x86_64-535.86.05.run sudo ./NVIDIA-Linux-x86_64-535.86.05.run 然后一路安装即可, 可能会遇到 X Server 没关闭的错误, 那就执行下面的命令即可.(我是Ubuntu)
sudo service lightdm stop # or sudo systemctl stop gdm 然后重新执行即可.
如果遇到提示
ERROR: The Nouveau kernel driver is currently in use by your system. 那么执行下面命令
sudo vim /etc/default/grub # 然后修改成下面这样 # GRUB_CMDLINE_LINUX_DEFAULT=&amp;#34;quiet splash nouveau.modeset=0&amp;#34; # 修改完后保存退出, 更新 sudo update-grub # 重启 sudo reboot ERROR: Unable to find the development tool `cc` in your path; please make sure that you have the package &#39;gcc&#39; installed.</description>
    </item>
    
    <item>
      <title>Linux 新增硬盘</title>
      <link>https://Lu0key.github.io/post/linux-%E6%96%B0%E5%A2%9E%E7%A1%AC%E7%9B%98/</link>
      <pubDate>Mon, 31 Jul 2023 15:03:39 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/linux-%E6%96%B0%E5%A2%9E%E7%A1%AC%E7%9B%98/</guid>
      <description>我们有时候Linux 服务器只有一个硬盘, 但是不是 LVM 格式的, 没办法直接扩容, 又不够用了, 因此我们选择 新创建一个 /home2 文件夹, 然后把硬盘挂载到 /home2 上, 想要方便直接用的话, 我就直接在 /home2 下给每一个人新创建一个同样的文件夹
# 需要管理员来搞 # 比如这个用户叫xxx sudo mkdir /home2/xxx sudo chmod 755 /home2/xxx sudo chown xxx:xxx /home2/xxx 然后 xxx 就可以在这个新的文件夹里直接用了.</description>
    </item>
    
    <item>
      <title>Linux 文本文件忙</title>
      <link>https://Lu0key.github.io/post/linux-%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%E5%BF%99/</link>
      <pubDate>Mon, 31 Jul 2023 13:16:20 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/linux-%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%E5%BF%99/</guid>
      <description>使用 MobaXterm 远程连接服务器的时候, 有时候会手动创建脚本在 windows 上写好了, 然后再直接用 MobaXterm 打开文件复制进去, 然后修改 shell 脚本的权限后去运行脚本. 有时候会出现错误
-bash: ./xxx.sh: 文本文件忙 这是因为 windows 和 Linux 的换行符不一样导致的, 解决方法是使用 dos2unix 命令
dos2unix xxx.sh 然后重新运行即可.</description>
    </item>
    
    <item>
      <title>Linux gpu fan control</title>
      <link>https://Lu0key.github.io/post/linux-gpu-fan-control/</link>
      <pubDate>Wed, 26 Jul 2023 00:58:32 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/linux-gpu-fan-control/</guid>
      <description>用于 Linux 服务器风扇控制, 经常觉得服务器显卡的风扇调度太保守了, 没事就想摸摸看, 然后核心温度才50度, 摸上去都有70多度了, 因此想要自己控制显卡的风扇转速, 狠狠地转！ 有时候核心都快70度了, 风扇转速才70%。
#!/bin/bash  gpu_index_str=$(nvidia-smi --query-gpu=index --format=csv,noheader) gpu_index=($gpu_index_str) for index in ${!gpu_index[*]} do nvidia-settings -a &amp;#34;[gpu:$index]/GPUFanControlState=1&amp;#34; done old_speed=-1 # fan_nums nvidia-settings -q all | grep fan last_fan_index=$( nvidia-settings -q all | grep fan | grep -oP &amp;#34;\[fan:(\d+)\]:&amp;#34; | grep -oP &amp;#34;\d+&amp;#34; | sort -rn | head -n 1) echo $last_fan_index fan_nums=$((last_fan_index+1)) echo &amp;#34;fan count&amp;#34; echo $fan_nums while true do temperature_str=$(nvidia-smi --query-gpu=temperature.gpu --format=csv,noheader) temperature=($temperature_str) if [ $((temperature[0])) -lt 40 ]; then echo &amp;#34;temperature &amp;lt; 40&amp;#34; fan_speed=60 elif [ $((temperature[0])) -lt 60 ]; then echo &amp;#34;40 &amp;lt; temperature &amp;lt; 60&amp;#34; fan_speed=90 else echo &amp;#34;temperature &amp;gt; 60&amp;#34; fan_speed=100 fi if [ $((old_speed)) -ne $((fan_speed)) ]; then for ((index=0;index&amp;lt;fan_nums;index++)) do old_speed=$fan_speed # echo &amp;#34;fan speed flush to $fan_speed&amp;#34; nvidia-settings -a &amp;#34;[fan:$((index))]/GPUTargetFanSpeed=$((fan_speed))&amp;#34; # echo &amp;#39;nvidia-settings -c:$index -a &amp;#34;[fan:$((index))]/GPUTargetFanSpeed=$((fan_speed))&amp;#34;&amp;#39; done fi sleep 300 done 缺陷:</description>
    </item>
    
    <item>
      <title>Linux 创建新用户</title>
      <link>https://Lu0key.github.io/post/linux-%E5%88%9B%E5%BB%BA%E6%96%B0%E7%94%A8%E6%88%B7/</link>
      <pubDate>Fri, 21 Jul 2023 18:27:05 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/linux-%E5%88%9B%E5%BB%BA%E6%96%B0%E7%94%A8%E6%88%B7/</guid>
      <description>sudo adduser xxx # 指定主目录 # 例如 # sudo adduser xxx --home /new_home/xxx # 输入密码 sudo chmod 755 /home/xxx su xxx # 输入密码 ssh-keygen # 一路回车 cd ~/.ssh cat id_rsa.pub &amp;gt;&amp;gt; authorized_keys chmod 777 ~/.ssh chmod 777 ~/.ssh/id_rsa # 然后把 id_rsa 下载下来 chmod 600 ~/.ssh/id_rsa chmod 700 ~/.ssh chmod 600 ~/.ssh/authorized_keys 然后就可以根据 id_rsa 登录了.</description>
    </item>
    
    <item>
      <title>Images to UByte</title>
      <link>https://Lu0key.github.io/post/images-to-ubyte/</link>
      <pubDate>Thu, 30 Mar 2023 18:41:44 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/images-to-ubyte/</guid>
      <description>图片数据集合转化为MNIST的UByte.gz格式 因为要使用别人的模型，替换成自己的数据集，但是发现别人的模型用的是MNIST一个t10k-labels-idx1-ubyte 这样名字的数据集，而不是直接的图片，因此为了避免麻烦，我想要把自己的图片数据集转化为这种格式的，找了半天在Github 上找到了，这里只是记录一下，方便下次用
# https://blog.csdn.net/ycc2011/article/details/88965606 # # This python script converts a sample of the notMNIST dataset into # the same file format used by the MNIST dataset. If you have a program # that uses the MNIST files, you can run this script over notMNIST to # produce a new set of data files that should be compatible with # your program. # # Instructions: # # 1) if you already have a MNIST data/ directory, rename it and create # a new one # # $ mv data data.</description>
    </item>
    
    <item>
      <title>几道积分和级数</title>
      <link>https://Lu0key.github.io/post/%E5%87%A0%E9%81%93%E7%A7%AF%E5%88%86%E5%92%8C%E7%BA%A7%E6%95%B0/</link>
      <pubDate>Thu, 12 Jan 2023 16:34:59 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/%E5%87%A0%E9%81%93%E7%A7%AF%E5%88%86%E5%92%8C%E7%BA%A7%E6%95%B0/</guid>
      <description>忘记什么时候搞来的积分了，有些好像是积分竞赛的，应该很多都不是我自己做的，只是原来记录的
$\begin{aligned} &amp;amp;\dfrac{z}{1-z}=\sum_{n=1}^{\infty}z^n\qquad(|z|&amp;lt;1)\\
&amp;amp;左右两边积分可得;\ln(1-z)=-\sum_{n=1}^\infty\dfrac{z^n}{n}.\\
&amp;amp;代入z=re^{i\theta},\dfrac{re^{i\theta}}{1-re^{i\theta}}=\sum_{n=1}^{\infty}r^n(\cos n\theta+i\sin n\theta)\\
&amp;amp;左边=\dfrac{re^{i\theta}}{1-re^{i\theta}}=\dfrac{r\cos\theta+ir\sin\theta}{(1-r\cos\theta)-ir\sin\theta}=\dfrac{(r\cos\theta+ir\sin\theta)[(1-r\cos\theta)+ir\sin\theta]}{(1-r\cos\theta)^2+r^2\sin^2\theta}\\
&amp;amp;\qquad=\dfrac{r\cos\theta-r^2}{1-2r\cos\theta+r^2}+i\dfrac{r\sin\theta}{1-2r\cos\theta+r^2}\\
&amp;amp;因此\dfrac{\cos\theta-r}{1-2r\cos\theta+r^2}=\sum_{n=1}^{\infty}r^{n-1}\cos n\theta,\quad \dfrac{\sin\theta}{1-2r\cos\theta+r^2}=\sum_{n=1}^{\infty}r^{n-1}\sin n\theta.\\
&amp;amp;左右对r积分:\quad\dfrac12\ln(1-2r\cos\theta+r^2)=-\sum_{n=1}^{\infty}r^n\dfrac{\cos n\theta}{n}\cdots①\\
&amp;amp;\qquad\qquad\qquad\quad \arctan\dfrac{r\sin\theta}{1-r\cos\theta}=\sum_{n=1}^{\infty}r^n\dfrac{\sin n\theta}{n}\cdots②\\
&amp;amp;将①式中r换为-r得：\\
&amp;amp;\qquad\qquad r\cos\theta-r^2\dfrac{\cos2\theta}{2}+r^3\dfrac{\cos3\theta}{3}-\cdots=\dfrac12\ln(1+2r\cos\theta+r^2)\\
&amp;amp;将②式中的r换为-r，\theta换为-\theta得：\\
&amp;amp;\qquad\qquad r\sin\theta-r^2\dfrac{\sin2\theta}{2}+r^3\dfrac{\sin3\theta}{3}-\cdots=\arctan\dfrac{r\sin\theta}{1+r\cos\theta} \end{aligned}$
 $ \begin{aligned} \displaystyle&amp;amp;\int\dfrac{\sin \theta}{r^2-2r\cos\theta+1}\text{d}r\\
=&amp;amp;\int\dfrac{\sin\theta}{(r-\cos\theta)^2+\sin^2\theta}\text{d}(r-\cos\theta)\\
=&amp;amp;\arctan\dfrac{r-\cos\theta}{\sin \theta} \end{aligned} $
$ \begin{aligned} \left(\arctan\dfrac{r\sin\theta}{1-r\cos\theta}\right)&#39;=&amp;amp;\dfrac{1}{\left(\dfrac{r\sin\theta}{1-r\cos\theta}\right)^2+1}\cdot\dfrac{\sin\theta(1-r\cos\theta)+\cos\theta\cdot r\sin\theta}{(1-r\cos\theta)^2}\\
=&amp;amp;\dfrac{\sin\theta}{r^2\sin^2\theta+1-2r\cos\theta+r^2\cos^2\theta}\\
=&amp;amp;\dfrac{\sin\theta}{1-2r\cos\theta+r^2} \end{aligned} $
$ \begin{aligned} &amp;amp;\dfrac{\sin\theta}{1-2r\cos\theta+r^2}=\dfrac{\sin\theta}{1-2r\cos\theta+r^2\cos^2\theta+r^2\sin^2\theta}\\
=&amp;amp;\dfrac{\sin\theta}{(1-r\cos\theta)^2+r^2\sin^2\theta}=\dfrac{\dfrac{\sin\theta}{(1-r\cos\theta)^2}}{1+\left(\dfrac{r\sin\theta}{1-r\cos\theta}\right)^2} \end{aligned} $
$\displaystyle\int_0^r\dfrac{\dfrac{\sin\theta}{(1-r\cos\theta)^2}}{1+\left(\dfrac{r\sin\theta}{1-r\cos\theta}\right)^2}\text{d}r=\int_0^r\dfrac{1}{1+\left(\dfrac{r\sin\theta}{1-r\cos\theta}\right)^2}\text{d}(\dfrac{r\sin\theta}{1-r\cos\theta})\\=\arctan\dfrac{r\sin\theta}{1-r\cos\theta}$
$\displaystyle\int_0^1\dfrac{\arctan x}{x\sqrt{1-x^2}}\text{d}x=\int_0^{\frac{\pi}{4}}\dfrac{x}{\tan x}$
$\displaystyle\lim_{x\to0^+}\ln(1-x)\ln(\tan x)=\lim_{x\to0^+}\ln(1-x)\ln(\sin x)=\lim_{x\to0^+}-x\ln(\sin x)=\lim_{x\to0^+}-\dfrac{\ln(\sin x)}{\frac1x}=\lim_{x\to0^+}\dfrac{\cos x}{\sin x}\cdot x^2=0$
  $\cos\theta+\dfrac{\cos2\theta}{2}+\dfrac{\cos3\theta}{3}+\dfrac{\cos4\theta}{4}+\cdots$  直接引用昨天的结论：
$r\cos\theta-r^2\dfrac{\cos2\theta}{2}+r^3\dfrac{\cos3\theta}{3}-\cdots=\dfrac12\ln(1+2r\cos\theta+r^2)\cdots①;$
把 $r=-1$ 带入 ① 式，得：</description>
    </item>
    
    <item>
      <title>JSP项目部署</title>
      <link>https://Lu0key.github.io/post/jsp%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/</link>
      <pubDate>Thu, 12 Jan 2023 16:28:22 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/jsp%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/</guid>
      <description>在写了那么久的JavaWeb项目后，当然是把自己做的项目给别人炫耀一下呀，这时候就要把自己的内容发布到网络上。
常用的有两种方法，一种是以自己电脑为服务器，用花生壳、ngrok等一些内网穿透工具，让别人可以用浏览器访问，这种方法有一个弊端就是，你的电脑必须要实时联网，一直开机，对于笔记本来说有一些不方便；另一种方法就是搞一台云服务器，比如：阿里云，腾讯云，山大云(逃)，然后将自己的项目部署到云服务器上，这样的话就能解决上述弊端。
前提：一台服务器，服务器安装了JDK，安装了tomcat，开放了8080端口，教程基于IDEA
接下来开始教程：
 点击 File -&amp;gt; Project Structure(快捷键Ctrl+Shift+Alt+S) 点击左侧的 Project Setting -&amp;gt; Artifacts 点击中间的 + 选择 Web Application: Archive 中你的项目 点击右下角的 Apply 点击 OK 点击 Build -&amp;gt; Build Artifacts, 选择 All Artifacts -&amp;gt; Clean 点击 Build -&amp;gt; Rebuild Project, 点击 Build -&amp;gt; Build Artifacts, 选择 ${项目名}:Web -&amp;gt; Build 在左侧项目结构中找到 out -&amp;gt; artifacts -&amp;gt; ${项目名}_Web -&amp;gt; ${项目名}_Web.war 右键选择 Show in Explorer 将这个 war 包放到服务器 tomcat 目录的 webapps 下  # 假设现在在 webapps 目录下 cd .</description>
    </item>
    
    <item>
      <title>科学上网爬虫</title>
      <link>https://Lu0key.github.io/post/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E7%88%AC%E8%99%AB/</link>
      <pubDate>Mon, 09 Jan 2023 01:47:56 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E7%88%AC%E8%99%AB/</guid>
      <description>有时候会有需求需要爬需要科学上网才能访问的网站，但是如果开全局模式，访问正常网站就会非常慢，因此需要开PAC模式，但是PAC模式似乎不能直接用 requests 发送请求。
找了半天，最后发现了PAC模式支持的方式，代码如下
from pypac import PACSession,get_pac url = &amp;#39;https://xxxxxx.com&amp;#39; # 这个 url 是要看你的科学上网软件来着的 pac = get_pac(url=&amp;#39;http://127.0.0.1:端口/pac/?t=164907&amp;#39;) s = PACSession(pac) #解析pac文件 resp = s.get(url, headers=headers) </description>
    </item>
    
    <item>
      <title>RGBA图像直接叠加</title>
      <link>https://Lu0key.github.io/post/rgba%E5%9B%BE%E5%83%8F%E7%9B%B4%E6%8E%A5%E5%8F%A0%E5%8A%A0/</link>
      <pubDate>Sun, 08 Jan 2023 01:38:02 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/rgba%E5%9B%BE%E5%83%8F%E7%9B%B4%E6%8E%A5%E5%8F%A0%E5%8A%A0/</guid>
      <description>因为在做图像补全任务时,想要展示缺陷图像的样子,需要将背景透明的mask图像加到原图像上,生成需要补全的图像.
原本的mask长这样
原本的图像长这样
预期的图片长这样
省流版: img.alpha_composite(mask)
我们发现背景是黑色的,一开始想的是创建一个新的图片,和目标图像一样大小,使用mask.getpixel((i,j)) 去获取mask每一个像素点,然后如果获取的黑色的,那就设置新图的像素为原图的像素newImg.putpixel((i,j),originImg.getpixel((i,j))),大概这个思路,因为原图是没有通道的,可能要简单的修改. 之前试过,这个方法是可行的,但是速度太慢了,我要对上百张图片进行这个操作要好久,所以去找别的方法.
首先我希望把mask盖到原图像上,就像PS一样,透明的部分不会印象下面的内容.因此我先把不透明的mask转化成透明的,因为mask是通用的,所以一张图片的效率低可以接受,以下是代码和效果.
mask = Image.open(&amp;#34;mask.png&amp;#34;) W, H = mask.size newMask = Image.new(&amp;#34;RGBA&amp;#34;, mask.size, (0, 0, 0, 0)) for i in range(W): for j in range(H): # print(mask.getpixel((i, j))) if mask.getpixel((i, j)) == (255, 255, 255): newMask.putpixel((i, j), (255, 255, 255, 255)) newMask.save(&amp;#34;newMask.png&amp;#34;)  这里才知道 img.size 返回的是先是宽度,然后才是高
getpixel((i,j)), 这里的i和j也分别是宽的位置和高的位置.
 得到了新的mask
希望把newMask直接盖到原图像上,查了半天,网上要么是一个个像素去判断的,效率难以接受,要么是用Image.blend(image,mask,alpha),这种方法会改变原图像的透明度,效果如此公式:
$$\text{image} * (1-\text{alpha})+\text{mask} * \text{alpha}$$
truthImg = Image.open(os.path.join(basepath, &amp;#34;truth&amp;#34;, imgName)) newImg = Image.</description>
    </item>
    
    <item>
      <title>纪念健康打卡</title>
      <link>https://Lu0key.github.io/post/%E7%BA%AA%E5%BF%B5%E5%81%A5%E5%BA%B7%E6%89%93%E5%8D%A1/</link>
      <pubDate>Sat, 07 Jan 2023 23:24:14 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/%E7%BA%AA%E5%BF%B5%E5%81%A5%E5%BA%B7%E6%89%93%E5%8D%A1/</guid>
      <description>疫情管控放开了，学校也终于取消健康打卡了，之前写的自动化健康打卡也用不到了，记录一下这个健康打卡引用中遇到的两个新问题
这里的代码是用selenium实现的，因为懒，不想再分析请求了
第一个问题：如何发送邮件
from email.mime.text import MIMEText #纯文本，HTML from email.mime.image import MIMEImage #图片 from email.mime.multipart import MIMEMultipart #多种组合内容 # smtplib 用于邮件的发信动作 import smtplib # email 用于构建邮件内容 from email.mime.text import MIMEText # 构建邮件头 from email.header import Header def sendMail(status): # 发信方的信息：发信邮箱，QQ 邮箱授权码 # 发送方邮箱 from_addr = &amp;#39;xxxxx@qq.com&amp;#39; # 发送方的QQ邮箱授权码 password = &amp;#39;asdfghjkl&amp;#39; # 收信方邮箱 to_addr = &amp;#39;yyyyyy@qq.com&amp;#39; # 发信服务器 # QQ那边设置 smtp_server = &amp;#39;smtp.qq.com&amp;#39; # 邮箱正文内容，第一个参数为内容，第二个参数为格式(plain 为纯文本)，第三个参数为编码 msg = MIMEText(&amp;#39;恭喜你今天的打卡完成啦！&amp;#39;, &amp;#39;plain&amp;#39;, &amp;#39;utf-8&amp;#39;) # 邮件头信息 msg[&amp;#39;From&amp;#39;] = Header(&amp;#39;打卡小助手&amp;#39;) # 发送者 msg[&amp;#39;To&amp;#39;] = Header(&amp;#39;洛七&amp;#39;) # 接收者 subject = &amp;#39;【健康打卡】&amp;#39;+status msg[&amp;#39;Subject&amp;#39;] = Header(subject, &amp;#39;utf-8&amp;#39;) # 邮件主题 try: smtpobj = smtplib.</description>
    </item>
    
    <item>
      <title>记录两道行列式</title>
      <link>https://Lu0key.github.io/post/%E8%AE%B0%E5%BD%95%E4%B8%A4%E9%81%93%E8%A1%8C%E5%88%97%E5%BC%8F/</link>
      <pubDate>Sat, 07 Jan 2023 19:37:32 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/%E8%AE%B0%E5%BD%95%E4%B8%A4%E9%81%93%E8%A1%8C%E5%88%97%E5%BC%8F/</guid>
      <description>最近在清理电脑，发现有些题目之前写的，没有保存，这里记录一下
求行列式
$$ D = \begin{vmatrix} \sin(\theta_1+\theta_1)&amp;amp;\sin(\theta_1+\theta_2)&amp;amp;\cdots&amp;amp;\sin(\theta_1+\theta_n)\\
\sin(\theta_2+\theta_1)&amp;amp;\sin(\theta_2+\theta_2)&amp;amp;\cdots&amp;amp;\sin(\theta_2+\theta_n)\\
\vdots&amp;amp;\vdots&amp;amp;&amp;amp;\vdots\\
\sin(\theta_n+\theta_1)&amp;amp;\sin(\theta_n+\theta_2)&amp;amp;\cdots&amp;amp;\sin(\theta_n+\theta_n) \end{vmatrix} $$
【Sol】: 当 $n\geqslant2$ 时
$$ \begin{aligned} &amp;amp;\begin{vmatrix} \sin(\theta_1+\theta_1)&amp;amp;\sin(\theta_1+\theta_2)&amp;amp;\cdots&amp;amp;\sin(\theta_1+\theta_n)\\
\sin(\theta_2+\theta_1)&amp;amp;\sin(\theta_2+\theta_2)&amp;amp;\cdots&amp;amp;\sin(\theta_2+\theta_n)\\
\vdots&amp;amp;\vdots&amp;amp;&amp;amp;\vdots\\
\sin(\theta_n+\theta_1)&amp;amp;\sin(\theta_n+\theta_2)&amp;amp;\cdots&amp;amp;\sin(\theta_n+\theta_n) \end{vmatrix}\\
=&amp;amp;\begin{vmatrix} \sin\theta_1&amp;amp;\cos\theta_1&amp;amp;0&amp;amp;\cdots&amp;amp;0\\
\sin\theta_2&amp;amp;\cos\theta_2&amp;amp;0&amp;amp;\cdots&amp;amp;0\\
\vdots&amp;amp;\vdots&amp;amp;\vdots&amp;amp;&amp;amp;\vdots\\
\sin\theta_n&amp;amp;\cos\theta_n&amp;amp;0&amp;amp;\cdots&amp;amp;0 \end{vmatrix}_ {n \times n} \cdot \begin{vmatrix} \cos\theta_1&amp;amp;\cos\theta_2&amp;amp;\cdots&amp;amp;\cos\theta_n\\
\sin\theta_1&amp;amp;\sin\theta_2&amp;amp;\cdots&amp;amp;\sin\theta_n\\
0&amp;amp;0&amp;amp;\cdots&amp;amp;0\\
\vdots&amp;amp;\vdots&amp;amp;&amp;amp;\vdots\\
0&amp;amp;0&amp;amp;\cdots&amp;amp;0 \end{vmatrix}_{n\times n}\\
=&amp;amp;\begin{cases} -\sin^2(\theta_1-\theta_2),&amp;amp;n=2\\
0,&amp;amp;n\geqslant3 \end{cases} \end{aligned} $$
因此
$$ D= \begin{cases} \sin2\theta_1,&amp;amp;n=1\\
-\sin^2(\theta_1-\theta_2),&amp;amp;n=2\\
0,&amp;amp;n\geqslant3 \end{cases} $$
 求行列式
$$ \begin{vmatrix} a_1^{n-1}&amp;amp;a_1^{n-2}b_1&amp;amp;\cdots&amp;amp;a_1b_1^{n-2}&amp;amp;b_1^{n-1}\\
a_2^{n-1}&amp;amp;a_2^{n-2}b_2&amp;amp;\cdots&amp;amp;a_2b_2^{n-2}&amp;amp;b_2^{n-1}\\
\vdots&amp;amp;\vdots&amp;amp;&amp;amp;\vdots&amp;amp;\vdots\\
a_{n-1}^{n-1}&amp;amp;a_{n-1}^{n-2}b_{n-1}&amp;amp;\cdots&amp;amp;a_{n-1}b_{n-1}^{n-2}&amp;amp;b_{n-1}^{n-1}\\
a_{n}^{n-1}&amp;amp;a_{n}^{n-2}b_n&amp;amp;\cdots&amp;amp;a_{n}b_n^{n-2}&amp;amp;b_{n}^{n-1} \end{vmatrix} $$
【Sol】:
首先引入引理，范德蒙(Vandermonde)行列式:</description>
    </item>
    
    <item>
      <title>线性系统理论 期末突击</title>
      <link>https://Lu0key.github.io/post/%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA-%E6%9C%9F%E6%9C%AB%E7%AA%81%E5%87%BB/</link>
      <pubDate>Sat, 07 Jan 2023 19:25:29 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/%E7%BA%BF%E6%80%A7%E7%B3%BB%E7%BB%9F%E7%90%86%E8%AE%BA-%E6%9C%9F%E6%9C%AB%E7%AA%81%E5%87%BB/</guid>
      <description>第一章 第二章 第三章 第四章 第五章 第六章  第一章  传递函数 特征多项式 特征方程 系统的极点 系统的零点 零极点相消 传递函数的零点和极点 系统的传递函数矩阵 元传递函数？ 真有理分式矩阵 (严格真与真的)判别方法  【定义1.1】 动力学系统的状态定义为完全的表征系统时间域行为的一个最小内部变量组。
 系统的状态变量 初始时刻 系统的状态向量(状态) 状态空间   状态变量组可以完全的表征系统行为的属性 状态变量组的最小性 状态变量组在数学上的特征 状态变量组包含了系统的物理特征 状态变量组选取上的不唯一性  【定理1.1】 系统任意选取的两个状态变量组之间为线性非奇异的关系。
 系统的状态方程 输出方程或量测方程 离散时间系统(离散系统) 系统的阶 控制输入向量 输出向量 系统矩阵 输入矩阵 输出矩阵 前馈矩阵 实现问题(不唯一)   【定理1.2】 给定单输入——单输出线性定常系统的输入输出描述 $$ y^{(n)}+a_{n-1}y^{(n-1)}+\cdots+a_1y^{(1)}+a_0y=b_mu^{(m)}+b_{m-1}u^{(m-1)}+\cdots+b_1u^{(1)}+b_0u $$
或
$$ g(s)=\dfrac{Y(s)}{U(s)}=\dfrac{b_ms^m+\cdots+b_1s+b_0}{s^n+a_{n-1}s^{n-1}+\cdots+a_1s+a_0} $$
当 $m&amp;lt;n$ 时，其对应的一个状态空间描述为
$$ \dot{x}= \begin{bmatrix} 0&amp;amp;1\
\vdots&amp;amp;&amp;amp;\ddots\</description>
    </item>
    
    <item>
      <title>03 Vue 基础语法</title>
      <link>https://Lu0key.github.io/post/03-vue-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</link>
      <pubDate>Sun, 01 May 2022 16:40:37 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/03-vue-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</guid>
      <description>基础语法 mustache语法 {{msg}} &amp;lt;!-- 可计算 --&amp;gt; &amp;lt;!-- 可以是表达式，但不能是语句 --&amp;gt; {{msg + site}} {{msg}} {{site}} 双大括号只能作用于标签的内容，不能作为标签的属性
插值语法 v-once
&amp;lt;body&amp;gt; &amp;lt;div id=&amp;#34;app&amp;#34;&amp;gt; &amp;lt;h1&amp;gt;会变化：{{ msg }}&amp;lt;/h1&amp;gt; &amp;lt;h1 v-once&amp;gt;不会变化：{{ msg }}&amp;lt;/h1&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;script src=&amp;#34;js/vue.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;script&amp;gt; const app = Vue.createApp({ data() { return { msg: &amp;#34;sdu&amp;#34; } } }).mount(&amp;#34;#app&amp;#34;); &amp;lt;/script&amp;gt; &amp;lt;/body&amp;gt; 还没想到什么常用的应用场景
v-text
&amp;lt;body&amp;gt; &amp;lt;div id=&amp;#34;app&amp;#34;&amp;gt; &amp;lt;!-- 这个更灵活 --&amp;gt; &amp;lt;h1&amp;gt;{{ msg }}，你好。&amp;lt;/h1&amp;gt; &amp;lt;p&amp;gt;--------------&amp;lt;/p&amp;gt; &amp;lt;h1 v-text=&amp;#34;msg&amp;#34;&amp;gt;默认内容&amp;lt;/h1&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;script src=&amp;#34;js/vue.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;script&amp;gt; const app = Vue.createApp({ data() { return { msg: &amp;#34;sdu&amp;#34; } } }).</description>
    </item>
    
    <item>
      <title>02 Vue MVC MVP MVVM</title>
      <link>https://Lu0key.github.io/post/02-vue-mvc-mvp-mvvm/</link>
      <pubDate>Sun, 01 May 2022 16:38:12 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/02-vue-mvc-mvp-mvvm/</guid>
      <description>MVC/MVP/MVVM MVC M:Model 业务模型，数据层，负责数据的处理和获取数据接口层
V:View 用户界面，视图层，是指用户看到并与之交互的界面。比如网页界面，或软件的客户端界面 C:Controller 控制器，控制器层，他是 Model 和 View 之间的胶水或中间人
 View 传指令到Controller Controller 完成业务逻辑后，要求 Model 改变状态 Model 将新的数据发送到View，用户的到反馈 所有的信息都是单向的    耦合度低 重用性高 部署快 可维护性高    不适合小型，中型等规模的应用程序 适合后端  MVP MVP是将Controller 改成了 Presenter(广播)，同时改变了通信方向
P和V双向通信，P和M双向通信，V和M不发生通信
View 非常薄，不不属任何业务逻辑，被称为被动视图（Passive View），而P非常厚
MVP用的少，适用于事件驱动的应用架构。
MVVM MVVM模型将 Presenter层替换成ViewModel，其他与MVP模型基本一致
于MVP的区别是，采用了双向绑定，视图层的变动，自动反映在ViewModel上，反之亦然，三大主流前端框架都采用了这种方式。
MVVM中，一个ViewModel和一个View匹配，万泉河View绑定，所有View中的修改变化，都会更新到ViewModel中，同时ViewModel的任何变化都会同步到View上显示。
  View 前端中主要是指DOM ViewModel  内部实现了数据绑定(Data Bindings)和DOM监听 监听DOM中各种事件出发 根据业务需求改变Model中的数据 是View 和Model 的桥梁    </description>
    </item>
    
    <item>
      <title>01 Vue 初体验</title>
      <link>https://Lu0key.github.io/post/01-vue-%E5%88%9D%E4%BD%93%E9%AA%8C/</link>
      <pubDate>Sun, 01 May 2022 16:36:02 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/01-vue-%E5%88%9D%E4%BD%93%E9%AA%8C/</guid>
      <description>初体验 &amp;lt;body&amp;gt; &amp;lt;div id=&amp;#34;app&amp;#34;&amp;gt; &amp;lt;h1&amp;gt;{{message}}&amp;lt;/h1&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;script src=&amp;#34;js/vue.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;script&amp;gt; // 0. 创建实例的全局配置对象  const HelloVue = { // 定义数据  data() { return{ message: &amp;#34;Hello&amp;#34; } } }; //1. 创建Vue的实例对象  const app = Vue.createApp(HelloVue).mount(&amp;#34;#app&amp;#34;); &amp;lt;/script&amp;gt; &amp;lt;/body&amp;gt; vue 是响应式的，数据和页面分离，可以在控制台中
app.message = &amp;#34;新内容&amp;#34;; 实时无刷新更改页面内容，只解析“#app”内的内容
&amp;lt;body&amp;gt; &amp;lt;div id=&amp;#34;app&amp;#34;&amp;gt; &amp;lt;div&amp;gt;{{colleges}}&amp;lt;/div&amp;gt; &amp;lt;p&amp;gt;---------------&amp;lt;/p&amp;gt; &amp;lt;ul&amp;gt; &amp;lt;li&amp;gt;{{colleges[0]}}&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;{{colleges[1]}}&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;{{colleges[2]}}&amp;lt;/li&amp;gt; &amp;lt;/ul&amp;gt; &amp;lt;p&amp;gt;---------------&amp;lt;/p&amp;gt; &amp;lt;ul&amp;gt; &amp;lt;li v-for=&amp;#34;college in colleges&amp;#34;&amp;gt;{{college}}&amp;lt;/li&amp;gt; &amp;lt;/ul&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;script src=&amp;#34;js/vue.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;script&amp;gt; // 0. 创建实例的全局配置对象  const listApp = { // 定义数据  data() { return{ colleges: [&amp;#34;山大-中心&amp;#34;,&amp;#34;山大-洪楼&amp;#34;,&amp;#34;山大-软件&amp;#34;] } } }; //1.</description>
    </item>
    
    <item>
      <title>00 Vue 安装</title>
      <link>https://Lu0key.github.io/post/00-vue-%E5%AE%89%E8%A3%85/</link>
      <pubDate>Sun, 01 May 2022 16:31:21 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/00-vue-%E5%AE%89%E8%A3%85/</guid>
      <description>Vue安装 Vue.js官网
安装nodejs Node.js下载地址
中文地址
根据自己的电脑选择对应的LTS就可以
LTS: Long-term support 长期支持版本
之后你可能想要升级node的版本，可以供gnvm、nvm之类的应用去管理版本，这个自己查查就好
vuecli Vue CLI
下载vue/cli
根据教程，安装完nodejs后，在cmd中使用npm命令即可下载
npm install -g @vue/cli # 或者 yarn global add @vue/cli 查看版本
vue --version # 或者 vue -V 升级版本
npm update -g @vue/cli # 或者 yarn global upgrade --latest @vue/cli 创建第一个Vue应用 选择一个目录下打开cmd(入股用 powershell ，在你不设置的情况下是默认禁止使用脚本的)
# vue create [ProjectName] # 比如 vue create vue3Project 会让你选择预设
 Default ([Vue 3] babel, eslint) Default ([Vue 2] babel, eslint) Manually select features  分别是默认使用Vue3、Vue2、手动设置</description>
    </item>
    
    <item>
      <title>数据库系统(4)-关系模型之关系代数</title>
      <link>https://Lu0key.github.io/post/22-3-23-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-4-%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B%E4%B9%8B%E5%85%B3%E7%B3%BB%E4%BB%A3%E6%95%B0/</link>
      <pubDate>Wed, 23 Mar 2022 22:08:32 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/22-3-23-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-4-%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B%E4%B9%8B%E5%85%B3%E7%B3%BB%E4%BB%A3%E6%95%B0/</guid>
      <description>关系代数的基本操作 关系代数的拓展操作 关系代数的组合与应用训练 关系代数的复杂拓展操作(选学)  关系代数概述 关系代数运算的特点  基于集合，提供了一系列的关系代数操作：并、差、笛卡尔积、选择、投影和更名等基本操作 以及交、链接和关系除等拓展操作，是一种集合思维的操作语言 关系代数操作以一个或多个关系为输入，结果是一个新的关系 用对关系的运算来表达查询，需要指明所用操作，具有一定的过程性 是一种抽象的语言，是学习其他数据库语言，如SQL等的基础  基本操作 关系代数之基本操作 关系代数运算的约束
并相容性
 参与运算的两个关系及其相关属性之间有一定的对应性、可比性或意义关联性  定义
关系R与关系S存在相容性，当且仅当：
 关系R和关系S的属性数目必须相容 对于任意 i ，关系R的第 i个属性的域必须和关系S的第i个属性的域相同  并
定义：假设关系R和关系S是并相容的，则关系R与关系S的并运算结果也是一个关系，记作：$R\cup S$，它由或者出现在关系R中，或者出现在关系S中的元组构成。
并运算是将两个关系的元组合并成一个关系，在合并时去掉重复的元组。
差
定义：假设关系 R 和关系 S 时并相容的，则关系 R 与关系S 的差运算结果也是一个关系，记作：R-S，它由踹向那子啊关系R中，但不出现在关系S中的元组构成。
数学描述：$R-S={t|t\in R ;and; t\not\in S}$，其中 t 是元组
广义笛卡尔积
定义：关系$R(&amp;lt;a_1,a_2,\cdots,a_n&amp;gt;)$ 与关系 $S(&amp;lt;b_1,b_2,\cdots,b_m&amp;gt;)$ 的广义笛卡尔积运算结果也是一个关系，记作：$R\times S$，它由关系R中的元组与关系S的元组进行所有可能的拼接(或串接)构成。
维数是相加
基数是相乘
选择
定义：给定一个关系R，同时给定一个选择的条件condition(简写con)，选择运算结果也是一个关系，记作$\sigma_{com}(R)$，它从关系R中选择除满足给定条件的condition的元组构成
运算优先级(从高到低)：括弧，比较运算符，非运算，与运算，或运算
投影(Project)
定义：给定一个关系R，投影运算结果也是以一个关系，记作 $\prod_A(R)$，它从关系R中选出属性包含在 A中的列构成.
投影关系，即从给定关系中选出某些列组成新的关系，而选择操作是从给定关系中选出某些行组成新的关系
例如$\prod_{A_3,A_1}(R)$，选取 $A_3,A_1$ 两列的元组,**投影后会自动去掉重复的元组**</description>
    </item>
    
    <item>
      <title>数据库系统(3)-关系模型之基本概念</title>
      <link>https://Lu0key.github.io/post/22-3-23-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-3-%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B%E4%B9%8B%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</link>
      <pubDate>Wed, 23 Mar 2022 22:05:52 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/22-3-23-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-3-%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B%E4%B9%8B%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</guid>
      <description>关系模型概述？ 什么是关系？ 关系模型中的约束  关系模型简述 提出
E.F.Codd 在 1970 年提出
研究
一个关系(relation) 就是一个Table
关系模型就是处理Table 的，由三个部分组成：
 描述DB各种数据的基本结构形式(Table/Relation) 描述Table与Table之间所可能发生的各种操作(关系运算) 描述这些操作所应遵循的约束条件(完整性约束)  关系模型三要素
 基本结构：Relation/Table 基本操作：Relation/Table 基本的  并 Union 差 difference 广义积 product 选择 selection 投影 projection   拓展的：  交 intersection 连接 join 除 division    完整性约束：实体完整性、参照完整性和用户自定义的完整性
关系模型与关系数据库语言的关系
关系运算：关系代数和关系演算
关系演算：元组演算和域演算
基于关系代数设计的数据库语言(ISBL):用计算机可识别的符号表征关系代数的运算符号
基于元组演算设计的数据库语言(Ingres系统的QUEL)：用计算机可识别的符号表征元组演算的运算符号
基于域演算设计的数据库语言示例QBE
什么是关系 什么是表
表的基本构成要素
 表/关系 列/字段/属性/数据项 列名 列值 标题/模式 行/元组/记录  关系
“列”的取值范围“域(Domain)”</description>
    </item>
    
    <item>
      <title>数据库系统(2)-数据库系统的结构抽象与演变</title>
      <link>https://Lu0key.github.io/post/22-3-23-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-2-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BB%93%E6%9E%84%E6%8A%BD%E8%B1%A1%E4%B8%8E%E6%BC%94%E5%8F%98/</link>
      <pubDate>Wed, 23 Mar 2022 22:02:00 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/22-3-23-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-2-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BB%93%E6%9E%84%E6%8A%BD%E8%B1%A1%E4%B8%8E%E6%BC%94%E5%8F%98/</guid>
      <description>三级模式与两层映像 物理独立性和逻辑独立性 数据-&amp;gt; 模式 -&amp;gt; 数据模型 网状/层次模型 -&amp;gt; 关系模型 -&amp;gt; OO 数据模型  数据库系统的标准结构 DBMS 管理数据的三个层次
 External Level = User Level  某一用户能够看到与处理的数据，全局数据的一部分   Conceptual Level = Logic Level  从全局角度理解/管理的数据，含相应的关联约束   Internal Level = Physical Level  存储在介质上的数据，含存储路径、存储方式、索引方式等     模式(Schema)
对数据库中数据所进行的一种结构性的描述所观察到数据的结构信息
  视图(View)/数据(Data)
某一表现形式下表现出来的数据库中的数据
 模式：数据的结构
视图：展现的数据
模式是对数据的抽象
三级模式(三级视图) ExternalSchema &amp;mdash; (External) View
 某一用户能够看到与处理的数据的结构描述
 (Conceptual) Schema &amp;mdash; Conceptual View</description>
    </item>
    
    <item>
      <title>数据库系统(1)-初步认识数据库系统</title>
      <link>https://Lu0key.github.io/post/22-3-23-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-1-%E5%88%9D%E6%AD%A5%E8%AE%A4%E8%AF%86%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/</link>
      <pubDate>Wed, 23 Mar 2022 09:04:07 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/22-3-23-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F-1-%E5%88%9D%E6%AD%A5%E8%AE%A4%E8%AF%86%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/</guid>
      <description> 数据库 数据库语言（SQL） 数据库应用程序 关系数据库  面向对象数据库 XML数据库 NoSQL数据库 其他数据库 数据库设计 数据库应用程序开发 数据库存取与控制    初步认识数据库系统  数据库是电子化信息的集合  Table
 列/字段/属性/数据项 行/元组/记录  Table 中描述了一批相互有关联关系的数据
Database 相互之间有关联关系的 Table 的集合
数据库系统(工作环境)
 数据库(DB)：Database 数据库管理系统(DBMS)：Database Management System(一种软件：Oracle、SQL Server) 数据库应用(DBAP)：Database Application 数据库管理员(DBA)：Database Administrator 计算机基本系统  数据库管理系统的功能：
 数据库定义  DDL：数据定义语言   数据库操纵  DML：数据操纵语言   数据库控制  DCL：数据控制语言   数据库维护  转储、恢复、重组、性能检测、分析    SQL：结构化的数据库语言
 DDL DML DCL  </description>
    </item>
    
    <item>
      <title>数据库复试极限学习</title>
      <link>https://Lu0key.github.io/post/22-3-18-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E8%AF%95%E6%9E%81%E9%99%90%E5%AD%A6%E4%B9%A0/</link>
      <pubDate>Fri, 18 Mar 2022 15:42:13 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/22-3-18-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E8%AF%95%E6%9E%81%E9%99%90%E5%AD%A6%E4%B9%A0/</guid>
      <description>因为是突然自学，所以就可能顺序会比较 随意 乱.
绪论 四个基本概念
 数据：描述事物的符号记录 数据库：概括地讲，数据库具有永久存储、有组织和可共享的三个基本特点  数据库是长期存储在计算机内、有组织的、可共享的大量数据的集合。数据库中的数据按一定的数据模型组织、描述和存储，具有较小的冗余度、较高的数据独立性和易拓展性，并可为各种用户共享。   数据库管理系统：是位于用户和操作系统之间的一层数据管理软件，和操作系统一样是计算机的基础软件  主要功能： 数据定义功能 数据组织、存储和管理 数据操纵功能 数据库的事务管理和运行管理 数据库的建立和维护功能 其他功能(数据转换功能，互访和互操作功能)   数据库系统：是由数据库、数据库管理系统(及其应用开发工具)、应用程序和数据库管理员(DBA)组成的存储、管理、处理和维护数据的系统。  注意：数据库系统是最大的范围
数据库的发展阶段
 人工管理阶段：数据不保存、不共享、不具有独立性 文件系统阶段：可保存，但共享性差，冗余度大，独立性差 数据库管理系统：数据库系统的出现使信息系统从以加工数据的程序为中心转向围绕共享的数据库为中心的新阶段  实现整体数据的结构化
数据的共享性高、冗余度低：数据共享可以大大减少数据冗余，节约存储空间
数据独立性高：
物理独立性：是指用户的应用程序与数据库中数据的物理存储是相互独立的
逻辑独立性：是指用户的应用程序与数据库的逻辑逻辑是相互独立的
数据由数据库管理系统统一管理和控制
数据模型
 概念模型：也称信息模型，他是按用户观点来对数据和信息建模，用于数据库设计  基本概念
实体：客观存在并可相互区别的事物：人
属性：实体所具有的某一特性：人的鼻子、嘴巴
码：唯一标识实体的属性：学号
实体型：用实体名及其属性集合来抽象和刻画同类实体：类
实体集：同一类型实体的集合：学号
联系：实体之间的联系通常是指不同实体集之间的联系，实体之间的联系有一对一，一对多，多对多等
概念模型的一种表示方法：实体-联系方法，用E-R图来描述现实世界的概念模型，E-R方法也称为E-R模型。
逻辑模型：它是按计算机系统的观点对数据建模，主要用于数据库管理系统的实现，包括：
 层次模型 网状模型 关系模型  物理模型：是对数据最底层的抽象，他描述数据在系统内部的表示方法和存取方法，或在磁盘或磁带上的存储方式和存取方法，是面向计算机系统的
联系：实体内部之间的联系通常是指实体各属性之间的联系
常用的数据模型
 层次模型 网状模型 关系模型 面向对象数据模型 对象关系数据模型 半结构化数据模型  关系：一个关系对应通常说的一张表
元组：表中的一行
属性：表中的一列</description>
    </item>
    
    <item>
      <title>偏微分方程分类</title>
      <link>https://Lu0key.github.io/post/22-3-14-%E5%81%8F%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B%E5%88%86%E7%B1%BB/</link>
      <pubDate>Mon, 14 Mar 2022 18:13:13 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/22-3-14-%E5%81%8F%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B%E5%88%86%E7%B1%BB/</guid>
      <description>太久没更了，都快忘了怎么用了，最近要高强度学习，把这个捡起来继续用
 偏微分方程概念 关于未知函数 $u(x_1,x_2,\cdots,x_n)$ 的偏微分方程 是一个含有 $u$ 的偏微商的恒等式，其中最高阶微商的阶数叫做该偏微分方程的阶. 例如，二阶偏微分方程的一般形式是
$$F(x,u,Du,u_{x_1x_1},u_{x_1x_2},\cdots,u_{x_nx_n})=0$$
其中，$x=(x_1,x_2,\cdots,x_n),;Du=(u_{x_1},u_{x_2},\cdots,u_{x_n})$，$F$ 是关于自变量 $x$ 和未知函数 $u$ 及 $u$ 的有限多个偏微商的已知函数。
Laplace 算子 $$\Delta=\dfrac{\partial^2}{\partial x_1^2}+\cdots+\dfrac{\partial^2}{\partial x_n^2}$$
称为 Laplace 算子，也称 调和算子，偏微分方程中最重要的算子之一.
例子 1 关于函数 $u=u(x_1,x_2,\cdots,x_n,t)$ 的 $n$ 维波动方程是
$$u_{tt}=a^2\Delta u$$
其中，$a&amp;gt;0$ 是常数，为一个二阶常系数线性方程.
2 当一个导热体的密度和比热都是常数时，其温度分布 $u(x,t)$ 满足，热传导方程
$$u_{t}=k\Delta u$$
其中，$k&amp;gt;0$ 是常数.
3 关于函数 $u(x_1,x_2,\cdots,x_n)$ 的 $n$ 维 Laplace 方程，也称调和方程是
$$\Delta u=u_{x_1x_2}+u_{x_2x_2}+\cdots+u_{x_nx_n}=0.$$
它的解称为调和函数(重要). 当方程非齐次时，叫做 Poisson(泊松)方程. 通常称为位势方程.
 二阶线性方程的一般形式 $$Lu\equiv\sum_{i,j=1}^na^{ij}(x)u_{x_ix_j}+\sum_{i=1}^nb^i(x)u_{x_i}+c(x)u=f(x)$$
其中 $a^{ij}=a^{ji}$，$i,j=1,2,\cdots,n$，且至少有一个 $a^{ij}$ 不恒为零.
说到这个，应该讲讲 偏微分方程线性 的概念</description>
    </item>
    
    <item>
      <title>Jquery 二次选择</title>
      <link>https://Lu0key.github.io/post/jquery-second-choice/</link>
      <pubDate>Sun, 11 Jul 2021 14:33:19 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/jquery-second-choice/</guid>
      <description>进行 DOM 操作的时候，我们有两种方式
// 原生 let a = document.querySelector(&amp;#34;css selector&amp;#34;); // JQuery let b = $(&amp;#34;css selector&amp;#34;) 如果我们想要对 a 和 b 二次选择怎么办呢？(就是从 a 和 b 中找 DOM 元素)
// 原生 for (let i =0; i&amp;lt;a.length; i++){ a[i].querySelector(&amp;#34;css selector&amp;#34;); } // JQuery for (let i =0; i&amp;lt;a.length; i++){ $(a[i]).find(&amp;#34;css selector&amp;#34;); } 然后就可以根据情况进行操作了，下面的代码是帮老师写的一键审批脚本
// 打开批量模式 edit = $(&amp;#34;#batchApprovalShow&amp;#34;) edit.click() // 获取当前页所有审批申请 a = $(&amp;#34;#nowApply &amp;gt; .manage-bar.completed&amp;#34;) // 这个循环是处理页面神奇的错误的 for (let i=0;i&amp;lt;a.length;i++){ $(a[i]).find(&amp;#34;.manage-body &amp;gt; .</description>
    </item>
    
    <item>
      <title>Python 下载图片</title>
      <link>https://Lu0key.github.io/post/python-download-img/</link>
      <pubDate>Sun, 11 Jul 2021 00:23:25 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/python-download-img/</guid>
      <description>在做Python 爬虫的时候，爬取图片是一个很常用的功能
# 主要部分代码 with open(filename, &amp;#34;wb&amp;#34;) as f: f.write(resp.content) 比较通用的下载图片代码
def download_img(url,src,count=0): &amp;#34;&amp;#34;&amp;#34; :param url: 图片地址 :param src: 图片存放的文件夹 :param count: 调用次数，默认为 0 &amp;#34;&amp;#34;&amp;#34; resp = requests.get(url,headers=headers) filename = src + &amp;#34;\\&amp;#34;+ url.split(&amp;#34;/&amp;#34;)[-1] # 判断文件夹存不存在 if not os.path.exists(src): os.makedirs(src) if not os.path.isdir(src): os.makedirs(src) try: # 主要部分 with open(filename, &amp;#34;wb&amp;#34;) as f: f.write(resp.content) resp.close() except: print(&amp;#34;============================================&amp;#34;) print(&amp;#34;Error:&amp;#34;, filename) resp.close() if count&amp;lt;5: download_img(url,src,count+1) else: print(&amp;#34;彻底失败&amp;#34;) </description>
    </item>
    
    <item>
      <title>Python 爬虫乱码问题</title>
      <link>https://Lu0key.github.io/post/python-crawler-mistaken-code/</link>
      <pubDate>Sat, 10 Jul 2021 23:23:46 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/python-crawler-mistaken-code/</guid>
      <description>import requests headers = { &amp;#34;User-Agent&amp;#34;:&amp;#34;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:89.0) Gecko/20100101 Firefox/89.0&amp;#34; } resp = requests.get(&amp;#34;http://cmathc.cn/&amp;#34;, headers=headers) print(resp.text) 可以很明显看出有乱码，解决的方式非常的简单粗暴
我们发现，网络返回的字符集类型和推测出来的字符集类型是不一致的，因此我们只要将字符集类型设定为推断出来的字符集类型即可，于是
import requests headers = { &amp;#34;User-Agent&amp;#34;:&amp;#34;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:89.0) Gecko/20100101 Firefox/89.0&amp;#34; } resp = requests.get(&amp;#34;http://cmathc.cn/&amp;#34;, headers=headers) resp.encoding = resp.apparent_encoding print(resp.text) 看图可知乱码问题得到了解决</description>
    </item>
    
    <item>
      <title>HashMap源码学习</title>
      <link>https://Lu0key.github.io/post/hashmap%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/</link>
      <pubDate>Sun, 13 Jun 2021 23:21:49 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/hashmap%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/</guid>
      <description>HashMap 因为为了翻转课堂专门看了 HashMap 的源码，为了担心以后忘记，写一篇笔记记录下来，如果下面没有特指都是指 JDK 1.8 的源码，JDK 1.7 与 1.8 差别比较大
介绍 HashMap 的底层是 数组 + 链表 + 红黑树，用一张图就能表示的比较清楚
这张图有一个问题，不止要链表长度达到 8，还要数组长度达到 64
常量 // 版本 id，感觉一般没用 private static final long serialVersionUID = 362498820763181265L; // 默认初始化容量，为 16 // 之所以用 1 &amp;lt;&amp;lt; 4 应该是为了表示容量必须是 2 的幂次方 static final int DEFAULT_INITIAL_CAPACITY = 1 &amp;lt;&amp;lt; 4; // aka 16  // 最大容量为 2^30 // 最小为 2 static final int MAXIMUM_CAPACITY = 1 &amp;lt;&amp;lt; 30; // 默认负载因子为 0.</description>
    </item>
    
    <item>
      <title>考研英语记录 8</title>
      <link>https://Lu0key.github.io/post/%E8%80%83%E7%A0%94%E8%8B%B1%E8%AF%AD%E8%AE%B0%E5%BD%95-8/</link>
      <pubDate>Sat, 22 May 2021 01:54:34 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/%E8%80%83%E7%A0%94%E8%8B%B1%E8%AF%AD%E8%AE%B0%E5%BD%95-8/</guid>
      <description>bathe in sunshine 沐日光浴
police station 警察局
bus station 英国常用
bus stop 美国常用
Labor Day 劳动节
choice adj. 上等的；精选的
choice tomatoes 精选西红柿
parking lot 停车场
washing n. 要洗的衣服；洗好的衣服 v. 洗涤用的
volleyball n. 排球 up and down 上上下下；前前后后
once in a blue moon 罕见的；极少的；难得的；千载难逢
What is it called? 那东西叫什么？
wind v. 蜿蜒；缠绕
half past ten 十点半
underground adj. 地下的；秘密的
gently adv. 温柔地；温和地；轻轻地
be careful with 小心；谨慎(通常指无生命的存在)
be careful of 当心；留心(通常指有生命的存在)
be full of = be filled with = take crowded in 充满&amp;hellip;</description>
    </item>
    
    <item>
      <title>考研英语记录 7</title>
      <link>https://Lu0key.github.io/post/%E8%80%83%E7%A0%94%E8%8B%B1%E8%AF%AD%E8%AE%B0%E5%BD%95-7/</link>
      <pubDate>Thu, 20 May 2021 01:36:08 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/%E8%80%83%E7%A0%94%E8%8B%B1%E8%AF%AD%E8%AE%B0%E5%BD%95-7/</guid>
      <description>at the moment 当时；此刻；现在
take sb&amp;rsquo;s place 代替；替换
eliminate poverty 消除贫穷
the poverty of imagination 缺乏想象力
tea set 茶具
fact 指公认的事实，强调客观性
truth 指“不是虚假的”，强调主观性
hybird rice 杂交水稻
pony v. 付清 celery n. 芹菜
stress n. 重音；强调；紧张 v. 着重；强调
to stress the importance 强调重要性
The stress falls on the last syllable. 重音在最后一个音节上
Cinderella n. 灰姑娘；仙德瑞拉
whole grains 全麦；全谷类
local flavour 地方风味
carnation n. 康乃馨
bring out 出版；呈现
actress n. 女演员
the basic unit of money 基本货币单位</description>
    </item>
    
    <item>
      <title>考研英语记录 6</title>
      <link>https://Lu0key.github.io/post/%E8%80%83%E7%A0%94%E8%8B%B1%E8%AF%AD%E8%AE%B0%E5%BD%95-6/</link>
      <pubDate>Tue, 18 May 2021 00:22:00 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/%E8%80%83%E7%A0%94%E8%8B%B1%E8%AF%AD%E8%AE%B0%E5%BD%95-6/</guid>
      <description>playtime n. 课间
Money doesn&amp;rsquo;t buy happiness. 金钱买不来幸福
the rest of the money 剩余的钱
monetary adj. 货币的；金钱的
moneyed adj. 富有的
answer the phone 接电话
the North Pole 北极
sleepy adj. 欲睡的；困倦的
the Middle East 中东
west region 西方地区
stone v. 用石头打
They stone the birds. 他们用石头打鸟
Is this&amp;hellip;? 这是&amp;hellip;吗？
teddy n. 连衫衬裤
from mouth to mouth 口口相传地
that is to say 也就是说
out v. 使熄灭；揭露；驱逐
The truth will out. 真相终将大白于天下</description>
    </item>
    
    <item>
      <title>考研英语记录 5</title>
      <link>https://Lu0key.github.io/post/%E8%80%83%E7%A0%94%E8%8B%B1%E8%AF%AD%E8%AE%B0%E5%BD%95-5/</link>
      <pubDate>Mon, 17 May 2021 00:43:50 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/%E8%80%83%E7%A0%94%E8%8B%B1%E8%AF%AD%E8%AE%B0%E5%BD%95-5/</guid>
      <description>eating adj. 食用的
eating habit 饮食习惯
man-eating 吃人的
Anything else? 还有其他事吗？
anything less than 绝不是
freshman n. 大一新生
thinner n. 稀释剂
for nothing 徒然；白白地；免费
age v. 变老
age overnight 一夜之间变老了
What ablout &amp;hellip; ? &amp;hellip; 怎么样？
neighbourhood committee 居委会
central figure 中心人物
peanut butter 花生酱
to form a habit 形成一种习惯
air n. 神态；样子 v. 播出
to air a TV shows 播出电视节目
skin v. 剥皮；削皮
It is cruel to skin a snake.</description>
    </item>
    
    <item>
      <title>考研英语记录 4</title>
      <link>https://Lu0key.github.io/post/%E8%80%83%E7%A0%94%E8%8B%B1%E8%AF%AD%E8%AE%B0%E5%BD%95-4/</link>
      <pubDate>Sat, 15 May 2021 19:12:39 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/%E8%80%83%E7%A0%94%E8%8B%B1%E8%AF%AD%E8%AE%B0%E5%BD%95-4/</guid>
      <description>book v. 预定
no comment 无可奉告
instant noodles 方便面
no 相当于形容词，可以直接修饰名词
not 是副词，不能直接修饰名词，若要修饰名词，只能和冠词等连用
not 可以修饰动词，表示否定
pen n. 围栏
ruler n. 统治者
Rome was the ruler of Europe. 罗马曾是欧洲的统治者
school v. 教育
He should be schooled with his peers. 他应该跟同龄人一样接受教育
UK = United Kingdom
key in 键入
o&amp;rsquo;clock = of the clock
meter n. 计量仪；仪表 v. 用仪表测量
a gas meter 煤气表
pet n. 宠儿 adj. 钟爱的 v. 爱抚
within one hour 一个小时之内</description>
    </item>
    
    <item>
      <title>考研英语记录 3</title>
      <link>https://Lu0key.github.io/post/%E8%80%83%E7%A0%94%E8%8B%B1%E8%AF%AD%E8%AE%B0%E5%BD%95-3/</link>
      <pubDate>Fri, 14 May 2021 18:59:39 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/%E8%80%83%E7%A0%94%E8%8B%B1%E8%AF%AD%E8%AE%B0%E5%BD%95-3/</guid>
      <description>pushed adj. 处于窘境的；紧缺的；紧张的
can of fruit 水果罐头
across from 在&amp;hellip;对面
the craft of writing 写作技巧
day by day 一天天地
abracadabra n. 咒语
dog v. 尾随
I dare you&amp;hellip; 谅你不敢&amp;hellip;
How dare you&amp;hellip; 你竟然&amp;hellip;
stand on one&amp;rsquo;s head 倒立；尽某人最大的努力
hammer and tongs 竭尽全力地
Puma Ranch 美洲狮大牧场
sweet potato 红薯
sweet water 淡水；甜水
sweet dumpling 汤圆
sweet bean paste 豆沙
Yours 您诚挚的(用于信结尾)
any more 再；还
praise sb. for sth. 因 sth. 表扬 sb.</description>
    </item>
    
    <item>
      <title>考研英语记录 2</title>
      <link>https://Lu0key.github.io/post/%E8%80%83%E7%A0%94%E8%8B%B1%E8%AF%AD%E8%AE%B0%E5%BD%95-2/</link>
      <pubDate>Fri, 14 May 2021 00:55:07 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/%E8%80%83%E7%A0%94%E8%8B%B1%E8%AF%AD%E8%AE%B0%E5%BD%95-2/</guid>
      <description>class n. 阶级；类别；社会等级
class divisions/differences 阶级分歧/差异
door to door 挨家挨户
down adj. 沮丧的
a white elephant 无用的；无用的东西；沉重的负担
every other day 每隔一天
eyeable 可见的；赏心悦目的    中文 英文     界 kingdom   门 phylum   纲 class   目 order   科 family   属 genus   种 species    live v. 实况转播的
make sense 有道理；有意义
make up 弥补；组成；化妆；整理；编造/捏造</description>
    </item>
    
    <item>
      <title>考研英语记录 1</title>
      <link>https://Lu0key.github.io/post/%E8%80%83%E7%A0%94%E8%8B%B1%E8%AF%AD%E8%AE%B0%E5%BD%95-1/</link>
      <pubDate>Wed, 12 May 2021 23:30:38 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/%E8%80%83%E7%A0%94%E8%8B%B1%E8%AF%AD%E8%AE%B0%E5%BD%95-1/</guid>
      <description>每天背的前200个中出现的生词生义
would like 想要
would rather 宁可；宁愿
ask v. 要求
bread n. 生计
coat v. 覆盖
late adj. 已故的
lesson n. 教训
light v. 点燃 n. 领悟，启发 adj. 异动的
nurse v. 喂奶，照顾 n. 保姆
right v. 纠正
tell v. 辨别，判断
want n. 缺乏
wear n. 磨损
well n. 泉，油井，井
take v. 吃
degree n. 程度，学位
pant v. 喘气，喘息
pretty adv. 很，相当
lot n. 阉，签，土地，份额，命运
parking lot 停车场
schedule v. 安排</description>
    </item>
    
    <item>
      <title>科学计算 4-7</title>
      <link>https://Lu0key.github.io/post/%E7%A7%91%E5%AD%A6%E8%AE%A1%E7%AE%97-4-7/</link>
      <pubDate>Tue, 11 May 2021 09:30:22 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/%E7%A7%91%E5%AD%A6%E8%AE%A1%E7%AE%97-4-7/</guid>
      <description>4.7 画出过结点 (0,3),(1,1),(2,4),(3,1),(4,2),(5,0) 的三次样条的图像。边条件为：
 两端点的二阶导数(特别包括取0值的自然样条)  hold on; x0 = [0,1,2,3,4,5]; y0 = [3,1,4,1,2,0]; plot(x0,y0,&amp;#39;o&amp;#39;); % 两端点的二阶导数值 secDerLeft = 0; secDerRight= 0; % 直接用 csape 函数 % cs0 = csape(x0,y0,&amp;#39;variational&amp;#39;); % yy = ppval(cs0,linspace(0,5,100)); % plot(linspace(0,5,100),yy,&amp;#39;r--&amp;#39;); % [2,2] 表示两个都是二阶导的值 cs = csape(x0,[secDerLeft,y0,secDerRight],[2,2]); xxt = linspace(-1,6,100); yyt=ppval(cs,xxt); plot(xxt,yyt,&amp;#39;r--&amp;#39;); hold off; % 改好了 % 默认h_i 恒等于 1 hold on; x0 = [0,1,2,3,4,5]; y0 = [3,1,4,1,2,0]; plot(x0,y0,&amp;#39;o&amp;#39;); b = zeros(length(x0),1); A = zeros(length(x0)); for i=2:length(x0)-1 b(i) = 6.</description>
    </item>
    
    <item>
      <title>科学计算 3-24</title>
      <link>https://Lu0key.github.io/post/%E7%A7%91%E5%AD%A6%E8%AE%A1%E7%AE%97-3-24/</link>
      <pubDate>Tue, 11 May 2021 08:57:54 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/%E7%A7%91%E5%AD%A6%E8%AE%A1%E7%AE%97-3-24/</guid>
      <description>3.24    (分段)线性插值基函数的表示
不妨认为直接整数为插值接点
% 可以画图多次(以叠加的方式) hold on; % 这个代码默认结点间隔为 1，只需要改下面这一行代码即可 xNode = linspace(0,5,6); for i=1:length(xNode) if length(xNode)&amp;lt;2 break; end r = rand(); g = rand(); b = rand(); if i == 1 x = linspace(0,xNode(2),100); y = (x-xNode(2))./(xNode(1)-xNode(2)); plot(x,y,&amp;#39;Color&amp;#39;,[r,g,b]); elseif i == length(xNode) x = linspace(xNode(i-1),xNode(i),100); y = (x-xNode(i-1))./(xNode(i)-xNode(i-1)); plot(x,y,&amp;#39;Color&amp;#39;,[r,g,b]); else x = linspace(xNode(i-1),xNode(i),100); y = (x-xNode(i-1))./(xNode(i)-xNode(i-1)); plot(x,y,&amp;#39;Color&amp;#39;,[r,g,b]); x = linspace(xNode(i),xNode(i+1),100); y = (x-xNode(i+1))./(xNode(i)-xNode(i+1)); plot(x,y,&amp;#39;Color&amp;#39;,[r,g,b]); end end (分段)二次插值基函数的表示</description>
    </item>
    
    <item>
      <title>科学计算 3-10</title>
      <link>https://Lu0key.github.io/post/%E7%A7%91%E5%AD%A6%E8%AE%A1%E7%AE%97-3-10/</link>
      <pubDate>Tue, 11 May 2021 08:50:14 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/%E7%A7%91%E5%AD%A6%E8%AE%A1%E7%AE%97-3-10/</guid>
      <description>3.10 科学计算引论-实验
分析计算 $\left(\dfrac{\sqrt{2}-1}{\sqrt{2}+1}\right)^3$ 的几种算式的误差。
((sqrt(2)-1)./(sqrt(2)+1))^3 % 0.005050633883347  第一种方法
$x=(\sqrt{2}-1)^6$  digits(6) % 设置有效位为6位 vpa(sqrt(2)-1) % 0.414214 vpa(0.414214.^6) % 0.00505067 abs(((sqrt(2)-1)./(sqrt(2)+1))^3-0.00505067) % 绝对误差为 3.611665341102244e-08 第二种方法
$x=99-70\sqrt{2}$  digits(6) vpa(sqrt(2)) % 1.414214 vpa(99-70.*sqrt(2)) % 0.00505063 abs(((sqrt(2)-1)./(sqrt(2)+1))^3-0.00505063) % 绝对误差为 3.883346588740011e-09 第三种方法
$x=\left(\dfrac{1}{\sqrt{2}+1}\right)^6$  digits(6) vpa(sqrt(2)) % 2.41421 vpa(1./2.41421) % 0.414214 vpa(0.414214.^6) % 0.00505067 abs(((sqrt(2)-1)./(sqrt(2)+1))^3-0.00505067) % 绝对误差为 3.611665341102244e-08 第四种方法
$x=\dfrac{1}{99+70\sqrt{2}}$  digits(6) vpa(sqrt(2)) % 1.414214 vpa(99+70.*sqrt(2)) % 197.995 vpa(1./197.995) % 0.00505063 abs(((sqrt(2)-1)./(sqrt(2)+1))^3-0.00505063) % 绝对误差为 3.</description>
    </item>
    
    <item>
      <title>Java 实现简易图片查看器</title>
      <link>https://Lu0key.github.io/post/imageviewer-code/</link>
      <pubDate>Sun, 18 Apr 2021 16:59:54 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/imageviewer-code/</guid>
      <description>这个代码是直接用核心卷上的
import javax.swing.*; import java.awt.*; import java.io.File; public class ImageViewer { public static void main(String[] args) { EventQueue.invokeLater(()-&amp;gt;{ JFrame frame = new ImageViewerFrame(); frame.setTitle(&amp;#34;ImageViewer&amp;#34;); frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); frame.setVisible(true); }); } } class ImageViewerFrame extends JFrame{ private JLabel label; private JFileChooser chooser; private static final int DEFAULT_WIDTH = 300; private static final int DEFAULT_HEIGHT = 400; public ImageViewerFrame(){ setSize(DEFAULT_WIDTH,DEFAULT_HEIGHT); // use a label to display the images  label = new JLabel(); add(label); // set up the file chooser  chooser = new JFileChooser(); chooser.</description>
    </item>
    
    <item>
      <title>Leetcode 338 比特位计数</title>
      <link>https://Lu0key.github.io/post/leetcode-338-counting-bits/</link>
      <pubDate>Thu, 25 Mar 2021 18:22:30 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/leetcode-338-counting-bits/</guid>
      <description>比特位计数(Counting Bits) 给定一个非负整数 num。对于 0 ≤ i ≤ num 范围中的每个数字 i ，计算其二进制数中的 1 的数目并将它们作为数组返回。
示例 1:
输入: 2输出: [0,1,1]示例 2:
输入: 5输出: [0,1,1,2,1,2]进阶:
 给出时间复杂度为**O(n*sizeof(integer))的解答非常容易。但你可以在线性时间O(n)**内用一趟扫描做到吗？ 要求算法的空间复杂度为O(n)。 你能进一步完善解法吗？要求在C++或任何其他语言中不使用任何内置函数（如 C++ 中的 __builtin_popcount）来执行此操作。。  /** * Note: The returned array must be malloced, assume caller calls free(). */ int* countBits(int num, int* returnSize){ int* ret = malloc(sizeof(int)*(num+1)); *returnSize = num+1; for (int i = 0; i &amp;lt;= num; ++i) { int count = 0; for (int offset = 30; offset &amp;gt;= 0 ; offset--) { int mask = 1&amp;lt;&amp;lt;offset; if ((i &amp;amp; mask)&amp;gt;0){ count++; } } ret[i] = count; } return ret; } 更猛的方法orz</description>
    </item>
    
    <item>
      <title>Leetcode 986 区间列表的交集</title>
      <link>https://Lu0key.github.io/post/leetcode-986-interval-list-intersections/</link>
      <pubDate>Thu, 25 Mar 2021 18:19:26 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/leetcode-986-interval-list-intersections/</guid>
      <description>区间列表的交集(Interval List Intersections) 给定两个由一些 闭区间 组成的列表，firstList 和 secondList ，其中 firstList[i] = [start_i, end_i] 而 secondList[j] = [start_j, end_j] 。每个区间列表都是成对 不相交 的，并且 已经排序 。
返回这 两个区间列表的交集 。
形式上，闭区间 [a, b]（其中 a &amp;lt;= b）表示实数 x 的集合，而 a &amp;lt;= x &amp;lt;= b 。
两个闭区间的 交集 是一组实数，要么为空集，要么为闭区间。例如，[1, 3] 和 [2, 4] 的交集为 [2, 3] 。
示例 1： 输入：firstList = [[0,2],[5,10],[13,23],[24,25]], secondList = [[1,5],[8,12],[15,24],[25,26]]输出：[[1,2],[5,5],[8,10],[15,23],[24,24],[25,25]]示例 2：
输入：firstList = [[1,3],[5,9]], secondList = []输出：[]示例 3：</description>
    </item>
    
    <item>
      <title>Leetcode 451 根据字符出现频率排序</title>
      <link>https://Lu0key.github.io/post/leetcode-451-sort-characters-by-frequency/</link>
      <pubDate>Thu, 25 Mar 2021 18:15:20 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/leetcode-451-sort-characters-by-frequency/</guid>
      <description>根据字符出现频率排序(Sort Characters By Frequency) 给定一个字符串，请将字符串里的字符按照出现的频率降序排列。
示例 1:
输入:&amp;quot;tree&amp;quot;输出:&amp;quot;eert&amp;quot;解释:&#39;e&#39;出现两次，&#39;r&#39;和&#39;t&#39;都只出现一次。因此&#39;e&#39;必须出现在&#39;r&#39;和&#39;t&#39;之前。此外，&amp;quot;eetr&amp;quot;也是一个有效的答案。示例 2:
输入:&amp;quot;cccaaa&amp;quot;输出:&amp;quot;cccaaa&amp;quot;解释:&#39;c&#39;和&#39;a&#39;都出现三次。此外，&amp;quot;aaaccc&amp;quot;也是有效的答案。注意&amp;quot;cacaca&amp;quot;是不正确的，因为相同的字母必须放在一起。示例 3:
输入:&amp;quot;Aabb&amp;quot;输出:&amp;quot;bbAa&amp;quot;解释:此外，&amp;quot;bbaA&amp;quot;也是一个有效的答案，但&amp;quot;Aabb&amp;quot;是不正确的。注意&#39;A&#39;和&#39;a&#39;被认为是两种不同的字符。char * frequencySort(char * s){ int count[128] = {0}; for (int i = 0; i &amp;lt; strlen(s); ++i) { count[s[i]]++; } for (int k = 0; k &amp;lt; strlen(s); ++k) { for (int i = 0; i+1 &amp;lt; strlen(s); ++i) { if(count[s[i]] &amp;lt; count[s[i+1]] || count[s[i]] == count[s[i+1]] &amp;amp;&amp;amp; s[i] &amp;gt; s[i+1]){ char temp = s[i]; s[i] = s[i+1]; s[i+1] = temp; } } } return s; } 可以用，但是会TLE，一般遇到排序的时候，如果没有用快排，而是用冒泡排序这种O(n^2)时间复杂度的算法，都很可能会超时</description>
    </item>
    
    <item>
      <title>Leetcode 230 二叉搜索树中第K小的元素</title>
      <link>https://Lu0key.github.io/post/leetcode-230-kth-smallest-element-in-a-bst/</link>
      <pubDate>Thu, 25 Mar 2021 18:09:50 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/leetcode-230-kth-smallest-element-in-a-bst/</guid>
      <description>二叉搜索树中第K小的元素(Kth Smallest Element in a BST) 给定一个二叉搜索树的根节点 root ，和一个整数 k ，请你设计一个算法查找其中第 k 个最小元素（从 1 开始计数）。
示例 1： 输入：root = [3,1,4,null,2], k = 1输出：1示例 2： 输入：root = [5,3,6,2,4,null,null,1], k = 3输出：3提示：
 树中的节点数为 n 。 1 &amp;lt;= k &amp;lt;= n &amp;lt;= 10^4 0 &amp;lt;= Node.val &amp;lt;= 10^4  **进阶：**如果二叉搜索树经常被修改（插入/删除操作）并且你需要频繁地查找第 k 小的值，你将如何优化算法？
/** * Definition for a binary tree node. * struct TreeNode { * int val; * struct TreeNode *left; * struct TreeNode *right; * }; */ int getSize(struct TreeNode* root){ if (root == NULL) return 0; return getSize(root-&amp;gt;left)+getSize(root-&amp;gt;right)+1; } int kthSmallest(struct TreeNode* root, int k){ int leftSize = getSize(root-&amp;gt;left); if (k &amp;lt;= leftSize){ return kthSmallest(root-&amp;gt;left, k); } if (k &amp;lt;= leftSize+1){ return root-&amp;gt;val; } return kthSmallest(root-&amp;gt;right,k-leftSize-1); } 好爽，这个比较简单，写的很爽，可能因为简单？</description>
    </item>
    
    <item>
      <title>Leetcode 438 找到字符串中所有字母异位词</title>
      <link>https://Lu0key.github.io/post/leetcode-438-find-all-anagrams-in-a-string/</link>
      <pubDate>Thu, 25 Mar 2021 18:03:24 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/leetcode-438-find-all-anagrams-in-a-string/</guid>
      <description>找到字符串中所有字母异位词(Find All Anagrams in a String) 给定一个字符串 s 和一个非空字符串 p，找到 s 中所有是 p 的字母异位词的子串，返回这些子串的起始索引。
字符串只包含小写英文字母，并且字符串 s 和 p 的长度都不超过 20100。
说明：
 字母异位词指字母相同，但排列不同的字符串。 不考虑答案输出的顺序。  示例 1:
输入:s: &amp;quot;cbaebabacd&amp;quot; p: &amp;quot;abc&amp;quot;输出:[0, 6]解释:起始索引等于 0 的子串是 &amp;quot;cba&amp;quot;, 它是 &amp;quot;abc&amp;quot; 的字母异位词。起始索引等于 6 的子串是 &amp;quot;bac&amp;quot;, 它是 &amp;quot;abc&amp;quot; 的字母异位词。示例 2:
输入:s: &amp;quot;abab&amp;quot; p: &amp;quot;ab&amp;quot;输出:[0, 1, 2]解释:起始索引等于 0 的子串是 &amp;quot;ab&amp;quot;, 它是 &amp;quot;ab&amp;quot; 的字母异位词。起始索引等于 1 的子串是 &amp;quot;ba&amp;quot;, 它是 &amp;quot;ab&amp;quot; 的字母异位词。起始索引等于 2 的子串是 &amp;quot;ab&amp;quot;, 它是 &amp;quot;ab&amp;quot; 的字母异位词。/** * Note: The returned array must be malloced, assume caller calls free().</description>
    </item>
    
    <item>
      <title>Leetcode 567 字符串的排列</title>
      <link>https://Lu0key.github.io/post/leetcode-567-permutation-in-string/</link>
      <pubDate>Thu, 25 Mar 2021 16:55:44 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/leetcode-567-permutation-in-string/</guid>
      <description>字符串的排列(Permutation in String) 给定两个字符串 s1 和 s2，写一个函数来判断 s2 是否包含 s1 的排列。
换句话说，第一个字符串的排列之一是第二个字符串的 子串 。
示例 1：
输入: s1 = &amp;quot;ab&amp;quot; s2 = &amp;quot;eidbaooo&amp;quot;输出: True解释: s2 包含 s1 的排列之一 (&amp;quot;ba&amp;quot;).示例 2：
输入: s1= &amp;quot;ab&amp;quot; s2 = &amp;quot;eidboaoo&amp;quot;输出: False提示：
 输入的字符串只包含小写字母 两个字符串的长度都在 [1, 10,000] 之间。  和上一题几乎一样，甚至更简单
bool checkInclusion(char * s1, char * s2){ int lenS1 = strlen(s1); int lenS2 = strlen(s2); if (lenS1&amp;gt;lenS2) return false; int Diff[&amp;#39;z&amp;#39;-&amp;#39;a&amp;#39;+1] = {0}; for (int i = 0; i &amp;lt; lenS1; ++i) Diff[s1[i]-&amp;#39;a&amp;#39;]--; for (int i = 0; i &amp;lt; lenS1; ++i) Diff[s2[i]-&amp;#39;a&amp;#39;]++; int diffCount = 0; for (char c = &amp;#39;a&amp;#39;; c &amp;lt;= &amp;#39;z&amp;#39;; c++) { if (Diff[c-&amp;#39;a&amp;#39;] !</description>
    </item>
    
    <item>
      <title>Leetcode 540 有序数组中的单一元素</title>
      <link>https://Lu0key.github.io/post/leetcode-540-single-element-in-a-sorted-array/</link>
      <pubDate>Thu, 25 Mar 2021 16:53:45 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/leetcode-540-single-element-in-a-sorted-array/</guid>
      <description>有序数组中的单一元素(Single Element in a Sorted Array) 给定一个只包含整数的有序数组，每个元素都会出现两次，唯有一个数只会出现一次，找出这个数。
示例 1:
输入: [1,1,2,3,3,4,4,8,8]输出: 2示例 2:
输入: [3,3,7,7,10,11,11]输出: 10注意: 您的方案应该在 O(log n)时间复杂度和 O(1)空间复杂度中运行。
int singleNonDuplicate(int* nums, int numsSize){ int ans = nums[0]; for (int i = 1; i &amp;lt; numsSize; ++i) { ans ^= nums[i]; } return ans; } 这个做法和之前的做法是一模一样的，这边应该有更妙的做法，毕竟条件更多了
int singleNonDuplicate(int* nums, int numsSize){ for (int i = 0; i+1 &amp;lt; numsSize; i+=2) { if (nums[i] != nums[i+1]){ return nums[i]; } } return nums[numsSize-1]; } 这样的做法也是比较简单的，而且不用用到异或，更清楚，但是时间复杂度还是O(n)</description>
    </item>
    
    <item>
      <title>Leetcode 733 图像渲染</title>
      <link>https://Lu0key.github.io/post/leetcode-733-flood-fill/</link>
      <pubDate>Thu, 25 Mar 2021 16:51:06 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/leetcode-733-flood-fill/</guid>
      <description>图像渲染(Flood Fill) 有一幅以二维整数数组表示的图画，每一个整数表示该图画的像素值大小，数值在 0 到 65535 之间。
给你一个坐标 (sr, sc) 表示图像渲染开始的像素值（行 ，列）和一个新的颜色值 newColor，让你重新上色这幅图像。
为了完成上色工作，从初始坐标开始，记录初始坐标的上下左右四个方向上像素值与初始坐标相同的相连像素点，接着再记录这四个方向上符合条件的像素点与他们对应四个方向上像素值与初始坐标相同的相连像素点，……，重复该过程。将所有有记录的像素点的颜色值改为新的颜色值。
最后返回经过上色渲染后的图像。
示例 1:
输入: image = [[1,1,1],[1,1,0],[1,0,1]]sr = 1, sc = 1, newColor = 2输出: [[2,2,2],[2,2,0],[2,0,1]]解析: 在图像的正中间，(坐标(sr,sc)=(1,1)),在路径上所有符合条件的像素点的颜色都被更改成2。注意，右下角的像素没有更改为2，因为它不是在上下左右四个方向上与初始点相连的像素点。注意:
 image 和 image[0] 的长度在范围 [1, 50] 内。 给出的初始点将满足 0 &amp;lt;= sr &amp;lt; image.length 和 0 &amp;lt;= sc &amp;lt; image[0].length。 image[i][j] 和 newColor 表示的颜色值在范围 [0, 65535]内。  /** * Return an array of arrays of size *returnSize.</description>
    </item>
    
    <item>
      <title>Leetcode 997 找到小镇的法官</title>
      <link>https://Lu0key.github.io/post/leetcode-997-find-the-town-judge/</link>
      <pubDate>Thu, 25 Mar 2021 16:48:54 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/leetcode-997-find-the-town-judge/</guid>
      <description>找到小镇的法官((Find the Town Judge) 在一个小镇里，按从 1 到 N 标记了 N 个人。传言称，这些人中有一个是小镇上的秘密法官。
如果小镇的法官真的存在，那么：
1. 小镇的法官不相信任何人。2. 每个人（除了小镇法官外）都信任小镇的法官。3. 只有一个人同时满足属性 1 和属性 2 。 给定数组 trust，该数组由信任对 trust[i] = [a, b] 组成，表示标记为 a 的人信任标记为 b 的人。
如果小镇存在秘密法官并且可以确定他的身份，请返回该法官的标记。否则，返回 -1。
示例 1：
输入：N = 2, trust = [[1,2]]输出：2示例 2：
输入：N = 3, trust = [[1,3],[2,3]]输出：3示例 3：
输入：N = 3, trust = [[1,3],[2,3],[3,1]]输出：-1示例 4：
输入：N = 3, trust = [[1,2],[2,3]]输出：-1示例 5：</description>
    </item>
    
    <item>
      <title>Leetcode 367 有效的完全平方数</title>
      <link>https://Lu0key.github.io/post/leetcode-367-valid-perfect-square/</link>
      <pubDate>Thu, 25 Mar 2021 16:46:34 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/leetcode-367-valid-perfect-square/</guid>
      <description>有效的完全平方数(Valid Perfect Square) 给定一个 正整数 num ，编写一个函数，如果 num 是一个完全平方数，则返回 true ，否则返回 false 。
进阶：不要 使用任何内置的库函数，如 sqrt 。
示例 1：
输入：num = 16输出：true示例 2：
输入：num = 14输出：false提示：
 1 &amp;lt;= num &amp;lt;= 2^31 - 1  bool isPerfectSquare(int num){ for (int i = 0; i &amp;lt; 46341; ++i) { if (i*i == num) return true; if (i*i &amp;gt; num) return false; } return false; } 暴力！因为46341的平方会超过整数的最大值，因此我们用46341，或者用long long 之类的</description>
    </item>
    
    <item>
      <title>Leetcode 1232 缀点成线</title>
      <link>https://Lu0key.github.io/post/leetcode-1232-check-if-it-is-a-straight-line/</link>
      <pubDate>Thu, 25 Mar 2021 16:40:22 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/leetcode-1232-check-if-it-is-a-straight-line/</guid>
      <description>缀点成线(Check If It Is a Straight Line) 在一个 XY 坐标系中有一些点，我们用数组 coordinates 来分别记录它们的坐标，其中 coordinates[i] = [x, y] 表示横坐标为 x、纵坐标为 y 的点。
请你来判断，这些点是否在该坐标系中属于同一条直线上，是则返回 true，否则请返回 false。
示例 1： 输入：coordinates = [[1,2],[2,3],[3,4],[4,5],[5,6],[6,7]]输出：true示例 2： 输入：coordinates = [[1,1],[2,2],[3,4],[4,5],[5,6],[7,7]]输出：false提示：
 2 &amp;lt;= coordinates.length &amp;lt;= 1000 coordinates[i].length == 2 -10^4 &amp;lt;= coordinates[i][0], coordinates[i][1] &amp;lt;= 10^4 coordinates 中不含重复的点  bool checkStraightLine(int** coordinates, int coordinatesSize, int* coordinatesColSize){ for (int i = 0; i &amp;lt; coordinatesSize; ++i) { for (int j = i+1; j &amp;lt; coordinatesSize; ++j) { for (int k = j+1; k &amp;lt; coordinatesSize; ++k) { int x1 = coordinates[i][0]; int y1 = coordinates[i][1]; int x2 = coordinates[j][0]; int y2 = coordinates[j][1]; int x3 = coordinates[k][0]; int y3 = coordinates[k][1]; if ((y2-y1)*(x3-x1) !</description>
    </item>
    
    <item>
      <title>Leetcode 993 二叉树的堂兄弟结点</title>
      <link>https://Lu0key.github.io/post/leetcode-993-cousins-in-binary-tree/</link>
      <pubDate>Thu, 25 Mar 2021 16:38:13 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/leetcode-993-cousins-in-binary-tree/</guid>
      <description>二叉树的堂兄弟结点(Cousins in Binary Tree) 在二叉树中，根节点位于深度 0 处，每个深度为 k 的节点的子节点位于深度 k+1 处。
如果二叉树的两个节点深度相同，但 父节点不同 ，则它们是一对堂兄弟节点。
我们给出了具有唯一值的二叉树的根节点 root ，以及树中两个不同节点的值 x 和 y 。
只有与值 x 和 y 对应的节点是堂兄弟节点时，才返回 true 。否则，返回 false。
示例 1： 输入：root = [1,2,3,4], x = 4, y = 3输出：false示例 2： 输入：root = [1,2,3,null,4,null,5], x = 5, y = 4输出：true示例 3： 输入：root = [1,2,3,null,4], x = 2, y = 3输出：false提示：
 二叉树的节点数介于 2 到 100 之间。 每个节点的值都是唯一的、范围为 1 到 100 的整数。  /** * Definition for a binary tree node.</description>
    </item>
    
    <item>
      <title>Leetcode 169 多数元素</title>
      <link>https://Lu0key.github.io/post/leetcode-169-majority-element/</link>
      <pubDate>Thu, 25 Mar 2021 14:30:35 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/leetcode-169-majority-element/</guid>
      <description>多数元素(Majority Element) 给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n/2 ⌋ 的元素。
你可以假设数组是非空的，并且给定的数组总是存在多数元素。
示例 1：
输入：[3,2,3]输出：3示例 2：
输入：[2,2,1,1,1,2,2]输出：2进阶：
 尝试设计时间复杂度为 O(n)、空间复杂度为 O(1) 的算法解决此问题。  int majorityElement(int* nums, int numsSize){ while (true){ int i = rand() % numsSize; int count = 0; for(int j =0 ; j&amp;lt;numsSize; j++){ if(nums[j] == nums[i]){ count++; } } if (count &amp;gt; numsSize/2){ return nums[i]; } } return 0; } 因为有一半以上的概率获得的数字是占一半以上的元素，效率难以评估
int cmp(const void* a, const void* b){ return *(int *)a- *(int *)b; } int majorityElement(int* nums, int numsSize){ qsort(nums, numsSize, sizeof(int), cmp); return nums[numsSize/2]; } 看到这个题目，应该可以很自然的想到哈希表，但是C本身不自带，手动实现Hash表</description>
    </item>
    
    <item>
      <title>Leetcode 387 字符串中的第一个唯一字符</title>
      <link>https://Lu0key.github.io/post/leetcode-387-first-unique-character-in-a-string/</link>
      <pubDate>Thu, 25 Mar 2021 14:28:37 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/leetcode-387-first-unique-character-in-a-string/</guid>
      <description>字符串中的第一个唯一字符(First Unique Character in a String) 给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。
示例：
s = &amp;quot;leetcode&amp;quot;返回 0s = &amp;quot;loveleetcode&amp;quot;返回 2提示： 你可以假定该字符串只包含小写字母。
int firstUniqChar(char * s){ int sSize = strlen(s); for (int i = 0; i &amp;lt; sSize; i++){ if (s[i] == &amp;#39;-&amp;#39;) continue; bool isUnique = true; for(int j =i+1; j&amp;lt;sSize; j++){ if (s[j] == s[i]){ isUnique = false; s[j] = &amp;#39;-&amp;#39;; } } if (isUnique){ return i; } } return -1; } 这种时间复杂度为O(n^2)</description>
    </item>
    
    <item>
      <title>Leetcode 476 数字的补数</title>
      <link>https://Lu0key.github.io/post/leetcode-476-number-complement/</link>
      <pubDate>Thu, 25 Mar 2021 14:24:40 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/leetcode-476-number-complement/</guid>
      <description>数字的补数(Number Complement) 给你一个 正 整数 num ，输出它的补数。补数是对该数的二进制表示取反。
示例 1：
输入：num = 5输出：2解释：5 的二进制表示为 101（没有前导零位），其补数为 010。所以你需要输出 2 。示例 2：
输入：num = 1输出：0解释：1 的二进制表示为 1（没有前导零位），其补数为 0。所以你需要输出 0 。提示：
 给定的整数 num 保证在 32 位带符号整数的范围内。 num &amp;gt;= 1 你可以假定二进制数不包含前导零位。 本题与 1009 https://leetcode-cn.com/problems/complement-of-base-10-integer/ 相同  int findComplement(int num){ int firstOnePosition = -1; int ans = 0; for (int i =30; i&amp;gt;=0; i--){ int mask = (1 &amp;lt;&amp;lt; i); if(firstOnePosition&amp;lt;0 &amp;amp;&amp;amp; (num &amp;amp; mask)!</description>
    </item>
    
    <item>
      <title>Leetcode 383 赎金信</title>
      <link>https://Lu0key.github.io/post/leetcode-383-ransom-note/</link>
      <pubDate>Thu, 25 Mar 2021 14:21:59 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/leetcode-383-ransom-note/</guid>
      <description>赎金信(Ransom Not) 给定一个赎金信 (ransom) 字符串和一个杂志(magazine)字符串，判断第一个字符串 ransom 能不能由第二个字符串 magazines 里面的字符构成。如果可以构成，返回 true ；否则返回 false。
(题目说明：为了不暴露赎金信字迹，要从杂志上搜索各个需要的字母，组成单词来表达意思。杂志字符串中的每个字符只能在赎金信字符串中使用一次。)
示例 1：
输入：ransomNote = &amp;quot;a&amp;quot;, magazine = &amp;quot;b&amp;quot;输出：false示例 2：
输入：ransomNote = &amp;quot;aa&amp;quot;, magazine = &amp;quot;ab&amp;quot;输出：false示例 3：
输入：ransomNote = &amp;quot;aa&amp;quot;, magazine = &amp;quot;aab&amp;quot;输出：true提示：
 你可以假设两个字符串均只含有小写字母。  bool canConstruct(char * ransomNote, char * magazine){ int ransomNoteSize = strlen(ransomNote); int magazineSize = strlen(magazine); for(int i =0;i&amp;lt; ransomNoteSize; i++){ bool isFound = false; for(int j = 0; j &amp;lt; magazineSize; j++) { if(magazine[j] == ransomNote[i]) { isFound = true; magazine[j] = &amp;#39;-&amp;#39;; break; } } if (!</description>
    </item>
    
    <item>
      <title>Leetcode 278 第一个错误的版本</title>
      <link>https://Lu0key.github.io/post/leetcode-278-first-bad-version/</link>
      <pubDate>Thu, 25 Mar 2021 14:16:28 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/leetcode-278-first-bad-version/</guid>
      <description>第一个错误的版本(First Bad Version) 你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。
假设你有 n 个版本 [1, 2, ..., n]，你想找出导致之后所有版本出错的第一个错误的版本。
你可以通过调用 bool isBadVersion(version) 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。
示例:
给定 n = 5，并且 version = 4 是第一个错误的版本。调用 isBadVersion(3) -&amp;gt; false调用 isBadVersion(5) -&amp;gt; true调用 isBadVersion(4) -&amp;gt; true所以，4 是第一个错误的版本。 // The API isBadVersion is defined for you. // bool isBadVersion(int version);  int firstBadVersion(int n) { for (int ans = 1; ans &amp;lt;=n; ans++){ if(isBadVersion(ans) &amp;amp;&amp;amp; !isBadVersion(ans-1)){ return ans; } } return 0; } 上面这种方法是最直接的，但是相对的，但是超慢，会超时</description>
    </item>
    
    <item>
      <title>Leetcode 124 二叉树中的最大路径和</title>
      <link>https://Lu0key.github.io/post/leetcode-124-binary-tree-maximum-path-sum/</link>
      <pubDate>Tue, 23 Mar 2021 15:10:24 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/leetcode-124-binary-tree-maximum-path-sum/</guid>
      <description>二叉树中的最大路径和(Binary Tree Maximum Path Sum) 路径 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个 节点，且不一定经过根节点。
路径和 是路径中各节点值的总和。
给你一个二叉树的根节点 root ，返回其 最大路径和 。
示例 1： 输入：root = [1,2,3]输出：6解释：最优路径是 2 -&amp;gt; 1 -&amp;gt; 3 ，路径和为 2 + 1 + 3 = 6示例 2： 输入：root = [-10,9,20,null,null,15,7]输出：42解释：最优路径是 15 -&amp;gt; 20 -&amp;gt; 7 ，路径和为 15 + 20 + 7 = 42提示：
 树中节点数目范围是 [1, 3 * 10^4] -1000 &amp;lt;= Node.val &amp;lt;= 1000  /** * Definition for a binary tree node.</description>
    </item>
    
    <item>
      <title>Leetcode 221 最大正方形</title>
      <link>https://Lu0key.github.io/post/leetcode-221-maximal-square/</link>
      <pubDate>Tue, 23 Mar 2021 15:08:31 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/leetcode-221-maximal-square/</guid>
      <description>最大正方形(Maximal Square) 在一个由 &#39;0&#39; 和 &#39;1&#39; 组成的二维矩阵内，找到只包含 &#39;1&#39; 的最大正方形，并返回其面积。
示例 1：
输入：matrix = [[&amp;quot;1&amp;quot;,&amp;quot;0&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;0&amp;quot;,&amp;quot;0&amp;quot;],[&amp;quot;1&amp;quot;,&amp;quot;0&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;1&amp;quot;],[&amp;quot;1&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;1&amp;quot;],[&amp;quot;1&amp;quot;,&amp;quot;0&amp;quot;,&amp;quot;0&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;0&amp;quot;]]输出：4示例 2：
输入：matrix = [[&amp;quot;0&amp;quot;,&amp;quot;1&amp;quot;],[&amp;quot;1&amp;quot;,&amp;quot;0&amp;quot;]]输出：1示例 3：
输入：matrix = [[&amp;quot;0&amp;quot;]]输出：0提示：
 m == matrix.length n == matrix[i].length 1 &amp;lt;= m, n &amp;lt;= 300 matrix[i][j] 为 &#39;0&#39; 或 &#39;1&#39;  int min(int a, int b){ if (a&amp;lt;b){ return a; }else{ return b; } } bool noZero(char** matrix, int row ,int col ,int size){ for(int dr = 0;dr &amp;lt; size;dr++){ for(int dc = 0;dc &amp;lt; size; dc++){ if(matrix[row+dr][col+dc] == &amp;#39;0&amp;#39;){ return false; } } } return true; } int maximalSquare(char** matrix, int matrixSize, int* matrixColSize){ // if (matrixSize == 0) return 0;  int rows = matrixSize; int cols = matrixColSize[0]; int maxSize = 0; for(int row =0 ;row &amp;lt; rows;row++){ for(int col = 0;col&amp;lt;cols; col++){ for(int size =1;size&amp;lt;=min(rows-row,cols-col);size++){ if(noZero(matrix, row, col, size) &amp;amp;&amp;amp; size &amp;gt; maxSize){ maxSize = size; } } } } return maxSize * maxSize; } 勉强过了</description>
    </item>
    
    <item>
      <title>Leetcode 1143 最长公共子序列</title>
      <link>https://Lu0key.github.io/post/leetcode-1143-longest-common-subsequence/</link>
      <pubDate>Tue, 23 Mar 2021 15:04:39 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/leetcode-1143-longest-common-subsequence/</guid>
      <description>最长公共子序列(Longest Common Subsequence) 给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列的长度。
一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。 例如，&amp;ldquo;ace&amp;rdquo; 是 &amp;ldquo;abcde&amp;rdquo; 的子序列，但 &amp;ldquo;aec&amp;rdquo; 不是 &amp;ldquo;abcde&amp;rdquo; 的子序列。两个字符串的「公共子序列」是这两个字符串所共同拥有的子序列。
若这两个字符串没有公共子序列，则返回 0。
示例 1:
输入：text1 = &amp;quot;abcde&amp;quot;, text2 = &amp;quot;ace&amp;quot; 输出：3 解释：最长公共子序列是 &amp;quot;ace&amp;quot;，它的长度为 3。示例 2:
输入：text1 = &amp;quot;abc&amp;quot;, text2 = &amp;quot;abc&amp;quot;输出：3解释：最长公共子序列是 &amp;quot;abc&amp;quot;，它的长度为 3。示例 3:
输入：text1 = &amp;quot;abc&amp;quot;, text2 = &amp;quot;def&amp;quot;输出：0解释：两个字符串没有公共子序列，返回 0。提示:
 1 &amp;lt;= text1.length &amp;lt;= 1000 1 &amp;lt;= text2.length &amp;lt;= 1000 输入的字符串只含有小写英文字符。  int lcs(char* text1, char* text2, int m, int n) { if(m == 0||n == 0) return 0; if(text1[m-1] == text2[n-1]) { return lcs(text1,text2,m-1,n-1)+1; }else { int discard1 = lcs(text1, text2, m-1, n); int discard2 = lcs(text1, text2, m, n-1); if(discard1 &amp;gt; discard2){ return discard1; }else { return discard2; } } } int longestCommonSubsequence(char* text1, char* text2){ int len1 = strlen(text1); int len2 = strlen(text2); return lcs(text1, text2, len1, len2); } 但是这种方法显然会爆炸，递归太多，超时</description>
    </item>
    
    <item>
      <title>Leetcode 55 跳跃游戏</title>
      <link>https://Lu0key.github.io/post/leetcode-55-jump-game/</link>
      <pubDate>Tue, 23 Mar 2021 15:02:46 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/leetcode-55-jump-game/</guid>
      <description>跳跃游戏(Jump Game) 给定一个非负整数数组 nums ，你最初位于数组的 第一个下标 。
数组中的每个元素代表你在该位置可以跳跃的最大长度。
判断你是否能够到达最后一个下标。
示例 1：
输入：nums = [2,3,1,1,4]输出：true解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。示例 2：
输入：nums = [3,2,1,0,4]输出：false解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。提示：
 1 &amp;lt;= nums.length &amp;lt;= 3 * 10^4 0 &amp;lt;= nums[i] &amp;lt;= 10^5  bool canJump(int* nums, int numsSize){ int start = 0; printf(&amp;#34;%d\n&amp;#34;,start); while(start &amp;lt;numsSize){ int newIndex = -1; if(start+nums[start]&amp;gt;=numsSize-1) return true; for(int i =1;i&amp;lt;=nums[start];i++){ if(i+nums[start+i]&amp;gt;nums[start]){ if(newIndex == -1){ newIndex = i+start; }else if(i+nums[start +i]&amp;gt;newIndex-start+nums[newIndex]){ newIndex = i+start; } } } if(newIndex == -1) return false; start = newIndex; } return false; } yeah，写出来了，看看老师怎么写的</description>
    </item>
    
    <item>
      <title>Leetcode 16.25 LRU 缓存</title>
      <link>https://Lu0key.github.io/post/leetcode-16.25-lru-cache-lcci/</link>
      <pubDate>Tue, 23 Mar 2021 14:54:41 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/leetcode-16.25-lru-cache-lcci/</guid>
      <description>LRU 缓存(LRU Cache) 设计和构建一个“最近最少使用”缓存，该缓存会删除最近最少使用的项目。缓存应该从键映射到值(允许你插入和检索特定键对应的值)，并在初始化时指定最大容量。当缓存被填满时，它应该删除最近最少使用的项目。
它应该支持以下操作： 获取数据 get 和 写入数据 put 。
获取数据 get(key) - 如果密钥 (key) 存在于缓存中，则获取密钥的值（总是正数），否则返回 -1。 写入数据 put(key, value) - 如果密钥不存在，则写入其数据值。当缓存容量达到上限时，它应该在写入新数据之前删除最近最少使用的数据值，从而为新的数据值留出空间。
示例:
LRUCache cache = new LRUCache( 2 /* 缓存容量 */ );cache.put(1, 1);cache.put(2, 2);cache.get(1); // 返回 1cache.put(3, 3); // 该操作会使得密钥 2 作废cache.get(2); // 返回 -1 (未找到)cache.put(4, 4); // 该操作会使得密钥 1 作废cache.get(1); // 返回 -1 (未找到)cache.get(3); // 返回 3cache.get(4); // 返回 4自己实现一个简单的缓存</description>
    </item>
    
    <item>
      <title>Leetcode 201 数字范围按位与</title>
      <link>https://Lu0key.github.io/post/leetcode-201-bitwise-and-of-numbers-range/</link>
      <pubDate>Tue, 23 Mar 2021 14:52:40 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/leetcode-201-bitwise-and-of-numbers-range/</guid>
      <description>数字范围按位与(Bitwise AND of Numbers Range) 给你两个整数 left 和 right ，表示区间 [left, right] ，返回此区间内所有数字 按位与 的结果（包含 left 、right 端点）。
示例 1：
输入：left = 5, right = 7输出：4示例 2：
输入：left = 0, right = 0输出：0示例 3：
输入：left = 1, right = 2147483647输出：0提示：
 0 &amp;lt;= left &amp;lt;= right &amp;lt;= 2^31 - 1  int rangeBitwiseAnd(int left, int right){ if(left == 0) return 0; int a = right; for(int i = left;i&amp;lt;right;i++){ a &amp;amp;=i; } return a; } 这样显然会超时</description>
    </item>
    
    <item>
      <title>Leetcode 560 和为K的子数组</title>
      <link>https://Lu0key.github.io/post/leetcode-560-subarray-sum-equals-k/</link>
      <pubDate>Tue, 23 Mar 2021 14:50:23 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/leetcode-560-subarray-sum-equals-k/</guid>
      <description>和为K的子数组(Subarray Sum Equals K) 给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数。
示例 1 :
输入:nums = [1,1,1], k = 2输出: 2 , [1,1] 与 [1,1] 为两种不同的情况。说明 :
 数组的长度为 [1, 20,000]。 数组中元素的范围是 [-1000, 1000] ，且整数 k 的范围是 [-1e7, 1e7]。  int subarraySum(int* nums, int numsSize, int k){ int count = 0; for(int i =0;i&amp;lt;numsSize;i++){ int sum = 0; for(int j=i;j&amp;lt;numsSize;j++){ sum+=nums[j]; if(sum == k){ count++; } } } return count; } O(n^2) 会超时哦</description>
    </item>
    
    <item>
      <title>Leetcode 1008 前序遍历构造二叉搜索树</title>
      <link>https://Lu0key.github.io/post/leetcode-1008-construct-binary-search-tree-from-preorder-traversal/</link>
      <pubDate>Tue, 23 Mar 2021 14:47:50 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/leetcode-1008-construct-binary-search-tree-from-preorder-traversal/</guid>
      <description>前序遍历构造二叉搜索树(Construct Binary Search Tree from Preorder Traversal) 返回与给定前序遍历 preorder 相匹配的二叉搜索树（binary search tree）的根结点。
(回想一下，二叉搜索树是二叉树的一种，其每个节点都满足以下规则，对于 node.left 的任何后代，值总 &amp;lt; node.val，而 node.right 的任何后代，值总 &amp;gt; node.val。此外，前序遍历首先显示节点 node 的值，然后遍历 node.left，接着遍历 node.right。）
题目保证，对于给定的测试用例，总能找到满足要求的二叉搜索树。
示例：
输入：[8,5,1,7,10,12]输出：[8,5,10,1,7,null,12]提示：
 1 &amp;lt;= preorder.length &amp;lt; = 100 1 &amp;lt;= preorder[i] &amp;lt;= 10^8 preorder 中的值互不相同  /** * Definition for a binary tree node. * struct TreeNode { * int val; * struct TreeNode *left; * struct TreeNode *right; * }; */ struct TreeNode* bstFromPreorderRanged(int* preorder, int start, int end){ if(start == end) return NULL; struct TreeNode* root = malloc(sizeof(struct TreeNode)); root-&amp;gt;val = preorder[start]; int i = start+1; while (i&amp;lt;end &amp;amp;&amp;amp; preorder[i]&amp;lt;root-&amp;gt;val){ i++; } root-&amp;gt;left = bstFromPreorderRanged(preorder, start+1, i); root-&amp;gt;right = bstFromPreorderRanged(preorder,i,end); return root; } struct TreeNode* bstFromPreorder(int* preorder, int preorderSize){ return bstFromPreorderRanged(preorder,0,preorderSize); } 提高效率</description>
    </item>
    
    <item>
      <title>Leetcode 33 搜索旋转排序数组</title>
      <link>https://Lu0key.github.io/post/leetcode-33-search-in-rotated-sorted-array/</link>
      <pubDate>Tue, 23 Mar 2021 14:44:28 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/leetcode-33-search-in-rotated-sorted-array/</guid>
      <description>搜索旋转排序数组(Search in Rotated Sorted Array) 整数数组 nums 按升序排列，数组中的值 互不相同 。
在传递给函数之前，nums 在预先未知的某个下标 k（0 &amp;lt;= k &amp;lt; nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。
给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的索引，否则返回 -1 。
示例 1：
输入：nums = [4,5,6,7,0,1,2], target = 0输出：4示例 2：
输入：nums = [4,5,6,7,0,1,2], target = 3输出：-1示例 3：
输入：nums = [1], target = 0输出：-1提示：</description>
    </item>
    
    <item>
      <title>Leetcode 64 最小路径和</title>
      <link>https://Lu0key.github.io/post/leetcode-64-minimum-path-sum/</link>
      <pubDate>Tue, 23 Mar 2021 14:41:59 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/leetcode-64-minimum-path-sum/</guid>
      <description>最小路径和(Minimum Path Sum) 给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。
说明： 每次只能向下或者向右移动一步。
示例 1： 输入：grid = [[1,3,1],[1,5,1],[4,2,1]]输出：7解释：因为路径 1→3→1→1→1 的总和最小。示例 2：
输入：grid = [[1,2,3],[4,5,6]]输出：12提示：
 m == grid.length n == grid[i].length 1 &amp;lt;= m, n &amp;lt;= 200 0 &amp;lt;= grid[i][j] &amp;lt;= 100  int minPartialPathSum(int** grid,int** path,int ROWS,int COLS,int i,int j){ if (path[i][j]!=-1){ return path[i][j]; } int right = grid[i][j]; int down = grid[i][j]; if (i==ROWS-1&amp;amp;&amp;amp;j==COLS-1){ path[i][j] = grid[i][j]; return grid[i][j]; } if(j&amp;lt;COLS-1){ right +=minPartialPathSum(grid,path,ROWS,COLS,i,j+1); } if(i&amp;lt;ROWS-1){ down +=minPartialPathSum(grid,path,ROWS,COLS,i+1,j); } if (j==COLS-1){ path[i][j] = down; return down; } if (i==ROWS-1){ path[i][j] = right; return right; } int re = right&amp;lt;down?</description>
    </item>
    
    <item>
      <title>Leetcode 200 岛屿数量</title>
      <link>https://Lu0key.github.io/post/leetcode-200-number-of-islands/</link>
      <pubDate>Tue, 23 Mar 2021 14:39:02 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/leetcode-200-number-of-islands/</guid>
      <description>岛屿数量(Number of Islands) 给你一个由 &#39;1&#39;（陆地）和 &#39;0&#39;（水）组成的的二维网格，请你计算网格中岛屿的数量。
岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。
此外，你可以假设该网格的四条边均被水包围。
示例 1：
输入：grid = [[&amp;quot;1&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;0&amp;quot;],[&amp;quot;1&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;0&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;0&amp;quot;],[&amp;quot;1&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;0&amp;quot;,&amp;quot;0&amp;quot;,&amp;quot;0&amp;quot;],[&amp;quot;0&amp;quot;,&amp;quot;0&amp;quot;,&amp;quot;0&amp;quot;,&amp;quot;0&amp;quot;,&amp;quot;0&amp;quot;]]输出：1示例 2：
输入：grid = [[&amp;quot;1&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;0&amp;quot;,&amp;quot;0&amp;quot;,&amp;quot;0&amp;quot;],[&amp;quot;1&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;0&amp;quot;,&amp;quot;0&amp;quot;,&amp;quot;0&amp;quot;],[&amp;quot;0&amp;quot;,&amp;quot;0&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;0&amp;quot;,&amp;quot;0&amp;quot;],[&amp;quot;0&amp;quot;,&amp;quot;0&amp;quot;,&amp;quot;0&amp;quot;,&amp;quot;1&amp;quot;,&amp;quot;1&amp;quot;]]输出：3提示：
 m == grid.length n == grid[i].length 1 &amp;lt;= m, n &amp;lt;= 300 grid[i][j] 的值为 &#39;0&#39; 或 &#39;1&#39;  我们找到一个岛屿之后就把他清零，当所有数字都为0时，就表示结束了
const char WATER = &amp;#39;0&amp;#39;; const char LAND = &amp;#39;1&amp;#39;; const char NEW = &amp;#39;X&amp;#39;; const char USED = &amp;#39;O&amp;#39;; void floodFill(char** grid,int NUMBER_OF_ROWS,int NUMBER_OF_COLS,int i,int j){ if(i&amp;lt;0 || i&amp;gt;=NUMBER_OF_ROWS || j&amp;lt;0 || j&amp;gt;=NUMBER_OF_COLS||grid[i][j]!</description>
    </item>
    
    <item>
      <title>Leetcode 678 有效的括号字符串</title>
      <link>https://Lu0key.github.io/post/leetcode-678-valid-parenthesis-string/</link>
      <pubDate>Tue, 23 Mar 2021 14:30:43 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/leetcode-678-valid-parenthesis-string/</guid>
      <description>有效的括号字符串(Valid Parenthesis String) 给定一个只包含三种字符的字符串：（ ，） 和 *，写一个函数来检验这个字符串是否为有效字符串。有效字符串具有如下规则：
 任何左括号 ( 必须有相应的右括号 )。 任何右括号 ) 必须有相应的左括号 ( 。 左括号 ( 必须在对应的右括号之前 )。 * 可以被视为单个右括号 ) ，或单个左括号 ( ，或一个空字符串。 一个空字符串也被视为有效字符串。  示例 1:
输入: &amp;quot;()&amp;quot;输出: True示例 2:
输入: &amp;quot;(*)&amp;quot;输出: True示例 3:
输入: &amp;quot;(*))&amp;quot;输出: True注意:
 字符串大小将在 [1，100] 范围内。  bool checkVaildSubstring(char * s, int i, int j){ if(i &amp;gt; j) return true; if(s[i] == &amp;#39;)&amp;#39;) { return false; }else if( s[i] == &amp;#39;*&amp;#39;){ if (checkVaildSubstring(s, i+1,j)){ return true; } } for (int k=i+1;k&amp;lt;= j;k++){ if(s[k]==&amp;#39;)&amp;#39; || s[k] == &amp;#39;*&amp;#39;){ if(checkVaildSubstring(s,i+1,k-1) &amp;amp;&amp;amp; checkVaildSubstring(s,k+1,j)){ return true; } } } return false; } bool checkValidString(char * s){ return checkVaildSubstring(s,0,strlen(s)-1); } 这里会因为重复算相同的内容多次导致超时，因此我们可以用一个二维数组将算过的存起来，二维数组的i,j表示从索引i到索引j的这个子串是否计算过</description>
    </item>
    
    <item>
      <title>Leetcode 238 除自身以外数组的乘积</title>
      <link>https://Lu0key.github.io/post/leetcode-238-product-of-array-except-self/</link>
      <pubDate>Tue, 23 Mar 2021 14:27:37 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/leetcode-238-product-of-array-except-self/</guid>
      <description>除自身以外数组的乘积(Product of Array Except Self) 给你一个长度为 n 的整数数组 nums，其中 n &amp;gt; 1，返回输出数组 output ，其中 output[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积。
示例:
输入: [1,2,3,4]输出: [24,12,8,6]提示: 题目数据保证数组之中任意元素的全部前缀元素和后缀（甚至是整个数组）的乘积都在 32 位整数范围内。
说明: 请 不要使用除法，且在 O(n) 时间复杂度内完成此题。
进阶： 你可以在常数空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组不被视为额外空间。）
/** * Note: The returned array must be malloced, assume caller calls free(). */ int* productExceptSelf(int* nums, int numsSize, int* returnSize){ *returnSize = numsSize; int * result = malloc(sizeof(int)*numsSize); for (int i =0;i&amp;lt;numsSize;i++){ int left = 1; for(int j =0;j&amp;lt;=i-1;j++){ left *= nums[j]; } int right =1; for (int j =i+1;j&amp;lt;numsSize;j++){ right *=nums[j]; } result[i] = left*right; } return result; } int* productExceptSelf(int* nums, int numsSize, int* returnSize){ int *result = malloc(sizeof(int)*numsSize); int *lefts = malloc(sizeof(int)*numsSize); lefts[0]=1; for(int i =1;i&amp;lt;numsSize;i++){ lefts[i] = lefts[i-1]*nums[i-1]; } int *rights = malloc(sizeof(int)*numsSize); rights[numsSize-1]=1; for(int i =numsSize-2;i&amp;gt;=0;i--){ rights[i] = rights[i+1]*nums[i+1]; } // 这个for可以放在上面，right[i] 算完了就可以算result[i]了，然后少一个for循环  for (int i =0;i&amp;lt;numsSize;i++){ result[i] = lefts[i]*rights[i]; } *returnSize = numsSize; return result; } 题目问能不能不要额外的空间，然后返回的空间不算，因此我们先第一步简化</description>
    </item>
    
    <item>
      <title>Leetcode 525 连续数组</title>
      <link>https://Lu0key.github.io/post/leetcode-525-contiguous-array/</link>
      <pubDate>Tue, 23 Mar 2021 14:24:43 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/leetcode-525-contiguous-array/</guid>
      <description>连续数组(Contiguous Array) 给定一个二进制数组, 找到含有相同数量的 0 和 1 的最长连续子数组（的长度）。
示例 1:
输入: [0,1]输出: 2说明: [0, 1] 是具有相同数量0和1的最长连续子数组。示例 2:
输入: [0,1,0]输出: 2说明: [0, 1] (或 [1, 0]) 是具有相同数量0和1的最长连续子数组。注意: 给定的二进制数组的长度不会超过50000。
最粗暴的方式
int count0(int i,int j,int *nums) { int count = 0; for (int k =i; k&amp;lt;=j;k++){ if(nums[k] == 0){ count++; } } return count; } int count1(int i,int j,int *nums) { int count = 0; for (int k =i; k&amp;lt;=j;k++){ if(nums[k] == 1){ count++; } } return count; } int findMaxLength(int* nums, int numsSize){ int maxLength = 0; for (int i =0;i&amp;lt;numsSize;i++){ for(int j =i;j&amp;lt;numsSize;j++){ if(count0(i,j,nums) == count1(i,j,nums)){ int length = j-i+1; if (length &amp;gt; maxLength){ maxLength = length; } } } } return maxLength; } 但是这样会超时，毕竟O(n^3)</description>
    </item>
    
    <item>
      <title>Leetcode 1046 最后一块石头的重量</title>
      <link>https://Lu0key.github.io/post/leetcode-1046-last-stone-weight/</link>
      <pubDate>Tue, 23 Mar 2021 14:21:07 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/leetcode-1046-last-stone-weight/</guid>
      <description>最后一块石头的重量(Last Stone Weight) 有一堆石头，每块石头的重量都是正整数。
每一回合，从中选出两块 最重的 石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x &amp;lt;= y。那么粉碎的可能结果如下：
 如果 x == y，那么两块石头都会被完全粉碎； 如果 x != y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。  最后，最多只会剩下一块石头。返回此石头的重量。如果没有石头剩下，就返回 0。
示例：
输入：[2,7,4,1,8,1]输出：1解释：先选出 7 和 8，得到 1，所以数组转换为 [2,4,1,1,1]，再选出 2 和 4，得到 2，所以数组转换为 [2,1,1,1]，接着是 2 和 1，得到 1，所以数组转换为 [1,1,1]，最后选出 1 和 1，得到 0，最终数组转换为 [1]，这就是最后剩下那块石头的重量。提示：
 1 &amp;lt;= stones.length &amp;lt;= 30 1 &amp;lt;= stones[i] &amp;lt;= 1000  int extractMax(int *stones, int stonesSize) { int max = stones[0]; // 获取最大数  for (int i=1;i&amp;lt;stonesSize;i++){ if (stones[i]&amp;gt;max){ max = stones[i]; } } // 将第一个最大数位置置为0  for(int i =0;i&amp;lt;stonesSize;i++){ if(stones[i] == max){ stones[i]=0; break; } } return max; } void insert(int *stones, int stonesSize, int value) { for (int i =0;i&amp;lt;stonesSize;i++){ if(stones[i] == 0){ stones[i] = value; break; } } } int lastStoneWeight(int* stones, int stonesSize){ while(true) { // 第一大  int y = extractMax(stones, stonesSize); // 第二大  int x = extractMax(stones, stonesSize); if(x == 0) { return y; } if(x!</description>
    </item>
    
    <item>
      <title>Leetcode 543 Diameter of Binary Tree</title>
      <link>https://Lu0key.github.io/post/leetcode-543-diameter-of-binary-tree/</link>
      <pubDate>Sat, 20 Mar 2021 13:26:27 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/leetcode-543-diameter-of-binary-tree/</guid>
      <description>二叉树的直径(Diameter of Binary Tree) 给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。
示例 : 给定二叉树
 1/ \2 3/ \ 4 5 返回 3, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。
注意：两结点之间的路径长度是以它们之间边的数目表示。
/** * Definition for a binary tree node. * struct TreeNode { * int val; * struct TreeNode *left; * struct TreeNode *right; * }; */ int maxDepth(struct TreeNode * root){ if (root == NULL) return 0; int leftMax = maxDepth(root-&amp;gt;left); int rightMax = maxDepth(root-&amp;gt;right); if(leftMax&amp;gt;rightMax){ return leftMax+1; } return rightMax+1; } int diameterOfBinaryTree(struct TreeNode* root){ if (root == NULL) return 0; int middle = maxDepth(root-&amp;gt;left) + maxDepth(root-&amp;gt;right); int left = diameterOfBinaryTree(root-&amp;gt;left); int right = diameterOfBinaryTree(root-&amp;gt;right); int max = middle; if (left &amp;gt; max){ max = left; } if(right &amp;gt; max){ max = right; } return max; } 二叉树的最大深度(Maximum Depth of Binary Tree) 给定一个二叉树，找出其最大深度。</description>
    </item>
    
    <item>
      <title>Leetcode 155 Min Stack</title>
      <link>https://Lu0key.github.io/post/leetcode-155-min-stack/</link>
      <pubDate>Sat, 20 Mar 2021 13:22:09 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/leetcode-155-min-stack/</guid>
      <description>最小栈(Min Stack) 设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。
push(x) —— 将元素 x 推入栈中。pop() —— 删除栈顶的元素。top() —— 获取栈顶元素。getMin() —— 检索栈中的最小元素。 示例:
输入：[&amp;quot;MinStack&amp;quot;,&amp;quot;push&amp;quot;,&amp;quot;push&amp;quot;,&amp;quot;push&amp;quot;,&amp;quot;getMin&amp;quot;,&amp;quot;pop&amp;quot;,&amp;quot;top&amp;quot;,&amp;quot;getMin&amp;quot;][[],[-2],[0],[-3],[],[],[],[]]输出：[null,null,null,null,-3,null,0,-2]解释：MinStack minStack = new MinStack();minStack.push(-2);minStack.push(0);minStack.push(-3);minStack.getMin(); --&amp;gt; 返回 -3.minStack.pop();minStack.top(); --&amp;gt; 返回 0.minStack.getMin(); --&amp;gt; 返回 -2.提示：
 pop、top 和 getMin 操作总是在 非空栈 上调用。  C语言版:
/** * Your MinStack struct will be instantiated and called as such: * MinStack* obj = minStackCreate(); * minStackPush(obj, val); * minStackPop(obj); * int param_3 = minStackTop(obj); * int param_4 = minStackGetMin(obj); * minStackFree(obj); */ typedef struct { int * data; int * mins; int size; } MinStack; /** initialize your data structure here.</description>
    </item>
    
    <item>
      <title>Leetcode Backspace String Compare</title>
      <link>https://Lu0key.github.io/post/leetcode-backspace-string-compare/</link>
      <pubDate>Fri, 19 Mar 2021 17:42:46 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/leetcode-backspace-string-compare/</guid>
      <description>比较含退格的字符串(Backspace String Compare) 给定 S 和 T 两个字符串，当它们分别被输入到空白的文本编辑器后，判断二者是否相等，并返回结果。 # 代表退格字符。
注意：如果对空文本输入退格字符，文本继续为空。
示例 1：
输入：S = &amp;quot;ab#c&amp;quot;, T = &amp;quot;ad#c&amp;quot;输出：true解释：S 和 T 都会变成 “ac”。示例 2：
输入：S = &amp;quot;ab##&amp;quot;, T = &amp;quot;c#d#&amp;quot;输出：true解释：S 和 T 都会变成 “”。示例 3：
输入：S = &amp;quot;a##c&amp;quot;, T = &amp;quot;#a#c&amp;quot;输出：true解释：S 和 T 都会变成 “c”。示例 4：
输入：S = &amp;quot;a#c&amp;quot;, T = &amp;quot;b&amp;quot;输出：false解释：S 会变成 “c”，但 T 仍然是 “b”。提示：
 1 &amp;lt;= S.</description>
    </item>
    
    <item>
      <title>Leetcode 876 Middle of the Linked List</title>
      <link>https://Lu0key.github.io/post/leetcode-876-middle-of-the-linked-list/</link>
      <pubDate>Fri, 19 Mar 2021 16:54:41 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/leetcode-876-middle-of-the-linked-list/</guid>
      <description>链表的中间结点(Middle Of The Linked List) 给定一个头结点为 head 的非空单链表，返回链表的中间结点。
如果有两个中间结点，则返回第二个中间结点。
示例 1：
输入：[1,2,3,4,5]输出：此列表中的结点 3 (序列化形式：[3,4,5])返回的结点值为 3 。 (测评系统对该结点序列化表述是 [3,4,5])。注意，我们返回了一个 ListNode 类型的对象 ans，这样：ans.val = 3, ans.next.val = 4, ans.next.next.val = 5, 以及 ans.next.next.next = NULL.示例 2：
输入：[1,2,3,4,5,6]输出：此列表中的结点 4 (序列化形式：[4,5,6])由于该列表有两个中间结点，值分别为 3 和 4，我们返回第二个结点。提示：
 给定链表的结点数介于 1 和 100 之间。  C语言版:
/** * Definition for singly-linked list. * struct ListNode { * int val; * struct ListNode *next; * }; */ struct ListNode * middleNode(struct ListNode* head){ int length = 1; struct ListNode* curr = head; while(curr-&amp;gt;next!</description>
    </item>
    
    <item>
      <title>Leetcode 49 Group Anagrams</title>
      <link>https://Lu0key.github.io/post/leetcode-49-group-anagrams/</link>
      <pubDate>Tue, 16 Mar 2021 16:50:13 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/leetcode-49-group-anagrams/</guid>
      <description>字母异位词分组(Group Anagrams) 给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。
示例:
输入: [&amp;quot;eat&amp;quot;, &amp;quot;tea&amp;quot;, &amp;quot;tan&amp;quot;, &amp;quot;ate&amp;quot;, &amp;quot;nat&amp;quot;, &amp;quot;bat&amp;quot;]输出:[[&amp;quot;ate&amp;quot;,&amp;quot;eat&amp;quot;,&amp;quot;tea&amp;quot;],[&amp;quot;nat&amp;quot;,&amp;quot;tan&amp;quot;],[&amp;quot;bat&amp;quot;]]说明：
 所有输入均为小写字母。 不考虑答案输出的顺序。  C语言版:
/** * Return an array of arrays of size *returnSize. * The sizes of the arrays are returned as *returnColumnSizes array. * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free(). */ int cmpChar(const void*a ,const void *b){ return *(const char*)a - *(const char *)b; } typedef struct { char * original; char * sorted; }Pair; int cmpPair(const void * a, const void * b){ const Pair * pa = (const Pair *)a; const Pair * pb = (const Pair *)b; return strcmp(pa-&amp;gt;sorted, pb-&amp;gt;sorted); } char *** groupAnagrams(char ** strs, int strsSize, int* returnSize, int** returnColumnSizes){ Pair* pairs = malloc(sizeof(Pair)*strsSize); for(int i =0;i&amp;lt;strsSize;i++){ char *sorted_str = malloc(sizeof(char)*strlen(strs[i])+1); strcpy(sorted_str,strs[i]); qsort(sorted_str, strlen(strs[i]),sizeof(char),cmpChar); pairs[i].</description>
    </item>
    
    <item>
      <title>积分练习 3</title>
      <link>https://Lu0key.github.io/post/%E7%A7%AF%E5%88%86%E7%BB%83%E4%B9%A0-3/</link>
      <pubDate>Tue, 16 Mar 2021 12:21:54 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/%E7%A7%AF%E5%88%86%E7%BB%83%E4%B9%A0-3/</guid>
      <description>积分练习 3 1 $$ I=\int_2^{\infty}\dfrac{e^{-\sqrt{x}}}{(\sqrt{x}-1)^2}\text{d}x $$
【Sol】:
$\begin{aligned} I=&amp;amp;\int_{\sqrt{2}}^{\infty}\dfrac{e^{-x}}{(x-1)^2}(2x\text{d}x)\\
=&amp;amp;2\int_{\sqrt{2}}^{\infty}\dfrac{xe^{-x}}{(x-1)^2}\text{d}x\\
=&amp;amp;2\int_{\sqrt{2}-1}^{\infty}\dfrac{x+1}{x^2}e^{-x-1}\text{d}x\\
=&amp;amp;\dfrac{2}{e}\int_{\sqrt{2}-1}^{\infty}(x+1)e^{-x}\text{d}\left(-\dfrac{1}{x}\right)\\
=&amp;amp;\dfrac{2}{e}\left[-\dfrac{x+1}{x}e^{-x}\bigg|_{\sqrt{2}-1}^{\infty}+\int_{\sqrt{2}-1}^{\infty}\dfrac{1}{x}(-x)e^{-x}\text{d}x\right]\\
=&amp;amp;\dfrac{2}{e}\left[\dfrac{\sqrt{2}}{\sqrt{2}-1}e^{1-\sqrt{2}}-\int_{\sqrt{2}-1}^{\infty}e^{-x}\text{d}x\right]\\
=&amp;amp;\dfrac{2}{e}\left[\sqrt{2}(\sqrt{2}+1)e^{1-\sqrt{2}}-e^{1-\sqrt{2}}\right]\\
=&amp;amp;2(\sqrt{2}+1)e^{-\sqrt{2}} \end{aligned}$
 2 $$ I=\int_0^1\dfrac{1}{1+\sqrt{2x\sqrt{1-x^2}}}\text{d}x $$
【Sol】:
利用公式
$$ \int_0^1f(2x\sqrt{1-x^2})\text{d}x=\int_0^1f(1-x^2)\text{d}x $$ 于是有:
$\begin{aligned} I=&amp;amp;\int_0^1\dfrac{1}{1+\sqrt{1-x^2}}\text{d}x\\
=&amp;amp;\int_0^{\frac{\pi}{2}}\dfrac{1}{1+\cos x}\text{d}(\sin x)\\
=&amp;amp;\int_0^{\frac{\pi}{2}}\left[1-\dfrac{1}{1+\cos x}\right]\text{d}x\
=&amp;amp;\dfrac{\pi}{2}-\dfrac{\sin x}{1+\cos x}\bigg|_{0}^{\frac{\pi}{2}}\
=&amp;amp;\dfrac{\pi}{2}-1 \end{aligned}$
 3 $$ I=\int_{0}^{2\pi}\dfrac{\sin^2x}{5+4\cos x}\text{d}x=\dfrac{\pi}{4} $$
【Sol】:
被积函数是周期为 $2\pi$ 的偶函数，因此可以将区间移动到对称区间 $[-\pi,; \pi]$ 上:
$$ I=\int_{-\pi}^{\pi}\dfrac{\sin^2x}{5+4\cos x}\text{d}x=2\int_{0}^{\pi}\dfrac{\sin^2x}{5+4\cos x}\text{d}x $$
又余弦函数在 $[0,; \pi]$ 上不对称，因此
$\begin{aligned} I=&amp;amp;2\left[\int_0^{\frac{\pi}{2}}\dfrac{\sin^2x}{5+\cos x}\text{d}x+\int_{\frac{\pi}{2}}^{\pi}\dfrac{\sin^2x}{5+4\cos x}\text{d}x\right]\\
=&amp;amp;2\left[\int_0^{\frac{\pi}{2}}\dfrac{\sin^2x}{5+4\cos x}\text{d}x+\int_{0}^{\frac{\pi}{2}}\dfrac{\cos^2x}{5-4\sin x}\text{d}x\right]\\
=&amp;amp;2\int_0^{\frac{\pi}{2}}\left[\dfrac{\sin^2x}{5+4\cos x}+\dfrac{\sin^2x}{5-4\cos x}\right]\text{d}x\\</description>
    </item>
    
    <item>
      <title>Leetcode 122 Best Time to Buy and Sell Stock Ii</title>
      <link>https://Lu0key.github.io/post/leetcode-122-best-time-to-buy-and-sell-stock-ii/</link>
      <pubDate>Tue, 16 Mar 2021 00:05:57 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/leetcode-122-best-time-to-buy-and-sell-stock-ii/</guid>
      <description>买卖股票的最佳时机II(Best Time To Buy And Sell Stock II) 给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。
设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。
注意: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
示例 1:
输入: [7,1,5,3,6,4]输出: 7解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。示例 2:
输入: [1,2,3,4,5]输出: 4解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。示例 3:</description>
    </item>
    
    <item>
      <title>Leetcode 283 Move Zeroes</title>
      <link>https://Lu0key.github.io/post/leetcode-283-move-zeroes/</link>
      <pubDate>Mon, 15 Mar 2021 16:56:34 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/leetcode-283-move-zeroes/</guid>
      <description>移动零(Move Zeroes) 给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。
示例:
输入: [0,1,0,3,12]输出: [1,3,12,0,0]说明:
 必须在原数组上操作，不能拷贝额外的数组。 尽量减少操作次数。  C语言版本:
void moveZeroes(int* nums, int numsSize){ while(true){ int count = 0; for (int i =0;i+1&amp;lt;numsSize;i++) { if(nums[i]==0 &amp;amp;&amp;amp; nums[i+1]!=0) { count++; int temp = nums[i]; nums[i] = nums[i+1]; nums[i+1] = temp; break; } } if (count==0)break; } } 这样会超时，去掉第一个break就能过
模仿冒泡排序:
void moveZeroes(int* nums, int numsSize){ for (int k=0;k&amp;lt;numsSize;k++){ for(int i=0;i+1&amp;lt;numsSize;i++){ if(nums[i] == 0 &amp;amp;&amp;amp; nums[i+1] !</description>
    </item>
    
    <item>
      <title>Leetcode 53 Maximum Subarray</title>
      <link>https://Lu0key.github.io/post/leetcode-53-maximum-subarray/</link>
      <pubDate>Mon, 15 Mar 2021 16:02:01 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/leetcode-53-maximum-subarray/</guid>
      <description>最大子序和(Maximum Subarray) 给定一个整数数组 nums，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
示例 1：
输入：nums = [-2,1,-3,4,-1,2,1,-5,4]输出：6解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。示例 2：
输入：nums = [1]输出：1示例 3：
输入：nums = [0]输出：0示例 4：
输入：nums = [-1]输出：-1示例 5：
输入：nums = [-100000]输出：-100000提示：
 $1\leqslant nums.length \leqslant 3 * 10^5$ $-10^5 \leqslant nums[i] \leqslant 10^5$  进阶：如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的 分治法 求解。
C语言版本:
int maxSubArray(int* nums, int numsSize){ int max=nums[0]; for (int i=0; i &amp;lt;numsSize;i++) { for (int j =i;j&amp;lt;numsSize;j++){ int sum = 0; for (int k =i;k&amp;lt;=j;k++){ sum += nums[k]; } if (sum&amp;gt;max){ max = sum; } } } return max; } 用这种方法会超时</description>
    </item>
    
    <item>
      <title>Leetcode 202 Happy Number</title>
      <link>https://Lu0key.github.io/post/leetcode-202-happy-number/</link>
      <pubDate>Mon, 15 Mar 2021 15:27:25 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/leetcode-202-happy-number/</guid>
      <description>快乐数(Happy Number) 编写一个算法来判断一个数 n 是不是快乐数。
「快乐数」定义为：
 对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。 然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。 如果 可以变为 1，那么这个数就是快乐数。  如果 n 是快乐数就返回 true ；不是，则返回 false 。
示例 1：
输入：19输出：true解释：1² + 9² = 828² + 2² = 686² + 8² = 1001² + 0² + 0² = 1示例 2：
输入：n = 2解释：2² = 44² = 161² + 6² = 373² + 7² = 585² + 8² = 898² + 9² = 1451² + 4² + 5² = 424² + 2² = 202² + 0² = 4 循环了，永远不会到1输出：false提示：</description>
    </item>
    
    <item>
      <title>Leetcode 136 Single Number</title>
      <link>https://Lu0key.github.io/post/leetcode-136-single-number/</link>
      <pubDate>Mon, 15 Mar 2021 14:36:31 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/leetcode-136-single-number/</guid>
      <description>只出现一次的数字(Single Number) 给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。
说明：
你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？
示例 1:
输入: [2,2,1]输出: 1示例 2:
输入: [4,1,2,1,2]输出: 4C的解法:
int singleNumber(int* nums, int numsSize){ for (int i =0;i&amp;lt;numsSize;i++){ int count = 0; for (int j=0;j&amp;lt;numsSize;j++){ if(nums[j]==nums[i]){ count++; } if(count==2)break; } if(count==1){ return nums[i]; } } return -1; } 用位运算:
int singleNumber(int* nums, int numsSize){ int n =nums[0]; for (int i =1;i&amp;lt;numsSize;i++){ n ^= nums[i]; } return n; } 之后再补Java的写法，都是类似的</description>
    </item>
    
    <item>
      <title>两道有意思的数列极限</title>
      <link>https://Lu0key.github.io/post/%E4%B8%A4%E9%81%93%E6%9C%89%E6%84%8F%E6%80%9D%E7%9A%84%E6%95%B0%E5%88%97%E6%9E%81%E9%99%90/</link>
      <pubDate>Thu, 11 Mar 2021 09:22:08 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/%E4%B8%A4%E9%81%93%E6%9C%89%E6%84%8F%E6%80%9D%E7%9A%84%E6%95%B0%E5%88%97%E6%9E%81%E9%99%90/</guid>
      <description>两道有意思的数列极限 1 设 $a_1=\sqrt{\dfrac{1}{2}},\; a_n=\sqrt{\dfrac{1+a_{n-1}}{2}}$，求 $\displaystyle\lim_{n\to\infty}a_1a_2\cdots a_n$.
【Sol】: $a_!=\cos\dfrac{\pi}{4},\;a_2=\sqrt{\dfrac{1+\cos\frac{\pi}{4}}{2}}=\sqrt{\cos^2\dfrac{\pi}{4\cdot2}}=\cos\dfrac{\pi}{4\cdot2},\;a_3\sqrt{\dfrac{1+a_3}{2}}=\cos\dfrac{\pi}{4\cdot2^2},\;\cdots,\;a_n=\cos\dfrac{\pi}{4\cdot2^{n-1}}$
因此
$\begin{aligned} &amp;amp;\lim_{n\to\infty}a_1a_2\cdots a_n\\
=&amp;amp;\lim_{n\to\infty}\cos\dfrac{\pi}{4}\cdot\cos\dfrac{\pi}{4\cdot2}\cdot\cdots\cos\dfrac{\pi}{4\cdot2^{n-1}}\\
=&amp;amp;\lim_{n\to\infty}\dfrac{\cos\dfrac{\pi}{4}\cdot\cos\dfrac{\pi}{4\cdot2}\cdot\cdots\cos\dfrac{\pi}{4\cdot2^{n-1}}(2\sin\dfrac{\pi}{4\cdot2^{n-1}})}{2\sin\dfrac{\pi}{4\cdot2^{n-1}}}\\
=&amp;amp;\lim_{n\to\infty}\dfrac{\cos\dfrac{\pi}{4}\cdot\cos\dfrac{\pi}{4\cdot2}\cdot\cdots\cos\dfrac{\pi}{4\cdot2^{n-2}}\cdot\sin\dfrac{\pi}{4\cdot2^{n-2}}}{2\sin\dfrac{\pi}{4\cdot2^{n-1}}}\\
=&amp;amp;\lim_{n\to\infty}\dfrac{\sin\dfrac{\pi}{2}}{2^{n}\sin\dfrac{\pi}{4\cdot2^{n-1}}}\\
=&amp;amp;\lim_{n\to\infty}\dfrac{1}{2^n\cdot\dfrac{\pi}{2^{n+1}}}\\
=&amp;amp;\dfrac{2}{\pi} \end{aligned}$
这里将 $\sqrt{\dfrac{1}{2}}=\cos\dfrac{\pi}{4}$ 如果是第一次见的话可能比较难以想到.
 2 设 $a_1=1,\;a_n=a_{n-1}+\dfrac{1}{a_{n-1}}(n\geqslant2)$，求
$$ \lim_{n\to\infty}\dfrac{\sqrt{2n}(a_n-\sqrt{2n})}{\ln n} $$
【Sol】:
(1) 由于 $a_1&amp;gt;0$ 因此 ${a_n}$ 为单调递增序列，且趋向于无穷大.
$a_{n+1}^2=a_{n}^2+\dfrac{1}{a_{n}^2}+2$
(2) $\displaystyle\lim_{n\to\infty}\dfrac{a_{n}^2}{2n}\xlongequal{\text{Stolz}}\lim_{n\to\infty}\dfrac{a_{n+1}^2-a_{n}^2}{2}=\lim_{n\to\infty}\dfrac{\dfrac{1}{a_n}^2+2}{2}=1\Rightarrow \lim_{n\to\infty}\dfrac{a_n}{\sqrt{2n}}=1$.
(3)
$\begin{aligned} &amp;amp;\lim_{n\to\infty}\dfrac{\sqrt{2n}(a_n-\sqrt{2n})}{\ln n}\\
=&amp;amp;\lim_{n\to\infty}\dfrac{\sqrt{2n}(a_{n}^2-2n)}{\ln n(a_n+\sqrt{2n})}\\
=&amp;amp;\lim_{n\to\infty}\dfrac{\sqrt{2n}}{a_n+\sqrt{2n}}\cdot\lim_{n\to\infty}\dfrac{a_n^2-2n}{\ln n}\\
\xlongequal{\text{Stolz}}&amp;amp;\dfrac{1}{2}\lim_{n\to\infty}\dfrac{a_{n+1}^2-a_{n}^2-2}{\ln(n+1)-\ln n}\\
=&amp;amp;\dfrac{1}{2}\lim_{n\to\infty}\dfrac{\dfrac{1}{a_n^2}}{\dfrac{1}{n}}\\
=&amp;amp;\dfrac{1}{2}\lim_{n\to\infty}\dfrac{n}{a_n^2}=\dfrac{1}{2}\times\dfrac{1}{2}=\dfrac{1}{4} \end{aligned}$
这题的解答来自一位群友，MSE上有老哥写的更长的渐进展开.</description>
    </item>
    
    <item>
      <title>积分练习 2</title>
      <link>https://Lu0key.github.io/post/%E7%A7%AF%E5%88%86%E7%BB%83%E4%B9%A0-2/</link>
      <pubDate>Tue, 09 Mar 2021 23:08:29 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/%E7%A7%AF%E5%88%86%E7%BB%83%E4%B9%A0-2/</guid>
      <description>积分练习 2 1 求积分 $$ I=\int_0^1\dfrac{x\ln(1+x)}{(1+x^2)^2}\text{d}x\
$$
【Sol】:
$\begin{aligned} I=&amp;amp;\int_0^1\ln(1+x)\text{d}\left[-\dfrac{1}{2(1+x^2)} \right]\\
=&amp;amp;-\dfrac{\ln(1+x)}{2(1+x^2)}\bigg|_0^1+\dfrac{1}{2}\int_0^1\dfrac{1}{(1+x^2)(1+x)}\text{d}x\\
=&amp;amp;-\dfrac{1}{4}\ln2+\dfrac{1}{4}\int_0^1\left[\dfrac{1}{1+x}+\dfrac{1-x}{1+x^2} \right]\\
=&amp;amp;-\dfrac{1}{4}\ln2+\dfrac{1}{4}\left[\ln(1+x)+\arctan x-\dfrac{1}{2}\ln(1+x^2) \right]\bigg|_0^1\\
=&amp;amp;-\dfrac{1}{8}\ln2+\dfrac{\pi}{16} \end{aligned}$
 2 求积分 $$ I=\int_0^{\infty} \dfrac{e^{-x}-e^{-2x}}{x}\sin x\text{d}x $$
【Sol】: 用拉普拉斯变换求
令 $f(x)=(e^{-x}-e^{-2x})\sin x$
$F(x)=\dfrac{1}{(x+1)^2+1}-\dfrac{1}{(x+2)^2+1}$
$\begin{aligned} I=&amp;amp;\int_0^{\infty}\left[\dfrac{1}{(x+1)^2+1}-\dfrac{1}{(x+2)^2+1} \right]\text{d}x\\
=&amp;amp;\left[\arctan(x+1)-\arctan(x+2) \right]\bigg|_{0}^{\infty}\\
=&amp;amp;\arctan 2-\dfrac{\pi}{4} \end{aligned}$
 3 求积分
$$ I=\int_0^1\dfrac{\ln(x+\sqrt{1-x^2})}{x}\text{d}x $$
【Sol】: 考虑含参积分
$\displaystyle I(a)=\int_0^1\dfrac{\ln(xa+\sqrt{1-x^2})}{x}\text{d}x,;;I=I(1)$
$\begin{aligned} I(0)=&amp;amp;\int_0^{1}\dfrac{\ln\sqrt{1-x^2}}{x}\text{d}x\\
=&amp;amp;\dfrac{1}{2}\left[\int_0^1\dfrac{\ln(1+x)}{x}\text{d}x+\int_0^{1}\dfrac{\ln(1-x)}{x}\text{d}x \right]\\
=&amp;amp;\dfrac{1}{2}\left[\dfrac{\pi^2}{12}-\dfrac{\pi^2}{6} \right]\\
=&amp;amp;-\dfrac{\pi^2}{24} \end{aligned}$
$\begin{aligned} I&#39;(a)=&amp;amp;\int_0^1\dfrac{1}{xa+\sqrt{1-x^2}}\text{d}x\\
=&amp;amp;\int_0^{\frac{\pi}{2}}\dfrac{1}{a\sin t+\cos t}\cos t\text{d}t\\
=&amp;amp;\dfrac{1}{a^2+1}\left[ \int_0^{\frac{\pi}{2}}\dfrac{(a\sin t+\cos t)+a(a\cos t-\sin t)}{a\sin t+\cos t}\text{d}t\right]\\</description>
    </item>
    
    <item>
      <title>积分练习 1</title>
      <link>https://Lu0key.github.io/post/%E7%A7%AF%E5%88%86%E7%BB%83%E4%B9%A0-1/</link>
      <pubDate>Tue, 09 Mar 2021 14:35:58 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/%E7%A7%AF%E5%88%86%E7%BB%83%E4%B9%A0-1/</guid>
      <description>积分练习 1 1 求积分 $$ I=\int_0^{\frac{\pi}{2}}\sin x\ln\sin x\text{d}x $$
【Sol】:
$\begin{aligned} I=&amp;amp;\int_0^{\frac{\pi}{2}}\cos x\ln\cos x\text{d}x\\
=&amp;amp;\int_0^{\frac{\pi}{2}}\ln\cos x\text{d}(\sin x-1)\\
=&amp;amp;(\sin x-1)\ln\cos x\bigg|_{0}^{\frac{\pi}{2}}-\int_0^{\frac{\pi}{2}}(\sin x-1)\text{d}(\ln \cos x)\\
=&amp;amp;0-0-\int_0^{\frac{\pi}{2}}\sin x\text{d}(\ln\cos x)+\ln\cos x\bigg|_0^{\frac{\pi}{2}} \end{aligned}$
令 $\displaystyle J=-\int_0^{\frac{\pi}{2}}\sin x\text{d}(\ln\cos x)$
$\begin{aligned} J=&amp;amp;\int_0^{\frac{\pi}{2}}\sin x\tan x\text{d}x\\
=&amp;amp;\int_0^{\frac{\pi}{2}}\dfrac{\sin^2x}{\cos x}\text{d}x\\
=&amp;amp;\int_0^{\frac{\pi}{2}}\dfrac{1-\cos^2x}{\cos x}\text{d}x\\
=&amp;amp;\left[\ln|\sec x+\tan x|-\sin x\right]\bigg|_0^{\frac{\pi}{2}} \end{aligned}$
因此
$\begin{aligned} I=&amp;amp;J+\ln\cos x\bigg|_ 0^{\frac{\pi}{2}}\\
=&amp;amp;\left[\ln|\sec x+\tan x|-\sin x\right] \bigg|_{0}^{ \frac{\pi}{2}} +\ln\cos x\bigg|_{0}^{\frac{\pi}{2}}\\
=&amp;amp;\left[\ln|1+\sin x|-\sin x\right]\bigg|_0^{\frac{\pi}{2}}\\
=&amp;amp;\ln 2-1 \end{aligned}$
 2 $$ I=\int_0^1\dfrac{x\ln x}{\sqrt{1-x^2}}\text{d}x $$</description>
    </item>
    
    <item>
      <title>Listings 笔记</title>
      <link>https://Lu0key.github.io/post/listings-%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Thu, 04 Mar 2021 19:37:06 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/listings-%E7%AC%94%E8%AE%B0/</guid>
      <description>listings 笔记 虽然是使用listings宏包，但是在使用环境的时候是使用lstlisting
basicstyle = &amp;lt;basic style&amp;gt;
可以在每个列表的开头选择. 你可以使用 \footnotesize, \small, \itshape, \ttfamily,或者其他的. The last token of &amp;lt;basic style&amp;gt; 的最后一个标记不能读取以下任何字符(这一句翻译的怪怪的).
如果你发现你的代码没有自动换行，可以加上这句
breaklines=true 我们再设定一下代码块的语言和样式
language=Java, keywordstyle={\bfseries\color{NavyBlue}} 这边要把xcolor宏包引入
如果你觉得listings自带的关键字不够，可以自己手动添加关键字
morekeywords={String} 有些不是关键字，但是是重要的类，可以使用强调(同样的，想要强调明显，也需要给强调设置样式)
emph={Controller,@RequestParam,CommonsMultipartFile,HttpServletRequest,IOException,@Controller,OutputStream, InputStream, @RequestMapping, HttpServletResponse,@PostMapping,File}, emphstyle={\bfseries\color{Tan}} 这时候我们会发现不仅下面的代码强调了，连导入的包中对应的词都强调了，这是我们不想看见的，因此我们可以使用
alsoletter{.} 这样前面有点的强调字就不会被记录在被强调的里面了
效果如图
除此之外，我们还可以设置这些
backgroundcolor={\color{yellow!40!white}}, % 设置背景颜色 frame=shadowbox, % 设置边框 rulecolor={\color{purple}}, % 设置边框线条颜色 rulesepcolor={\color{orange}}, % 设置边框线条和代码块间的颜色 framesep=1em, % 设置代码块和边框的距离 numbers=left, % 设置代码行数的位置 numbersep=2em, % 设置代码行数离代码的距离 numberstyle={\sffamily\footnotesize} % 设置代码行数的样式 最后的效果如图所示， 如果我们需要写很多的代码块，那我们可以把公共的部分放在最前面的 \lstset 中
listings的demo
\begin{lstlisting}[ basicstyle=\ttfamily, breaklines=true, language=Java, morekeywords={String}, keywordstyle={\bfseries\color{NavyBlue}}, emph={Controller,@RequestParam,CommonsMultipartFile,HttpServletRequest,IOException,@Controller, OutputStream, InputStream, @RequestMapping, HttpServletResponse,@PostMapping,File}, emphstyle={\bfseries\color{Tan}}, alsoletter={.</description>
    </item>
    
    <item>
      <title>Test Image Bed</title>
      <link>https://Lu0key.github.io/post/test-image-bed/</link>
      <pubDate>Thu, 04 Mar 2021 00:20:24 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/test-image-bed/</guid>
      <description>测试 Github 的免费图床 这个是图片用https://carbon.now.sh/生成的
别的搜到的一些不太喜欢,比如http://www.planetb.ca/syntax-highlight-word
vscode 有个插件 Polacode，但是不知道为什么没用成功，下次再试试，左上角三个点是模仿苹果的，Polacode没有这三个点，好了先到这里，晚安
如果图床好用了，明天就写listings的笔记</description>
    </item>
    
    <item>
      <title>王道考研 数据结构 查找</title>
      <link>https://Lu0key.github.io/post/%E7%8E%8B%E9%81%93%E8%80%83%E7%A0%94-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%9F%A5%E6%89%BE/</link>
      <pubDate>Mon, 01 Mar 2021 08:27:27 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/%E7%8E%8B%E9%81%93%E8%80%83%E7%A0%94-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%9F%A5%E6%89%BE/</guid>
      <description>查找  查找  基本概念 顺序查找 折半查找 分块查找 B树 B树的插入和删除  插入 删除   B+树 散列查找  散列表(Hash Table) 开放定址法 平方探测法 伪随机序列法 再散列法      基本概念 查找：在数据集合中寻找满足某种条件的数据元素的过程称为查找
查找表(查找结构)：用于查找的数据集合称为查找表，它由同一类型的数据元素(或记录组成)
关键字：数据元素中唯一标识该元素的某个数据项的值，使用基于关键字的查找，查找结果应该是唯一的(比如学号)
常见操作
 查找符合条件的数据元素 插入、删除某个数据元素  如果只进行操作1——静态查找表即可
也要进行操作2——动态查找表
评价指标
查找长度：在查找运算中，需要对比关键字的次数称为查找长度
平均查找长度(ASL)：所有查找过程中进行关键字的比较次数的平均值
$\displaystyle ASL=\sum_{i=1}^nP_iC_i$
其中n为数据元素个数，C_i为查找第i个元素的查找长度，P_i为查找第i个元素的概率
ASL的数量级放映了查找算法时间复杂度
评价一个查找算法的效率时，通常考虑查找成功/失败两种情况的ASL
顺序查找 顺序查找，又叫“线性查找”，通常用于线性表(顺序表、链表)
算法思想：从头到尾一个一个对比
顺序查找的实现
// 查找表的数据结构(顺序表) typedef struct { // 动态数组的基址(剩下靠偏移量)  Elemtypr *elem; // 表的长度  int TableLen; }SSTable; // 顺序查找 int Search_Seq(SSTable ST, ElemType key) { int i; // for循环空语句  for (i=0;i&amp;lt;ST.</description>
    </item>
    
    <item>
      <title>王道考研 数据结构 图</title>
      <link>https://Lu0key.github.io/post/%E7%8E%8B%E9%81%93%E8%80%83%E7%A0%94-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/</link>
      <pubDate>Mon, 01 Mar 2021 08:22:55 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/%E7%8E%8B%E9%81%93%E8%80%83%E7%A0%94-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/</guid>
      <description>图  图  定义 图的存储  临接矩阵 邻接表 十字链表法 邻接多重表   基本操作 图的遍历  广度优先遍历 深度优先遍历   最小生成树 最短路径问题 Dijkstra算法 Floyd算法 有向无环图(DAG) 拓扑排序 关键路径    定义 图G由顶点集V和边集E组成，记为G=(V, E)，其中V(G) 表示图G中顶点的有限非空集；E(G) 表示图G 中顶点之间的关系（边）集合。若 $V={v_1, v_2, &amp;hellip;, v_n}$，则用 $|V|$ 表示图G 中顶点的个数，也称图G 的阶，$E={(u, v)|u\in V, v\in V}$，用 $|E|$ 表示图G中边的条数。
G：Graph
V：Vertex
E：Edge
线性表可以是空表，树可以是空树，但图不可以是空的，即V一定是非空集
e.g.
V:车站，E：铁路
社交软件中的好友关系可以看成是一种无向图
微博中的粉丝关系可以看作是一种有向图
若 E 是无向边（简称边）的有限集合时，则图 G 为无向图。边是顶点的无序对，记为 $(v, w)$ 或 $(w, v)$，因为 $(v, w)=(w, v)$，其中v，w 是顶点。可以说顶点w和顶点v互为邻接点。边 $(v, w)$ 依附于顶点 $w$ 和 $v$，或者说边 $(v, w)$ 和顶点 v、w 相关联。</description>
    </item>
    
    <item>
      <title>Python Selenium 笔记</title>
      <link>https://Lu0key.github.io/post/python-selenium/</link>
      <pubDate>Sun, 28 Feb 2021 19:30:33 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/python-selenium/</guid>
      <description>Python Selenium 笔记 这里用的是Firefox的 webdriver
browser = webdriver.Firefox(executable_path =r&amp;#34;D:\geckodriver&amp;#34;) 通过get打开网页
browser.get(&amp;#34;https://www.baidu.com&amp;#34;) 窗口最大化
browser.maximize_window() 输入内容
browser.find_element_by_id(&amp;#34;un&amp;#34;).send_keys(&amp;#34;学号&amp;#34;) 点击事件
browser.find_element_by_id(&amp;#34;index_login_btn&amp;#34;).click() close 和 quit 的区别
# close 是关闭当前tab browser.close() # quit 是关闭整个浏览器 browser.quit() 在自动化操作的时候可能会遇到多个标签页，这里我还不是很清楚，一个标签页对应一个句柄
# 获得所有句柄 handles = browser.window_handles # 获得当前句柄 currentWin = browser.current_window_handle 因为我在使用的时候，最多只会遇到两个标签页，多的标签页可以直接close掉，因此没有深究怎么切换到指定的标签页的方法，只要每次产生新的标签页的时候，我就把当前的标签页关掉，然后获得新标签页的句柄(因为只有一个标签页，因此句柄也只有一个)
# 假装这里打开了新的标签页 # 关闭当前标签页 browser.close() # 获得所有句柄(这时只有1个) handles = browser.window_handles # 切换到这个句柄上 browser.switch_to.window(handles[0]) 当页面中有iframe标签的时候，选择器无法选择到iframe中的内容，因此要切换到iframe内
# 这里只要获得了对应的iframe标签即可，比如用id也可以 iframe = browser.find_elements_by_tag_name(&amp;#34;iframe&amp;#34;)[0] # 切换到iframe中就可以用css选择器之类的去获取元素 browser.switch_to.frame(iframe) # 对iframe中的内容操作完了，返回原页面 browser.switch_to.default_content() </description>
    </item>
    
    <item>
      <title>Python 操作 Excel</title>
      <link>https://Lu0key.github.io/post/python-wr-excel/</link>
      <pubDate>Sun, 28 Feb 2021 18:37:37 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/python-wr-excel/</guid>
      <description>Python 处理excel 老师需要找出哪些同学在网上填了返校申请，因为有几百个人，所以比较难以肉眼看出来
这里我们假设填了信息的人可以导出名字，和整个年级的名单
这样我们就有两个表了，代码如下
import xlrd # 总的人名 name_set = [] # 填报的人 name_data = [] # 没填报的人 other = [] set_excel = xlrd.open_workbook(&amp;#39;C:\\Users\\Luokey\\Desktop\\set.xlsx&amp;#39;) set_sheet = set_excel.sheets()[0] print(set_sheet.name) print(&amp;#34;=============&amp;#34;) # 这里实际上是从第二行开始，到第一列的最后一个元素 for i in range(1,len(set_sheet.col_slice(0, start_rowx=0, end_rowx=None))): name = set_sheet.cell_value(i, 0) name_set.append(name) print(name_set) print(len(name_set)) data_excel = xlrd.open_workbook(&amp;#39;C:\\Users\\Luokey\\Desktop\\data.xlsx&amp;#39;) data_sheet = data_excel.sheets()[0] print(&amp;#34;=============&amp;#34;) # 这里实际上是从第二行开始，到第一列的最后一个元素 for i in range(1,len(data_sheet.col_slice(0, start_rowx=0, end_rowx=None))): name = data_sheet.cell_value(i, 0) name_data.append(name) print(&amp;#34;======没提交的名单=======&amp;#34;) for name in name_set: if name not in name_data: print(name) other.</description>
    </item>
    
    <item>
      <title>Spring5</title>
      <link>https://Lu0key.github.io/post/spring5/</link>
      <pubDate>Wed, 17 Feb 2021 22:18:45 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/spring5/</guid>
      <description>Spring Spring 简介  Spring理念：使现有的技术 更加容易使用，本身是一个大杂烩  SSH：Struct2+Spring+Hibernate
SSM：SpringMVC+Spring+Mybatis
官网：https://spring.io/projects/spring-framework
官方下载地址：https://repo.spring.io/release/org/springframework/spring/ Github：https://github.com/spring-projects/spring-framework
&amp;lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-webmvc&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;5.2.12.RELEASE&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-jdbc --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-jdbc&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;5.2.12.RELEASE&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; 优点  Spring是一个开源的免费的框架(容器) Spring是一个轻量级、非入侵式的框架 控制反转(IOC)，面向切面编程(AOP) 支持事务的处理，对框架整合的支持  总结：Spring是一个轻量级的控制反转(IOC)和面向切面变成(AOP)的框架！
组成 拓展  SpringBoot  一个快速开发的脚手架 基于SpringBoot可以快速地开发单个微服务、 约定大于配置   SpringCloud  SpringCloud 是基于 SpringBoot实现的    因为现在大多数公司都在使用SpringBoot进行快速开发，学习SpingBoot的前提，需要完全掌握Spring和SpringMVC。承上启下的作用
弊端：发展了太久之后，违背了原来的理念，配置十分繁琐，人称“配置地狱”
IOC理论推导  UserDao接口 UserDaoImpl 实现类 UserService 业务接口 UserServiceImpl 业务实现  在我们之前的业务中，用户的需求可能会影响我们原来的代码，我们需要根据用户的需求去修改原代码，如果程序代码量十分大，修改一次的成本十分高昂
我们使用一个Set接口实现，已经发生了革命性的变化
private UserDao userDao; public void setUserDao(UserDao userdao) { this.</description>
    </item>
    
    <item>
      <title>Mybatis</title>
      <link>https://Lu0key.github.io/post/mybatis/</link>
      <pubDate>Mon, 15 Feb 2021 22:05:30 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/mybatis/</guid>
      <description>MyBatis MyBatis官网
简介 什么是MaBatis？  MyBatis 是一款优秀的持久层框架 它支持自定义 SQL、存储过程以及高级映射。 MyBatis 免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作。 MyBatis 可以通过简单的 XML 或注解来配置和映射原始类型、接口和 Java POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。  如何获得MyBatis？
 github maven  &amp;lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis --&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.mybatis&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;mybatis&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;3.5.2&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; 持久化 数据持久化
 持久化就是将程序的数据在持久状态和瞬时状态转化的过程 内存：断电即失 数据库(JDBC)、IO文件持久化  为什么需要持久化？
 有一些数据，不能让他丢掉 内存太贵了  持久层  完成持久化工作的代码块 层界限十分明显  为什么需要MyBatis？  方便 传统的JDBC代码太复杂了。简化，框架 帮助程序员将数据存入到数据库中 不用MyBatis也可以，MyBatis更容易上手。技术没有高低之分 优点  sql和代码分离 更容易单元测试 提供xml标签，支持编写动态sql    最重要的一点：使用的人多</description>
    </item>
    
    <item>
      <title>王道考研 数据结构 串</title>
      <link>https://Lu0key.github.io/post/%E7%8E%8B%E9%81%93%E8%80%83%E7%A0%94-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%B8%B2/</link>
      <pubDate>Sat, 06 Feb 2021 22:10:51 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/%E7%8E%8B%E9%81%93%E8%80%83%E7%A0%94-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%B8%B2/</guid>
      <description>串  串  定义 存储结构  顺序存储 链式存储   基本操作  求子串 比较字符串 定位操作   朴素模式匹配算法 KMP 算法 KMP算法优化    定义 串，即字符串（String）是由零个或者多个字符组成的有限序列。一般记为 S = &amp;lsquo;a1a2&amp;hellip;a_n&amp;rsquo; ($n\geqslant0$)
其中，S是串名，单引号括起来的字符序列是串的值；$a_i$可以是字母、数字或者其他字符；串中字符的个数n称为串的长度。n=0 时的串称为空串（用 $\varnothing$ 表示）
字串：串中任意个连续的字符组成的子序列
主串：包含字串的串
字符在主串中的位置：字符在串中的序号
字串在主串中的位置：字串的第一个字符在主串中的位置
位序是从1开始，而不是0开始
串是一种特殊的线性表，数据元素之间呈线性关系
串的数据对象限定为字符集（如中文字符、英文字符、数字字符、标点字符等）
串的基本操作，如增删改查通常以字串为操作对象
串的基本操作
 StrAssign(&amp;amp;T, chars)：赋值操作，把串T赋值为chars StrCopy(&amp;amp;T, S)：复制操作。由串S复制得到串T StrEmpty(S)：判空操作。若S为空串，则返回true，否则返回false StrLength(S)：求串长，返回串S的元素个数 ClearString(&amp;amp;S)：清空操作。将S清为空串 DestroyString(&amp;amp;S)：销毁串。将串S销毁，回收存储空间 Concat(&amp;amp;T, S1, S2)：串联接。用T返回由S1和S2联接而成的新串 SubString(&amp;amp;sub, S, pos, len)：求字串，用sub但会串S的第pos个字符起长度为len的子串 Index(S, T)：定位操作。若主串S中存在与串T值相同的子串，则返回它在主串S中第一次出现的位置；否则函数值为0 StrCompare(S, T)：比较操作。若S&amp;gt;T，则返回值&amp;gt;0，若S=T，则返回值=0，若S&amp;lt; T，则返回值&amp;lt;0  这个比较是一个字符一个字符比较的，那字符怎么比较呢？
ASCII字符编码，将数字与字符一一对应，因此比较字符实际上就是比较字符对应的数字
乱码问题：
不同的编码规则可能会导致乱码</description>
    </item>
    
    <item>
      <title>王道考研 数据结构 栈和队列</title>
      <link>https://Lu0key.github.io/post/%E7%8E%8B%E9%81%93%E8%80%83%E7%A0%94-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/</link>
      <pubDate>Sat, 06 Feb 2021 22:08:19 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/%E7%8E%8B%E9%81%93%E8%80%83%E7%A0%94-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/</guid>
      <description>栈和队列  栈和队列  定义 顺序栈  顺序栈-进栈 顺序表-出栈 顺序栈-读栈 顺序栈-共享栈 栈的链式实现   队列  队列-顺序存储 队列-入队 队列-出队 队列的链式实现 双端队列   栈-括号匹配 栈-表达式求值  原理 代码   栈的应用-递归 队列的应用 特殊矩阵的压缩存储  对称矩阵 三角矩阵 三对角矩阵 稀疏矩阵      定义 栈(stack) 是只允许一端进行插入或删除操作的线性表（是同一端）.
重要术语
 栈顶 栈底 空栈  特点：LIFO（Last In First Out）后进的先出
基本操作
 InitStack(&amp;amp; S)：初始化栈。构造一个空栈S，分配内存空间。 DestroyStack(&amp;amp; S)：销毁栈。销毁并释放栈S所占的内存空间。 Push(&amp;amp;S, x)：进栈，若栈S未满，则将x加入使之成为新栈顶。 Pop(&amp;amp;S, &amp;amp;x)：出栈，若栈S非空，则弹出栈顶元素，并用x返回 GetTop(S, &amp;amp;x)：读栈顶元素。若栈S非空，则用x返回栈顶元素  栈的差一般只访问栈顶元素   StackEmpty(S)：判断一个栈S是否为空，若为空，则返回true，否则返回false。  常考题型：判断合法的出栈的顺序（要满足先进后出，后进先出）</description>
    </item>
    
    <item>
      <title>王道考研 数据结构 线性表</title>
      <link>https://Lu0key.github.io/post/%E7%8E%8B%E9%81%93%E8%80%83%E7%A0%94-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%80%A7%E8%A1%A8/</link>
      <pubDate>Sat, 06 Feb 2021 21:43:51 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/%E7%8E%8B%E9%81%93%E8%80%83%E7%A0%94-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%80%A7%E8%A1%A8/</guid>
      <description>线性表  线性表  定义 基本操作  其他常用操作 注 为什么需要实现基本操作   顺序表  顺序表的实现-静态分配 顺序表的实现-动态分配 特点 顺序表-插入 顺序表-删除 顺序表-按位查找 顺序表-按值查找 按值查找的时间复杂度   链表  定义 单链表-初始化 单链表-按位序插入 单链表-后插操作 单链表-前插操作 单链表-按位序删除 单链表-删除指定结点 单链表-按位查找 单链表-按值查找 单链表-获取长度 单链表-尾插法 单链表-头插法   双链表  初始化 双链表-插入 双链表-删除 双链表-遍历   循环链表  循环单链表 循环双链表   静态链表  静态链表-定义   顺序表和链表的比较    定义 线性表(Linear List)是具有相同数据类型的 n ($n\geqslant0$) 个数据元素的有限序列，其中 n 为表长，当 n=0 时线性表是一个空表。若用 L 命名线性表，则一般表示为 $$ L=(a_1, a_2,\cdots,a_j, a_{j+1},\cdots,a_n) $$ 相同：意味着每个数据元素所占空间一样大</description>
    </item>
    
    <item>
      <title>Git Commit错误修改</title>
      <link>https://Lu0key.github.io/post/git-commit%E9%94%99%E8%AF%AF%E4%BF%AE%E6%94%B9/</link>
      <pubDate>Sat, 06 Feb 2021 21:34:56 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/git-commit%E9%94%99%E8%AF%AF%E4%BF%AE%E6%94%B9/</guid>
      <description>git commit错误修改 在 git commit -m &amp;quot;message&amp;quot; 时，我们有时会不小心把 message 的信息写错，要怎么修改呢？
这时候分为两种情况
 已经git push了 还没git push  还没push 这种情况比较简单，直接使用
git commit --amend进入vim界面，按i进入insert模式，修改完错误的message后，按esc，输入:wq保存退出即可，最后再push
通过
git log可以看到记录是修改后的message
已经push 这种情况命令比较多一点，但是也是能够解决
先用 git log 查看是哪一次commit 的message需要修改，比如我是倒数第二次和第三次的commit都有一点问题，那么我们先修改倒数第二次的，先使用命令
git rebase -i HEAD^进入vim界面，按i进入insert模式，将需要修改message的那一行的pick改成edit，将message改成正确的，再按esc，输入 :wq 保存退出
输入命令
git commit --amend同样进入vim界面，按i进入insert模式，将第一行错误的message修改为正确的message，退出保存流程和上面一样
rebase确认命令
git rebase --continue最后强制push一下即可
git push -f查看git log会发现已经修改好了</description>
    </item>
    
    <item>
      <title>上交考研数分一题</title>
      <link>https://Lu0key.github.io/post/%E4%B8%8A%E4%BA%A4%E8%80%83%E7%A0%94%E6%95%B0%E5%88%86%E4%B8%80%E9%A2%98/</link>
      <pubDate>Fri, 22 Jan 2021 20:49:16 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/%E4%B8%8A%E4%BA%A4%E8%80%83%E7%A0%94%E6%95%B0%E5%88%86%E4%B8%80%E9%A2%98/</guid>
      <description>2021 上海交通大学硕士研究生入学考试数学分析第7题
求极限
$$ \lim_{x\to\infty}\dfrac{(1+\frac{1}{x})^x-e}{\sin\dfrac{1}{x}}
$$
Solution: $$\begin{aligned} &amp;amp;\lim_{x\to\infty}\dfrac{(1+\frac{1}{x})^x-e}{\sin\dfrac{1}{x}}\\
=&amp;amp;e\lim_{x\to\infty}\dfrac{e^{x\ln(1+\frac{1}{x})-1}-1}{\dfrac{1}{x}}\\
=&amp;amp;e\lim_{x\to\infty}x[x\ln(1+\dfrac{1}{x})-1]\\
=&amp;amp;e\lim_{x\to\infty}x[x(\dfrac{1}{x}-\dfrac{1}{2x^2}+o(\dfrac{1}{x^3}))-1]\\
=&amp;amp;-\dfrac{e}{2} \end{aligned}$$</description>
    </item>
    
    <item>
      <title>函数的不可积问题</title>
      <link>https://Lu0key.github.io/post/%E5%87%BD%E6%95%B0%E7%9A%84%E4%B8%8D%E5%8F%AF%E7%A7%AF%E9%97%AE%E9%A2%98/</link>
      <pubDate>Fri, 22 Jan 2021 20:32:15 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/%E5%87%BD%E6%95%B0%E7%9A%84%E4%B8%8D%E5%8F%AF%E7%A7%AF%E9%97%AE%E9%A2%98/</guid>
      <description>函数的“不可积”问题 这里的“不可积”指的是原函数不能表示成初等函数的形式
基本是搬运，但是忘记出处了
常见的“不可积”的例子 三角积分类 $\displaystyle\int\dfrac{\sin x}{x^n}\text{d}x,;\int\dfrac{\cos x}{x^n}\text{d}x,;\int\dfrac{\tan x}{x^n},;\int x^n\tan x\text{d}x$
$\displaystyle\int\left(\dfrac{x}{\sin x}\right)^n\text{d}x,;\int\left(\dfrac{x}{\cos x}\right)^n\text{d}x,;\int\left(\dfrac{x}{\tan x}\right)^n\text{d}x$
菲涅尔积分类型 $\displaystyle\int\sin x^2\text{d}x,;\int\cos x^2\text{d}x,;\int\tan x^2\text{d}x$
贝塞尔积分 $\displaystyle\int\cos(x\sin x)\text{d}x$
Laplace 积分 $\displaystyle\int\dfrac{\cos\beta x}{1+x^2}\text{d}x$
高斯积分类 $\displaystyle\int e^{ax^2+bx+c}\text{d}x$
$\displaystyle\int x^ne^{ax^2+bx+c}\text{d}x$
指数积分类型 $\displaystyle\int\dfrac{e^{ax}}{x}\text{d}x,;\int\dfrac{e^{ax}}{a+x^n}\text{d}x,;\int\dfrac{x^n}{1\pm e^x}\text{d}x$
对数积分类型 $\displaystyle\int\dfrac{\text{d}x}{\ln x},;\int\dfrac{\ln x\text{d}x}{1+x^2},;\int\ln\sin x\text{d}x,;\int\ln\cos x\text{d}x,;\int\ln\tan x\text{d}x$
$\displaystyle\int\ln(a+b\sin x)\text{d}x,;\int\ln(a+b\cos x)\text{d}x,\int\ln(a+b\tan x)\text{d}x$
$\displaystyle\int\ln\ln\sin x\text{d}x,;\int\ln\ln\cos x\text{d}x,;\int\ln\ln\tan x\text{d}x$
椭圆积分类 $\displaystyle\int\dfrac{1}{\sqrt{1-k^2\sin^2x}}\text{d}x,;\int\sqrt{1-k^2\sin^2x}\text{d}x$
$\displaystyle\int\dfrac{1}{\sqrt{1\pm x^n}}\text{d}x,;\int\sqrt{1\pm x^n}\text{d}x;(n\geqslant3)$
常见的特殊函数 Beta 函数 $\displaystyle\text{B}(p,q)=\int_0^1x^{p-1}(1-x)^{q-1}\text{d}x=\dfrac{\Gamma(p)\Gamma(q)}{\Gamma(p+q)},;(p,q&amp;gt;0)$
Gamma 函数 $\displaystyle\Gamma(s)=\int_0^{+\infty}x^{s-1}e^{-x}\text{d}x,;(s&amp;gt;0)$
误差函数 $\displaystyle\text{erf}(x)=\dfrac{2}{\sqrt{\pi}}\int_0^xe^{-x^2}\text{d}x$
互补误差函数 $\displaystyle \text{erfc}(x)=1-\text{erf}(x)=\dfrac{2}{\sqrt{\pi}}\int_x^{+\infty}e^{-x^2}\text{d}x$
zeta 函数 $\displaystyle\zeta(s)=\sum_{k=1}^{\infty}\dfrac{1}{k^s}$</description>
    </item>
    
    <item>
      <title>王道考研 数据结构 绪论</title>
      <link>https://Lu0key.github.io/post/%E7%8E%8B%E9%81%93%E8%80%83%E7%A0%94-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BB%AA%E8%AE%BA/</link>
      <pubDate>Fri, 22 Jan 2021 19:09:34 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/%E7%8E%8B%E9%81%93%E8%80%83%E7%A0%94-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BB%AA%E8%AE%BA/</guid>
      <description>绪论 学什么  如何用程序代码把现实世界的问题信息化 如何用计算机高效地处理这些信息从而创造价值  基本概念 数据  数据是信息的载体，是描述客观事物属性的数、字符及所有能输入到计算机中并被计算机程序识别和处理的符号的集合。数据是计算机程序加工的原料。
 数据元素、数据项  数据元素是数据的基本单位，通常作为一个整体进行考虑和处理。
一个数据元素可由若干个数据项组成，数据项是构成数据元素的不可分割的最小单位。
 数据结构、数据对象  结构 是各个元素之间的关系
数据结构 是相互之间存在一种或者多种特定关系的数据元素的集合。
数据对象 是具有相同性质的数据元素的集合，是数据的一个子集。
 数据结构的三要素   逻辑结构
 集合  各个元素同属一个集合，别无其他关系   线性结构  数据元素之间是一对一的关系，除了第一个元素，所有元素都有唯一前驱，除了最后一个元素，所有元素都有唯一后继   树形结构  数据元素之间是一对多的关系   图状结构（网状结构）  数据元素之间是多对多的关系      物理结构（存储结构）
 顺序存储  存储位置相邻   链式存储  借助元素存储地址的指针来辨识元素之间的逻辑关系   索引存储  索引表，索引表中的每项称为索引项(关键字，地址)   散列存储  通过元素的关键字直接计算出该元素的存储地址，又称哈希（Hash）存储      数据的运算</description>
    </item>
    
    <item>
      <title>Euler积分</title>
      <link>https://Lu0key.github.io/post/euler%E7%A7%AF%E5%88%86/</link>
      <pubDate>Fri, 22 Jan 2021 16:04:02 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/euler%E7%A7%AF%E5%88%86/</guid>
      <description>Beta 函数 形如
$\displaystyle \text{B}(p,q)=\int_0^1x^{p-1}(1-x)^{q-1}\text{d}x$
的含参变量积分称为 Beta 函数，或 第一类 Euler 积分。
Beta 函数 $\text{B}(p,q)$ 的定义域为 $(0,+\infty)\times(0,+\infty)$
性质 1 连续性 $\text{B}(p,q)$ 在 $(0,+\infty)\times(0,+\infty)$ 上连续.
2 对称性 $\text{B}(p,q)=\text{B}(q,p),;p&amp;gt;0,;q&amp;gt;0$
3 递推公式 $\text{B}(p,q)=\dfrac{q-1}{p+q-1}\text{B}(p,q-1),;p&amp;gt;0,;q&amp;gt;1$
可由对称性与递推公式得到，
当 $p&amp;gt;1,;q&amp;gt;1$ 时，有
$\text{B}(p,q)=\dfrac{(p-1)(q-1)}{(p+q-1)(p+q-2)}\text{B}(p-1,q-1)$
其他表示 1 作变量代换 $x=\cos^2\varphi$，得到
$\text{B}(p,q)=2\displaystyle\int_0^{\frac\pi2}\cos^{2p-1}\varphi\sin^{2q-1}\varphi;\text{d}\varphi$
易知
$\text{B}\left(\dfrac{1}{2},\dfrac{1}{2}\right)=\pi$
2 作变量代换 $x=\dfrac{1}{1+t}$，得到
$\begin{aligned} \text{B}(p,q)=&amp;amp;\int_0^{+\infty}\dfrac{t^{q-1}}{(1+t)^{p+q}}\text{d}t\
=&amp;amp;\int_0^{1}\dfrac{t^{q-1}}{(1+t)^{p+q}}\text{d}t+\int_1^{+\infty}\dfrac{t^{q-1}}{(1+t)^{p+q}}\text{d}t \end{aligned}$
对后一个积分作变量代换 $t=\dfrac{1}{u}$，得到
$\displaystyle\int_1^{+\infty}\dfrac{t^{q-1}}{(1+t)^{p+q}}\text{d}t=\int_0^1\dfrac{u^{p-1}}{(1+u)^{p+q}}\text{d}u$
于是
$\displaystyle\text{B}(p,q)=\int_0^1\dfrac{t^{q-1}+t^{p-1}}{(1+t)^{p+q}}\text{d}t$
 Gamma 函数 形如
$\displaystyle\Gamma(s)=\int_0^{+\infty}x^{s-1}e^{-x}\text{d}x$
的含参变量积分称为 Gamma 函数 或 第二类 Euler 积分.
$\Gamma(s)$ 的定义域为 $(0,+\infty)$
性质 1 连续性与可导性 $\Gamma(s)$ 在 $(0,+\infty)$ 上连续且任意阶可导.</description>
    </item>
    
    <item>
      <title>Python Flask 入门</title>
      <link>https://Lu0key.github.io/post/python-flask-%E5%85%A5%E9%97%A8/</link>
      <pubDate>Fri, 22 Jan 2021 16:01:50 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/python-flask-%E5%85%A5%E9%97%A8/</guid>
      <description>Flask  Flask  特点 list  example   tuple(元组)  “可变的” tuple  tips     循环  range() continue  example   break   dict set  常用函数   定义函数  tips 空函数 参数检查 多个返回值 默认参数  坑   可变参数 关键字参数 命名关键词参数   参数组合还没看&amp;hellip;..  递归函数  tips   尾递归 切片 Slice 切片   Iteration 迭代  如何判断一个对象是否可迭代 如何同时迭代索引和元素   列表生成式 generator 生成器 迭代器 高阶函数 map/reduce filter sorted 返回函数 闭包(Closure) 匿名函数lambda 装饰器(Decorator) 偏函数 Partial function 模块 Module  作用域 安装第三方库   OOP 访问限制 继承和多态 获取对象信息 实例属性和类属性 使用__slots__ 使用@property 多重继承 定制类  __iter__ __getattr__ __call__   枚举类 待解决问题    特点 123</description>
    </item>
    
    <item>
      <title>Js Dom</title>
      <link>https://Lu0key.github.io/post/js-dom/</link>
      <pubDate>Thu, 21 Jan 2021 14:41:37 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/js-dom/</guid>
      <description>DOM DOM 树   DOM
 DOM 树 获取DOM元素 元素的属性 操作元素类名 操作文本内容 全选 选项卡 返回顶部 操作元素样式 DOM节点 获取节点 创建节点 插入节点 删除节点 替换节点 克隆节点 带有添加和删除功能的表格 动态创建表格 获取元素尺寸 获取元素偏移量 获取浏览器窗口尺寸 元素的常用事件 二级菜单渲染 选择器    doucument object model文档对象模型
  操作页面元素的属性与方法
  DOM树
  DOM 的顶级是 document，可能会有更高的节点window，看情况
  可以操作各种标签，文本，属性， 样式
  获取DOM元素  非常规标签  html/head/body  document.documentElement document.head document.body     常规标签  能用常规标签的方法去获取非常规标签，知识一般不这样用   getElementById()  语法：查找范围.</description>
    </item>
    
    <item>
      <title>Test Mathjax</title>
      <link>https://Lu0key.github.io/post/test-mathjax/</link>
      <pubDate>Thu, 21 Jan 2021 13:37:06 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/test-mathjax/</guid>
      <description>测试数学公式 行内公式: $a^2+b^2=c^2$
块状公式: $$ E=mc^2 $$
显示公式参考：https://note.qidong.name/2018/03/hugo-mathjax/</description>
    </item>
    
    <item>
      <title>First Blog</title>
      <link>https://Lu0key.github.io/post/first-blog/</link>
      <pubDate>Thu, 21 Jan 2021 11:15:13 +0800</pubDate>
      
      <guid>https://Lu0key.github.io/post/first-blog/</guid>
      <description>Hello world 第一篇Hugo博客
下载主题
git clone https://github.com/lxndrblz/m10c.git themes/m10c  hugo 本地启动
hugo server -t themename --bulidDrafts hugo 创建新文章
hugo new post/blogname.md 推到Github远端服务器 创建名为 [github用户名].github.io 的仓库
blog目录下
hugo --theme=m10c --baseUrl=&amp;#34;https://Lu0key.github.io/&amp;#34; --buildDrafts 会生成一个public文件夹，进入该文件夹
cd public 初始化git仓库
git init 将所有文件添加入暂存区
git add . 将git仓库和云端仓库关联
git remote add [shortname] [url] 比如我的就是
git remote add origin https://github.com/Lu0key/Lu0key.github.io.git 最后推至云端
git push -u origin master  之后修改博客后，再推到GitHub上需要
hugo --theme=m10c -b=&amp;#34;https://Lu0key.github.io/&amp;#34; -D cd public git add . git commit -m &amp;#34;message&amp;#34; git push </description>
    </item>
    
  </channel>
</rss>
