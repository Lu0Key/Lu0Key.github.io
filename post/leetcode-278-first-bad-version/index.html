<!doctype html>
<html lang="en-us">

<head>
    
    <title>Leetcode 278 第一个错误的版本 // 洛七的摸鱼池塘</title>
    <link rel="shortcut icon" href="%20/favicon.ico%20" />
    <meta charset="utf-8" /> <meta name="generator" content="Hugo 0.80.0" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="洛七" />
    <meta name="description" content="" /> <link rel="stylesheet" href="https://Lu0key.github.io/css/main.min.88e7083eff65effb7485b6e6f38d10afbec25093a6fac42d734ce9024d3defbd.css" />  <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Leetcode 278 第一个错误的版本"/>
<meta name="twitter:description" content="第一个错误的版本(First Bad Version) 你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。
假设你有 n 个版本 [1, 2, ..., n]，你想找出导致之后所有版本出错的第一个错误的版本。
你可以通过调用 bool isBadVersion(version) 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。
示例:
给定 n = 5，并且 version = 4 是第一个错误的版本。 调用 isBadVersion(3) -&gt; false 调用 isBadVersion(5) -&gt; true 调用 isBadVersion(4) -&gt; true 所以，4 是第一个错误的版本。 // The API isBadVersion is defined for you. // bool isBadVersion(int version);  int firstBadVersion(int n) { for (int ans = 1; ans &lt;=n; ans&#43;&#43;){ if(isBadVersion(ans) &amp;&amp; !isBadVersion(ans-1)){ return ans; } } return 0; } 上面这种方法是最直接的，但是相对的，但是超慢，会超时"/>
 <meta property="og:title" content="Leetcode 278 第一个错误的版本" />
<meta property="og:description" content="第一个错误的版本(First Bad Version) 你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。
假设你有 n 个版本 [1, 2, ..., n]，你想找出导致之后所有版本出错的第一个错误的版本。
你可以通过调用 bool isBadVersion(version) 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。
示例:
给定 n = 5，并且 version = 4 是第一个错误的版本。 调用 isBadVersion(3) -&gt; false 调用 isBadVersion(5) -&gt; true 调用 isBadVersion(4) -&gt; true 所以，4 是第一个错误的版本。 // The API isBadVersion is defined for you. // bool isBadVersion(int version);  int firstBadVersion(int n) { for (int ans = 1; ans &lt;=n; ans&#43;&#43;){ if(isBadVersion(ans) &amp;&amp; !isBadVersion(ans-1)){ return ans; } } return 0; } 上面这种方法是最直接的，但是相对的，但是超慢，会超时" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://Lu0key.github.io/post/leetcode-278-first-bad-version/" />
<meta property="article:published_time" content="2021-03-25T14:16:28+08:00" />
<meta property="article:modified_time" content="2021-03-25T14:16:28+08:00" />


</head>

<body>
    <header class="app-header">
        <a href="https://Lu0key.github.io/"><img class="app-header-avatar" src="/avatar.jpg" alt="洛七" /></a>
        <h1>洛七的摸鱼池塘</h1>
        <nav class="app-header-menu">
            <a class="app-header-menu-item" href="/tags/">Tags</a>
        </nav>
        <p>即将没书读的咸鱼</p>
        <div class="app-header-social">
            
        </div>
    </header>
    <main class="app-container">
        
  <article class="post">
    <header class="post-header">
      <h1 class ="post-title">Leetcode 278 第一个错误的版本</h1>
      <div class="post-meta">
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar">
  <title>calendar</title>
  <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line>
</svg>
          Mar 25, 2021
        </div>
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock">
  <title>clock</title>
  <circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline>
</svg>
          1 min read
        </div>
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tag">
  <title>tag</title>
  <path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path><line x1="7" y1="7" x2="7" y2="7"></line>
</svg>
              <a class="tag" href="https://Lu0key.github.io/tags/leetcode/">leetcode</a>
        </div>
      </div>
    </header>
    <div class="post-content">
      <h1 id="第一个错误的版本first-bad-versionhttpsleetcode-cncomproblemsfirst-bad-version"><a href="https://leetcode-cn.com/problems/first-bad-version/">第一个错误的版本(First Bad Version)</a></h1>
<p>你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。</p>
<p>假设你有 <code>n</code> 个版本 <code>[1, 2, ..., n]</code>，你想找出导致之后所有版本出错的第一个错误的版本。</p>
<p>你可以通过调用 <code>bool isBadVersion(version)</code> 接口来判断版本号 <code>version</code> 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。</p>
<p><strong>示例:</strong></p>
<pre><code>给定 n = 5，并且 version = 4 是第一个错误的版本。

调用 isBadVersion(3) -&gt; false
调用 isBadVersion(5) -&gt; true
调用 isBadVersion(4) -&gt; true

所以，4 是第一个错误的版本。 
</code></pre><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">// The API isBadVersion is defined for you.
</span><span style="color:#75715e">// bool isBadVersion(int version);
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">firstBadVersion</span>(<span style="color:#66d9ef">int</span> n) {
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> ans <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; ans <span style="color:#f92672">&lt;=</span>n; ans<span style="color:#f92672">++</span>){
        <span style="color:#66d9ef">if</span>(isBadVersion(ans) <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span>isBadVersion(ans<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)){
            <span style="color:#66d9ef">return</span> ans;
        }
    }
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p>上面这种方法是最直接的，但是相对的，但是超慢，会超时</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">binarySearch</span>(<span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> first, <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> last){
    <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> mid <span style="color:#f92672">=</span> (first)<span style="color:#f92672">+</span>(last<span style="color:#f92672">-</span>first)<span style="color:#f92672">/</span><span style="color:#ae81ff">2</span>;
    <span style="color:#66d9ef">if</span>(isBadVersion(mid) <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span>isBadVersion(mid<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)){
        <span style="color:#66d9ef">return</span> mid;
    }
    <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>isBadVersion(mid)){
        <span style="color:#66d9ef">return</span> binarySearch(mid<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>,last);
    }
    <span style="color:#66d9ef">return</span> binarySearch(first,mid);
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">firstBadVersion</span>(<span style="color:#66d9ef">int</span> n) {
    <span style="color:#66d9ef">return</span> binarySearch(<span style="color:#ae81ff">1</span>,(<span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span>)n<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>);
}
</code></pre></div><p>有类似二分法，这里有两个注意的点，一个是first+last可能会超过int的范围，n+1也可能会超过返回，所以要类型转换。</p>
<p>也可以转换成while循环</p>

    </div>
    <div class="post-footer">
      
    </div>
  </article>

    </main>
</body>

</html>