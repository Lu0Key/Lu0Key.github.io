<!doctype html>
<html lang="en-us">
  <head>
    <title>Leetcode 1008 前序遍历构造二叉搜索树 // 洛七的摸鱼池塘</title>
    <link rel="shortcut icon" href="/favicon.ico" />
    <meta charset="utf-8" />
    <meta name="generator" content="Hugo 0.115.4">
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="洛七" />
    <meta name="description" content="" />
    <link rel="stylesheet" href="/css/main.min.d08c6ce68432c68a64d84cb426dfdecab702035f91a5d580831f23f76c040a05.css" />

    
    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Leetcode 1008 前序遍历构造二叉搜索树"/>
<meta name="twitter:description" content="前序遍历构造二叉搜索树(Construct Binary Search Tree from Preorder Traversal) 返回与给定前序遍历 preorder 相匹配的二叉搜索树（binary search tree）的根结点。
(回想一下，二叉搜索树是二叉树的一种，其每个节点都满足以下规则，对于 node.left 的任何后代，值总 &lt; node.val，而 node.right 的任何后代，值总 &gt; node.val。此外，前序遍历首先显示节点 node 的值，然后遍历 node.left，接着遍历 node.right。）
题目保证，对于给定的测试用例，总能找到满足要求的二叉搜索树。
示例：
输入：[8,5,1,7,10,12] 输出：[8,5,10,1,7,null,12] 提示：
1 &lt;= preorder.length &lt; = 100 1 &lt;= preorder[i] &lt;= 10^8 preorder 中的值互不相同 /** * Definition for a binary tree node. * struct TreeNode { * int val; * struct TreeNode *left; * struct TreeNode *right; * }; */ struct TreeNode* bstFromPreorderRanged(int* preorder, int start, int end){ if(start == end) return NULL; struct TreeNode* root = malloc(sizeof(struct TreeNode)); root-&gt;val = preorder[start]; int i = start&#43;1; while (i&lt;end &amp;&amp; preorder[i]&lt;root-&gt;val){ i&#43;&#43;; } root-&gt;left = bstFromPreorderRanged(preorder, start&#43;1, i); root-&gt;right = bstFromPreorderRanged(preorder,i,end); return root; } struct TreeNode* bstFromPreorder(int* preorder, int preorderSize){ return bstFromPreorderRanged(preorder,0,preorderSize); } 提高效率"/>

    <meta property="og:title" content="Leetcode 1008 前序遍历构造二叉搜索树" />
<meta property="og:description" content="前序遍历构造二叉搜索树(Construct Binary Search Tree from Preorder Traversal) 返回与给定前序遍历 preorder 相匹配的二叉搜索树（binary search tree）的根结点。
(回想一下，二叉搜索树是二叉树的一种，其每个节点都满足以下规则，对于 node.left 的任何后代，值总 &lt; node.val，而 node.right 的任何后代，值总 &gt; node.val。此外，前序遍历首先显示节点 node 的值，然后遍历 node.left，接着遍历 node.right。）
题目保证，对于给定的测试用例，总能找到满足要求的二叉搜索树。
示例：
输入：[8,5,1,7,10,12] 输出：[8,5,10,1,7,null,12] 提示：
1 &lt;= preorder.length &lt; = 100 1 &lt;= preorder[i] &lt;= 10^8 preorder 中的值互不相同 /** * Definition for a binary tree node. * struct TreeNode { * int val; * struct TreeNode *left; * struct TreeNode *right; * }; */ struct TreeNode* bstFromPreorderRanged(int* preorder, int start, int end){ if(start == end) return NULL; struct TreeNode* root = malloc(sizeof(struct TreeNode)); root-&gt;val = preorder[start]; int i = start&#43;1; while (i&lt;end &amp;&amp; preorder[i]&lt;root-&gt;val){ i&#43;&#43;; } root-&gt;left = bstFromPreorderRanged(preorder, start&#43;1, i); root-&gt;right = bstFromPreorderRanged(preorder,i,end); return root; } struct TreeNode* bstFromPreorder(int* preorder, int preorderSize){ return bstFromPreorderRanged(preorder,0,preorderSize); } 提高效率" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://Lu0key.github.io/post/leetcode-1008-construct-binary-search-tree-from-preorder-traversal/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2021-03-23T14:47:50+08:00" />
<meta property="article:modified_time" content="2021-03-23T14:47:50+08:00" />


  </head>
  <body>
    <header class="app-header">
      <a href="https://Lu0key.github.io/"><img class="app-header-avatar" src="/avatar.jpg" alt="洛七" /></a>
      <span class="app-header-title">洛七的摸鱼池塘</span>
      <nav class="app-header-menu">
          <a class="app-header-menu-item" href="/tags/">Tags</a>
      </nav>
      <p>即将没书读的咸鱼</p>
    </header>
    <main class="app-container">
      
  <article class="post">
    <header class="post-header">
      <h1 class ="post-title">Leetcode 1008 前序遍历构造二叉搜索树</h1>
      <div class="post-meta">
        <div>
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar">
  <title>calendar</title>
  <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line>
</svg>
          Mar 23, 2021
        </div>
        <div>
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock">
  <title>clock</title>
  <circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline>
</svg>
          2 min read
        </div>
        <div>
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tag">
  <title>tag</title>
  <path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path><line x1="7" y1="7" x2="7.01" y2="7"></line>
</svg>
              <a class="tag" href="https://Lu0key.github.io/tags/leetcode/">leetcode</a>
        </div>
      </div>
    </header>
    <div class="post-content">
      <h1 id="前序遍历构造二叉搜索树construct-binary-search-tree-from-preorder-traversalhttpsleetcode-cncomproblemsconstruct-binary-search-tree-from-preorder-traversal"><a href="https://leetcode-cn.com/problems/construct-binary-search-tree-from-preorder-traversal/">前序遍历构造二叉搜索树(Construct Binary Search Tree from Preorder Traversal)</a></h1>
<p>返回与给定前序遍历 <code>preorder</code> 相匹配的二叉搜索树（binary <strong>search</strong> tree）的根结点。</p>
<p>(回想一下，二叉搜索树是二叉树的一种，其每个节点都满足以下规则，对于 <code>node.left</code> 的任何后代，值总 <code>&lt; node.val</code>，而 <code>node.right</code> 的任何后代，值总 <code>&gt; node.val</code>。此外，前序遍历首先显示节点 <code>node</code> 的值，然后遍历 <code>node.left</code>，接着遍历 <code>node.right</code>。）</p>
<p>题目保证，对于给定的测试用例，总能找到满足要求的二叉搜索树。</p>
<p><strong>示例：</strong></p>
<pre tabindex="0"><code>输入：[8,5,1,7,10,12]
输出：[8,5,10,1,7,null,12]
</code></pre><p><img src="https://raw.githubusercontent.com/Lu0Key/hexo-image/master/imags/2021/1266.png" alt="图裂了"></p>
<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= preorder.length &lt; = 100</code></li>
<li><code>1 &lt;= preorder[i] &lt;= 10^8</code></li>
<li><code>preorder</code> 中的值互不相同</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * Definition for a binary tree node.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * struct TreeNode {
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *     int val;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *     struct TreeNode *left;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *     struct TreeNode *right;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * };
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> TreeNode<span style="color:#f92672">*</span> <span style="color:#a6e22e">bstFromPreorderRanged</span>(<span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> preorder, <span style="color:#66d9ef">int</span> start, <span style="color:#66d9ef">int</span> end){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(start <span style="color:#f92672">==</span> end) <span style="color:#66d9ef">return</span> NULL;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> TreeNode<span style="color:#f92672">*</span> root <span style="color:#f92672">=</span> <span style="color:#a6e22e">malloc</span>(<span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">struct</span> TreeNode));
</span></span><span style="display:flex;"><span>    root<span style="color:#f92672">-&gt;</span>val <span style="color:#f92672">=</span> preorder[start];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> start<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> (i<span style="color:#f92672">&lt;</span>end <span style="color:#f92672">&amp;&amp;</span> preorder[i]<span style="color:#f92672">&lt;</span>root<span style="color:#f92672">-&gt;</span>val){
</span></span><span style="display:flex;"><span>        i<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    root<span style="color:#f92672">-&gt;</span>left <span style="color:#f92672">=</span> <span style="color:#a6e22e">bstFromPreorderRanged</span>(preorder, start<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>, i);
</span></span><span style="display:flex;"><span>    root<span style="color:#f92672">-&gt;</span>right <span style="color:#f92672">=</span> <span style="color:#a6e22e">bstFromPreorderRanged</span>(preorder,i,end);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> root;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> TreeNode<span style="color:#f92672">*</span> <span style="color:#a6e22e">bstFromPreorder</span>(<span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> preorder, <span style="color:#66d9ef">int</span> preorderSize){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">bstFromPreorderRanged</span>(preorder,<span style="color:#ae81ff">0</span>,preorderSize);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>提高效率</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> pos;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> TreeNode<span style="color:#f92672">*</span> <span style="color:#a6e22e">bstFromPreorderRanged</span>(<span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> preorder, <span style="color:#66d9ef">int</span> start, <span style="color:#66d9ef">int</span> end, <span style="color:#66d9ef">int</span> max){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(start <span style="color:#f92672">==</span> end) <span style="color:#66d9ef">return</span> NULL;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(preorder[start] <span style="color:#f92672">&gt;</span>max) <span style="color:#66d9ef">return</span> NULL;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> TreeNode<span style="color:#f92672">*</span> root <span style="color:#f92672">=</span> <span style="color:#a6e22e">malloc</span>(<span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">struct</span> TreeNode));
</span></span><span style="display:flex;"><span>    root<span style="color:#f92672">-&gt;</span>val <span style="color:#f92672">=</span> preorder[start];
</span></span><span style="display:flex;"><span>    pos<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>    root<span style="color:#f92672">-&gt;</span>left <span style="color:#f92672">=</span> <span style="color:#a6e22e">bstFromPreorderRanged</span>(preorder, start<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>, end,root<span style="color:#f92672">-&gt;</span>val);
</span></span><span style="display:flex;"><span>    root<span style="color:#f92672">-&gt;</span>right <span style="color:#f92672">=</span> <span style="color:#a6e22e">bstFromPreorderRanged</span>(preorder,pos,end,max);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> root;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> TreeNode<span style="color:#f92672">*</span> <span style="color:#a6e22e">bstFromPreorder</span>(<span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> preorder, <span style="color:#66d9ef">int</span> preorderSize){
</span></span><span style="display:flex;"><span>    pos <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">bstFromPreorderRanged</span>(preorder,<span style="color:#ae81ff">0</span>,preorderSize,INT_MAX);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>少了一个while循环</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> TreeNode<span style="color:#f92672">*</span> <span style="color:#a6e22e">bstFromPreorder</span>(<span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> preorder, <span style="color:#66d9ef">int</span> preorderSize){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> TreeNode<span style="color:#f92672">*</span> root <span style="color:#f92672">=</span> <span style="color:#a6e22e">malloc</span>(<span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">struct</span> TreeNode));
</span></span><span style="display:flex;"><span>    root<span style="color:#f92672">-&gt;</span>val <span style="color:#f92672">=</span> preorder[<span style="color:#ae81ff">0</span>];
</span></span><span style="display:flex;"><span>    root<span style="color:#f92672">-&gt;</span>left <span style="color:#f92672">=</span> root<span style="color:#f92672">-&gt;</span>right <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> TreeNode<span style="color:#f92672">*</span> path[<span style="color:#ae81ff">100</span>];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> topIndex <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    path[topIndex] <span style="color:#f92672">=</span> root;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;i<span style="color:#f92672">&lt;</span>preorderSize;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">struct</span> TreeNode<span style="color:#f92672">*</span> node <span style="color:#f92672">=</span> <span style="color:#a6e22e">malloc</span>(<span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">struct</span> TreeNode));
</span></span><span style="display:flex;"><span>        node<span style="color:#f92672">-&gt;</span>val <span style="color:#f92672">=</span> preorder[i];
</span></span><span style="display:flex;"><span>        node<span style="color:#f92672">-&gt;</span>left <span style="color:#f92672">=</span> node<span style="color:#f92672">-&gt;</span>right <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(preorder[i] <span style="color:#f92672">&lt;</span> path[topIndex]<span style="color:#f92672">-&gt;</span>val ){
</span></span><span style="display:flex;"><span>            path[topIndex]<span style="color:#f92672">-&gt;</span>left <span style="color:#f92672">=</span> node;
</span></span><span style="display:flex;"><span>            topIndex<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>            path[topIndex] <span style="color:#f92672">=</span> node;
</span></span><span style="display:flex;"><span>        } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">while</span>(topIndex<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span><span style="color:#f92672">&gt;=</span><span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> path[topIndex<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]<span style="color:#f92672">-&gt;</span>val <span style="color:#f92672">&lt;</span>preorder[i]){
</span></span><span style="display:flex;"><span>                topIndex<span style="color:#f92672">--</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(topIndex <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span><span style="color:#f92672">&gt;=</span><span style="color:#ae81ff">0</span>){
</span></span><span style="display:flex;"><span>                path[topIndex]<span style="color:#f92672">-&gt;</span>right <span style="color:#f92672">=</span> node;
</span></span><span style="display:flex;"><span>                path[topIndex] <span style="color:#f92672">=</span> node;
</span></span><span style="display:flex;"><span>            }<span style="color:#66d9ef">else</span>{
</span></span><span style="display:flex;"><span>                path[<span style="color:#ae81ff">0</span>]<span style="color:#f92672">-&gt;</span>right <span style="color:#f92672">=</span> node;
</span></span><span style="display:flex;"><span>                path[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> node;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> root;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>最后这种方法应该时比较优的解法了</p>

    </div>
    <div class="post-footer">
      
    </div>
  </article>

    </main>
  </body>
</html>
