<!doctype html>
<html lang="en-us">
  <head>
    <title>王道考研 数据结构 图 // 洛七的摸鱼池塘</title>
    <link rel="shortcut icon" href="/favicon.ico" />
    <meta charset="utf-8" />
    <meta name="generator" content="Hugo 0.115.4">
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="洛七" />
    <meta name="description" content="" />
    <link rel="stylesheet" href="/css/main.min.d08c6ce68432c68a64d84cb426dfdecab702035f91a5d580831f23f76c040a05.css" />

    
    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="王道考研 数据结构 图"/>
<meta name="twitter:description" content="图 图 定义 图的存储 临接矩阵 邻接表 十字链表法 邻接多重表 基本操作 图的遍历 广度优先遍历 深度优先遍历 最小生成树 最短路径问题 Dijkstra算法 Floyd算法 有向无环图(DAG) 拓扑排序 关键路径 定义 图G由顶点集V和边集E组成，记为G=(V, E)，其中V(G) 表示图G中顶点的有限非空集；E(G) 表示图G 中顶点之间的关系（边）集合。若 $V={v_1, v_2, &hellip;, v_n}$，则用 $|V|$ 表示图G 中顶点的个数，也称图G 的阶，$E={(u, v)|u\in V, v\in V}$，用 $|E|$ 表示图G中边的条数。
G：Graph
V：Vertex
E：Edge
线性表可以是空表，树可以是空树，但图不可以是空的，即V一定是非空集
e.g.
V:车站，E：铁路
社交软件中的好友关系可以看成是一种无向图
微博中的粉丝关系可以看作是一种有向图
若 E 是无向边（简称边）的有限集合时，则图 G 为无向图。边是顶点的无序对，记为 $(v, w)$ 或 $(w, v)$，因为 $(v, w)=(w, v)$，其中v，w 是顶点。可以说顶点w和顶点v互为邻接点。边 $(v, w)$ 依附于顶点 $w$ 和 $v$，或者说边 $(v, w)$ 和顶点 v、w 相关联。"/>

    <meta property="og:title" content="王道考研 数据结构 图" />
<meta property="og:description" content="图 图 定义 图的存储 临接矩阵 邻接表 十字链表法 邻接多重表 基本操作 图的遍历 广度优先遍历 深度优先遍历 最小生成树 最短路径问题 Dijkstra算法 Floyd算法 有向无环图(DAG) 拓扑排序 关键路径 定义 图G由顶点集V和边集E组成，记为G=(V, E)，其中V(G) 表示图G中顶点的有限非空集；E(G) 表示图G 中顶点之间的关系（边）集合。若 $V={v_1, v_2, &hellip;, v_n}$，则用 $|V|$ 表示图G 中顶点的个数，也称图G 的阶，$E={(u, v)|u\in V, v\in V}$，用 $|E|$ 表示图G中边的条数。
G：Graph
V：Vertex
E：Edge
线性表可以是空表，树可以是空树，但图不可以是空的，即V一定是非空集
e.g.
V:车站，E：铁路
社交软件中的好友关系可以看成是一种无向图
微博中的粉丝关系可以看作是一种有向图
若 E 是无向边（简称边）的有限集合时，则图 G 为无向图。边是顶点的无序对，记为 $(v, w)$ 或 $(w, v)$，因为 $(v, w)=(w, v)$，其中v，w 是顶点。可以说顶点w和顶点v互为邻接点。边 $(v, w)$ 依附于顶点 $w$ 和 $v$，或者说边 $(v, w)$ 和顶点 v、w 相关联。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://Lu0key.github.io/post/%E7%8E%8B%E9%81%93%E8%80%83%E7%A0%94-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%9B%BE/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2021-03-01T08:22:55+08:00" />
<meta property="article:modified_time" content="2021-03-01T08:22:55+08:00" />


  </head>
  <body>
    <header class="app-header">
      <a href="https://Lu0key.github.io/"><img class="app-header-avatar" src="/avatar.jpg" alt="洛七" /></a>
      <span class="app-header-title">洛七的摸鱼池塘</span>
      <nav class="app-header-menu">
          <a class="app-header-menu-item" href="/tags/">Tags</a>
      </nav>
      <p>即将没书读的咸鱼</p>
    </header>
    <main class="app-container">
      
  <article class="post">
    <header class="post-header">
      <h1 class ="post-title">王道考研 数据结构 图</h1>
      <div class="post-meta">
        <div>
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar">
  <title>calendar</title>
  <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line>
</svg>
          Mar 1, 2021
        </div>
        <div>
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock">
  <title>clock</title>
  <circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline>
</svg>
          6 min read
        </div>
        <div>
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tag">
  <title>tag</title>
  <path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path><line x1="7" y1="7" x2="7.01" y2="7"></line>
</svg>
              <a class="tag" href="https://Lu0key.github.io/tags/%E8%80%83%E7%A0%94/">考研</a>
              <a class="tag" href="https://Lu0key.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a>
        </div>
      </div>
    </header>
    <div class="post-content">
      <h1 id="图">图</h1>
<!-- raw HTML omitted -->
<ul>
<li><a href="#%E5%9B%BE">图</a>
<ul>
<li><a href="#%E5%AE%9A%E4%B9%89">定义</a></li>
<li><a href="#%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8">图的存储</a>
<ul>
<li><a href="#%E4%B8%B4%E6%8E%A5%E7%9F%A9%E9%98%B5">临接矩阵</a></li>
<li><a href="#%E9%82%BB%E6%8E%A5%E8%A1%A8">邻接表</a></li>
<li><a href="#%E5%8D%81%E5%AD%97%E9%93%BE%E8%A1%A8%E6%B3%95">十字链表法</a></li>
<li><a href="#%E9%82%BB%E6%8E%A5%E5%A4%9A%E9%87%8D%E8%A1%A8">邻接多重表</a></li>
</ul>
</li>
<li><a href="#%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C">基本操作</a></li>
<li><a href="#%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86">图的遍历</a>
<ul>
<li><a href="#%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86">广度优先遍历</a></li>
<li><a href="#%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86">深度优先遍历</a></li>
</ul>
</li>
<li><a href="#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91">最小生成树</a></li>
<li><a href="#%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98">最短路径问题</a></li>
<li><a href="#dijkstra%E7%AE%97%E6%B3%95">Dijkstra算法</a></li>
<li><a href="#floyd%E7%AE%97%E6%B3%95">Floyd算法</a></li>
<li><a href="#%E6%9C%89%E5%90%91%E6%97%A0%E7%8E%AF%E5%9B%BEdag">有向无环图(DAG)</a></li>
<li><a href="#%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F">拓扑排序</a></li>
<li><a href="#%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84">关键路径</a></li>
</ul>
</li>
</ul>
<!-- raw HTML omitted -->
<h2 id="定义">定义</h2>
<p>图G由顶点集V和边集E组成，记为G=(V, E)，其中V(G) 表示图G中顶点的有限非空集；E(G) 表示图G 中顶点之间的关系（边）集合。若 $V={v_1, v_2, &hellip;, v_n}$，则用 $|V|$ 表示图G 中顶点的个数，也称图G 的阶，$E={(u, v)|u\in V, v\in V}$，用 $|E|$ 表示图G中边的条数。</p>
<p>G：Graph<br>
V：Vertex<br>
E：Edge<br>
线性表可以是空表，树可以是空树，但图不可以是空的，即V一定是<strong>非空集</strong></p>
<p>e.g.<br>
V:车站，E：铁路</p>
<p>社交软件中的好友关系可以看成是一种无向图<br>
微博中的粉丝关系可以看作是一种有向图</p>
<p>若 E 是无向边（简称边）的有限集合时，则图 G 为<strong>无向图</strong>。边是顶点的无序对，记为 $(v, w)$ 或 $(w, v)$，因为 $(v, w)=(w, v)$，其中v，w 是顶点。可以说顶点w和顶点v互为邻接点。边 $(v, w)$ 依附于顶点 $w$ 和 $v$，或者说边 $(v, w)$ 和顶点 v、w 相关联。</p>
<p>若 E 是有向边（也称<strong>弧</strong>）的有限集合时，则图 G 为<strong>有向图</strong>。弧是顶点的有序对，记为 $&lt;v,w&gt;$，其中 v、w 是顶点，v 称为<strong>弧尾</strong>，w称为<strong>弧头</strong>，$&lt;v, w&gt;$ 称为从顶点 v 到顶点 w 的弧，也称 v 邻接到 w，或 w 邻接自 v。因为有向，因此 $&lt;v, w&gt;\not=&lt;w, v&gt;$</p>
<p>圆括号对应无向图的边，尖括号对应有向图的边。</p>
<p>简单图：</p>
<ul>
<li>不存在重复边</li>
<li>不存在顶点到自身的边</li>
</ul>
<p><strong>数据结构中一般只讨论简单图</strong>。</p>
<p>多重图： 图 G 中某两个结点之间的边数多于一条，又允许顶点通过同一条边和自己关联，则 G 为多重图.</p>
<p>顶点的度</p>
<ul>
<li>对于无向图:顶点v的度是指依附于该顶点的边的条数,记为 TD(v).</li>
<li>对于有向图
<ul>
<li>入度:以顶点v为终点的有向边的数目,记为ID(v)</li>
<li>出度:以顶点v为起点的有向边的数目,记为OD(v)</li>
<li>顶点v的度等于其入度和出度之和,即TD(v)=ID(v)+OD(v)</li>
</ul>
</li>
</ul>
<p>有n个顶点的无向图的度等于 $\displaystyle\sum_{i=1}^nTD(v_i)=2|E|$<br>
其中 $|E|$ 表示无向图边的数量</p>
<p>在有 n 个顶点的有向图中 $\displaystyle\sum_{i=1}^nID(v_i)=\sum_{i=1}^nOD(v_i)=|E|$</p>
<p>名词:</p>
<ul>
<li>路径</li>
<li>回路:第一个顶点和最后一个顶点相同的路径称为<strong>回路</strong>或<strong>环</strong></li>
<li><strong>简单路径</strong>:在路径序列中,顶点不重复出现的路径称为简单路径</li>
<li><strong>简单回路</strong>:除第一个顶点和最后一个顶点外,其余顶点不重复出现的回路称为简单回路</li>
<li><strong>路径长度</strong>:路径上边的数量</li>
<li>点到点的<strong>距离</strong>:从顶点v到顶点w的最短路径若存在,则此路径的长度称为从v到w的距离</li>
<li>若从v到w根本不存在路径,则记该距离为无穷(∞)</li>
</ul>
<p>无向图中,若从顶点v到顶点w有路径存在,则称v 和 w 是<strong>连通</strong>的<br>
有向图中,若从顶点v到顶点w和顶点w到顶点v之间都有路径,则称这两个顶点是<strong>强连通</strong>的</p>
<p>若无向图 G 中任意两个顶点都是连通的,则称图 G 为连通图,否则称为非连通图<br>
若有向图中任何一对顶点都是强连通的,则称此图为强连通图.</p>
<p>考点</p>
<ul>
<li>对于n个顶点的无向图G
<ul>
<li>若图G是连通图,则最少有n-1条边</li>
<li>若图G是非连通图,则最多可能有$c_{n-1}^2$ 条边</li>
</ul>
</li>
<li>对于n个顶点的有向图G
<ul>
<li>若G是强连通图,则最少有n条边(形成回路)</li>
</ul>
</li>
</ul>
<p><strong>子图</strong><br>
设有两个图 G=(V, E) 和 G&rsquo;=(V&rsquo;, E&rsquo;),若 V&rsquo; 是 V 的子集,且 E&rsquo; 是 E 的子集,则称G&rsquo; 是 G 的子图<br>
(子图的前提要求是G&rsquo;必须是一个<strong>图</strong>,并不是随便G的点的子集和边的子集合在一起就是子图,因为边是通过两个点确定的,如果只是取子集的话,可能会出现一条边,但是只有其中一个端点的情况)</p>
<p><strong>生成子图</strong><br>
若子图中的点包含了原图中所有的点,则称其为原图G的生成子图.</p>
<p><strong>连通分量</strong><br>
无向图中的<strong>极大连通子图</strong>称为<strong>连通分量</strong>.<br>
子图必须连通,且包含尽可能多的顶点和边</p>
<p>比如:
国家铁路图有三个连通分量</p>
<ul>
<li>大陆铁路网</li>
<li>海南岛铁路网</li>
<li>台湾铁路网</li>
</ul>
<p><strong>强连通分量</strong><br>
有向图中的<strong>极大强连通子图</strong>称为有向图的<strong>强连通分量</strong>.</p>
<p>连通图的生成树是包含图中全部顶点的一个<strong>极小连通子图</strong>(边要尽可能的少,但要保持连通)</p>
<p>若图中顶点数为n,则它的生成树含有n-1条边.对生成树而言,若砍去它的一条边,则会变成非连通图,若加上一条边则会形成一个回路.</p>
<p>在<strong>非连通图</strong>中,<strong>连通分量的生成树</strong>构成了非连通图的<strong>生成森林</strong></p>
<p><strong>边的权</strong>:在一个图中,每条边都可以标上具有某种含义的数值,该数值称为该边的权值.<br>
<strong>带权图/网</strong>:边上带有权值的图称为带权图,也称网.</p>
<p><strong>带权路径长度</strong>:当图是带权图时,一条路径上所有边的权值之和,称为该路径的带权路径长度</p>
<p><strong>无向完全图</strong>:无向图中任意两个顶点之间都存在边</p>
<p>若无向图的顶点数|V|=n,则 $|E|\in[0,C_n^2]=[0,\dfrac{n(n-1)}{2}]$</p>
<p><strong>有向完全图</strong>:有向图中任意两个顶点之间都存在方向相反的两条弧</p>
<p>若有向图的顶点数|V|=n,则 $|E|\in[0,2C_n^2]=[0,n(n-1)]$</p>
<p>边很少的图称为<strong>稀疏图</strong>,反之称为<strong>稠密图</strong>.</p>
<p>稀疏图和稠密图之间没有绝对的界限,一般来说|E|&lt;|V|log|V| 时,可以将G视为稀疏图.</p>
<p><strong>树</strong>:不存在回路,且连通的无向图<br>
n个顶点的树,则必有n-1条边</p>
<p>考点:n个顶点的图,若 |E|&gt;n-1,则一定有回路</p>
<p><strong>有向树</strong>:一个顶点的入度为0,其余顶点的入度均为1的有向图,称为有向树</p>
<h2 id="图的存储">图的存储</h2>
<h3 id="临接矩阵">临接矩阵</h3>
<p>无向图中，若两个顶点之间邻接，则为1，若两个顶点之间不邻接，则为0.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#define MaxVertexNum 100  </span><span style="color:#75715e">// 顶点数目的最大值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">char</span> Vex[MaxVertexNum]; <span style="color:#75715e">// 顶点表（顶点中可以存更复杂的信息）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">int</span> Edge[MaxVertexNum] [MaxVertexNum]; <span style="color:#75715e">// 邻接矩阵，边表（可以用bool型）
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">int</span> vexnum, arcnum; <span style="color:#75715e">// 图当前顶点数和边数/弧数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>} MGraph;
</span></span></code></pre></div><p>结点数为n的图G=(V, E) 的邻接矩阵A是n×n的。将G的顶点编号为 $v_1,v_2,\cdots,v_n$，则
$A[i][j]=\begin{cases}
1, &amp;\text{若}(v_i,v_j)\text{或}&lt;v_i,v_j&gt;\text{是}E(G)\text{中的边}\
0, &amp;\text{若}(v_i,v_j)\text{或}&lt;v_i,v_j&gt;\text{不是}E(G)\text{中的边}\
\end{cases}$</p>
<p>对于无向图的度，只要检查第i行或者第i列非零元素的个数即可<br>
对于有向图的度，出度为第i行非零元素个数，入度为第i列非零元素个数，第i个节点的度为第i行和第i列的非零元素个数之和</p>
<p><strong>存储带权图</strong><br>
将1换成对应边的权值，0换成无穷</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#define MaxVertexNum 100    </span><span style="color:#75715e">// 顶点数目的最大值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e">#define INFINITY 最大的int值 </span><span style="color:#75715e">// 宏定义常量“无穷”
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">char</span> VertexType;    <span style="color:#75715e">// 顶点的数据结构
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">int</span> EdgeType;       <span style="color:#75715e">// 带权图中边上权值的数据类型
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>  VertexType Vex[MaxVertexNum]; <span style="color:#75715e">// 顶点 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  EdgeType Edge[MaxVertexNum] [MaxVertexNum]; <span style="color:#75715e">// 边的权
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">int</span> vexnum. arcnum; <span style="color:#75715e">// 图的当前定点数和弧数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>} MGraph;
</span></span></code></pre></div><p>邻接矩阵法存储带权图可以用0或者无穷来表示两个点之间不存在边</p>
<p>邻接矩阵的空间复杂度为O(n^2)，适合用于存储稠密图<br>
易知，无向图的邻接矩阵是对称矩阵，可以压缩存储，只存储上三角区或下三角区（之前有说错如何存储压缩矩阵，简单图中不能直接和自己相连，因此主对角线上的元素都为空）</p>
<p><strong>邻接矩阵的性质</strong><br>
设无向图的邻接矩阵为 $\boldsymbol{A}$(矩阵元素为0/1)，则 $\boldsymbol{A}^n$ 的元素 $\boldsymbol{A}^n[i][j]$ 等于由顶点i到顶点j的长度为n的路径的数目</p>
<h3 id="邻接表">邻接表</h3>
<p>顶点</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> VNode{
</span></span><span style="display:flex;"><span>  VertexType data; <span style="color:#75715e">// 顶点信息
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  ArcNode <span style="color:#f92672">*</span>first;  <span style="color:#75715e">// 第一条边/弧
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>} VNode, AdjList [MaxVertexNum];
</span></span></code></pre></div><p>用邻接表存储的图</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>  AdjList vertices;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> vexnum, arcnum; <span style="color:#75715e">// 记录了有多少个顶点，多少条弧
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}ALGraph;
</span></span></code></pre></div><p>边/弧</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> ArcNode {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> adjvex; <span style="color:#75715e">// 当前这条边/弧指向哪个结点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">struct</span> ArcNode <span style="color:#f92672">*</span>next;<span style="color:#75715e">// 指向下一条弧的指针
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#75715e">// InfoType info; // 边权值
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}ArcNode;
</span></span></code></pre></div><p>邻接表法就是我把所有的结点列出来，比如有ABCD四个结点</p>
<table>
<thead>
<tr>
<th>结点</th>
<th>data</th>
<th>*first</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td></td>
<td></td>
</tr>
<tr>
<td>B</td>
<td></td>
<td></td>
</tr>
<tr>
<td>C</td>
<td></td>
<td></td>
</tr>
<tr>
<td>D</td>
<td></td>
<td></td>
</tr>
<tr>
<td>然后data存数据，*first存一条弧，然后弧指向下一条弧，这样下去</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>无向图使用邻接表法，会产生数据冗余，比如A到B有边，那么会有A到B和B到A的边，等于一条边记了两次，空间复杂度更高</p>
<p>有向图的空间复杂度更低</p>
<p>对于无向图来说，获得某个结点的度，只需要遍历该节点的边<br>
对于有向图来说，度=入度+出度，找出度很简单，遍历该节点即可，但是要获得入度则需要遍历所有的边，时间复杂度比较高</p>
<p>图的邻接表表示并不唯一，选*first比较随意，邻接矩阵法表示法唯一</p>
<table>
<thead>
<tr>
<th> </th>
<th>邻接表</th>
<th>邻接矩阵</th>
</tr>
</thead>
<tbody>
<tr>
<td>空间复杂度</td>
<td>无向图$O(|V|+2|E|)$；有向图$O(|V|+|E|)$</td>
<td>$O(|V|^2)$</td>
</tr>
<tr>
<td>适用于</td>
<td>存储稀疏图</td>
<td>存储稠密图</td>
</tr>
<tr>
<td>表示方式</td>
<td>不唯一</td>
<td>唯一</td>
</tr>
<tr>
<td>计算度</td>
<td>计算有向图的度、入度不方便，其余很方便</td>
<td>必须遍历对应行或列</td>
</tr>
<tr>
<td>找相邻的边</td>
<td>找有向图的入弧不方便，其余很方便</td>
<td>必须遍历对应行和列</td>
</tr>
</tbody>
</table>
<h3 id="十字链表法">十字链表法</h3>
<p>用于存储有向图</p>
<p>用一个数组存储<strong>顶点结点</strong></p>
<p>顶点结点存储</p>
<ul>
<li>数据域data</li>
<li>该顶点作为弧头的第一条弧firstin</li>
<li>该顶点作为弧尾的第一条弧firstout</li>
</ul>
<p>弧结点存储</p>
<ul>
<li>弧尾顶点编号tailvex</li>
<li>弧头顶点编号headvex</li>
<li>权值info(可能会没有)</li>
<li>弧头相同的下一条弧hlink</li>
<li>弧尾相同的下一条弧tlink</li>
</ul>
<p>这边的编号就是对应数组中顶点的索引，就是一个数字</p>
<p>空间复杂度为O(|V|+|E|)，只需要弧的数量和结点的数量即可<br>
相对于邻接矩阵法的空间复杂度为O(|V|^2) 小很多</p>
<h3 id="邻接多重表">邻接多重表</h3>
<p>用于存储无向图</p>
<p>邻接表和邻接矩阵存储无向图，删除边和结点会比较麻烦，因此可以使用邻接多重表</p>
<p>与十字链表法类似的，用一个数组存储<strong>顶点结点</strong></p>
<p>顶点结点存储</p>
<ul>
<li>数据域</li>
<li>与该顶点相连的第一条边</li>
</ul>
<p>边结点存储</p>
<ul>
<li>边的两个顶点编号i，j</li>
<li>权值info(可以没有)</li>
<li>依附于顶点i的下一条边</li>
<li>依附于顶点j的下一条边</li>
</ul>
<p>与十字链表法类似，边结点存储的顶点编号就是顶点结点在数组中的索引</p>
<table>
<thead>
<tr>
<th> </th>
<th>邻接矩阵</th>
<th>邻接表</th>
<th>十字链表</th>
<th>邻接多重表</th>
</tr>
</thead>
<tbody>
<tr>
<td>空间复杂度</td>
<td>$O(\mid V\mid^2)$</td>
<td>无向图O(|V|+2|E|);有向图O(|V|+|E|)</td>
<td>O(|V|+|E|)</td>
<td>O(|V|+|E|)</td>
</tr>
<tr>
<td>找相邻边</td>
<td>遍历对应行或列，时间复杂度为O(|V|)</td>
<td>找有向图的入边必须遍历整个邻接表</td>
<td>很方便</td>
<td>很方便</td>
</tr>
<tr>
<td>删除边或顶点</td>
<td>删除边方便，删除顶点需要大量移动数据</td>
<td>无向图中删除边或顶点都不方便</td>
<td>很方便</td>
<td>很方便</td>
</tr>
<tr>
<td>适用于</td>
<td>稠密图</td>
<td>稀疏图和其他</td>
<td>只能存有向图</td>
<td>只能存无向图</td>
</tr>
<tr>
<td>表达方式</td>
<td>唯一</td>
<td>不唯一</td>
<td>不唯一</td>
<td>不唯一</td>
</tr>
</tbody>
</table>
<h2 id="基本操作">基本操作</h2>
<p>因为基本操作和存储结构密不可分，所以我们这边以邻接矩阵和邻接表作为基本存储结构</p>
<p>基本操作：</p>
<ul>
<li>Adjacent(G,x,y):判断图G是否存在边&lt;x,y&gt;或&lt;y,x&gt;</li>
<li>Neighhbors(G,x):列出图G中与结点x邻接的边</li>
<li>InsertVertex(G,x):在图G中插入顶点x</li>
<li>DeleteVertex(G,x):从图G中删除顶点x</li>
<li>AddEdge(G,x,y):若无向边(x,y)或有向边&lt;x,y&gt;不存在，则向图G中添加该边</li>
<li>RemoveEdge(G,x,y):若无向边(x,y)或有向边&lt;x,y&gt;存在，则向图G中删除该边</li>
<li>FirstNeighbor(G,x):求图G中顶点x的第一个邻接点，若有则返回定顶点号，若x没有邻接点或图中不存在x，则返回-1</li>
<li>NextNeighbor(G,x,y):假设图G中顶点y是顶点x的一个邻接点，返回除y之外顶点x的下一个邻接点的顶点号，若y是x的最后一个邻接点，则返回-1</li>
<li>Get_edge_value(G,x,y):获得图G中边(x, y)或&lt;x,y&gt;对应的权值</li>
<li>Set_edge_value(G,x,y,v): 设置图G中边(x,y) 或 &lt;x,y&gt; 对应的权值为v</li>
</ul>
<p>Adjacent(G,x,y):判断图G是否存在边&lt;x,y&gt;或(x,y)</p>
<ul>
<li>无向图：
<ul>
<li>邻接矩阵，时间复杂度O(1)</li>
<li>邻接表，最坏时间复杂度O(|V|)</li>
</ul>
</li>
<li>有向图方法和无向图类似</li>
</ul>
<p>Neighbors(G,x):列出图G中与结点x邻接的边</p>
<ul>
<li>无向图
<ul>
<li>邻接矩阵，只需要遍历对应的行或者列，时间复杂度为O(|V|)</li>
<li>邻接表，遍历对应的结点最好为O(1)，最坏为O(|V|)</li>
</ul>
</li>
<li>有向图
<ul>
<li>邻接矩阵，遍历对应的行或列可以得到对应的入边和出边</li>
<li>邻接表，出边只要遍历对应结点即可，但是如果是入边则需要遍历整个邻接表</li>
</ul>
</li>
</ul>
<p>InsertVertex(G,x):在图G中插入顶点x</p>
<ul>
<li>无向图
<ul>
<li>邻接矩阵，将对应的行和列初始化为0，写入对应的数据O(1)</li>
<li>邻接表，将*first初始化为空，新增结点信息O(1)</li>
</ul>
</li>
<li>有向图类似</li>
</ul>
<p>DeleteVertex(G,x):从图G中删除顶点x</p>
<ul>
<li>无向图
<ul>
<li>邻接矩阵，一种是删除对应的行和列，然后移动其余的元素，拼接起来，另一种是将对应的行和列全部置为0，在结构体中增加一个bool类型，表示是否顶点是否是一个空顶点O(V)</li>
<li>邻接表，删除结点，以及其他元素和结点相连的边O(1)~O(|E|)</li>
</ul>
</li>
<li>有向图
<ul>
<li>邻接矩阵，和无向图一样</li>
<li>邻接表，删除出边，删除结点即可，删除入边，需要遍历整个表删除入边</li>
</ul>
</li>
</ul>
<p>AddEdge(G,x,y):若无向边(x,y)或有向边&lt;x,y&gt;不存在，则向图G中添加该边</p>
<ul>
<li>无向图
<ul>
<li>邻接矩阵，O(1)</li>
<li>邻接表，对应两个结点进行头插法，O(1)</li>
</ul>
</li>
<li>有向图基本一致O(1)</li>
</ul>
<p>FirstNeighbor(G,x):求图G中顶点x的第一个邻接点，若有则返回顶点号。若x没有邻接点或图中不存在x，则返回-1</p>
<ul>
<li>无向图
<ul>
<li>邻接矩阵，对对应的行进行遍历</li>
<li>邻接表，对对应的结点进行遍历</li>
</ul>
</li>
<li>有向图
<ul>
<li>邻接矩阵，出边扫描对应的行，找入边扫描对应的列</li>
<li>邻接表，找出边O(1)，找入边O(1)~O(|E|)</li>
</ul>
</li>
</ul>
<p>NextNeighbor(G,x,y):假设图G中顶点y是顶点x的一个邻接点，返回除y之外顶点x的下一个邻接点的顶点号，如果y是x的最后一个邻接点，则返回-1</p>
<ul>
<li>无向图
<ul>
<li>邻接矩阵，扫描对应的行</li>
<li>邻接表，遍历对应的结点</li>
</ul>
</li>
<li>有向图类似</li>
</ul>
<p>最后两个</p>
<ul>
<li>Get_edge_value(G,x,y):获得图G中边(x, y)或&lt;x,y&gt;对应的权值</li>
<li>Set_edge_value(G,x,y,v): 设置图G中边(x,y) 或 &lt;x,y&gt; 对应的权值为v</li>
</ul>
<p>主要的事件开销都在于寻找，所以和上面的类似</p>
<h2 id="图的遍历">图的遍历</h2>
<ul>
<li>广度优先遍历(BFS)</li>
<li>深度优先遍历(DFS)</li>
</ul>
<h3 id="广度优先遍历">广度优先遍历</h3>
<p>树的广度优先遍历和层序遍历差不多</p>
<p>树是特殊的图，因此图的广度优先和树的广度优先类似</p>
<p>图和树的区别在于，树不可能有回路，图可能有回路，因此我们可以通过增加一种数据来表示我们是否已经经过了这个点</p>
<p>广度优先遍历（Breadth-First-Search,BFS）要点：</p>
<ol>
<li>找到一个与一个顶点相邻的所有顶点</li>
<li>标记哪些顶点被访问过</li>
<li>需要一个辅助队列</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// 标记访问数组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">bool</span> visited [MAX_VERTEX_NUM]; 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 广度优先遍历
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 从顶点v出发，广度优先遍历图G
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">BFS</span>(Graph G, <span style="color:#66d9ef">int</span> v){
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">visit</span>(v);
</span></span><span style="display:flex;"><span>  visited[v] <span style="color:#f92672">=</span> TRUE;<span style="color:#75715e">//对v做已访问标记
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#a6e22e">Enqueue</span>(Q, v);    <span style="color:#75715e">// 顶点v入队列
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">while</span>(<span style="color:#f92672">!</span><span style="color:#a6e22e">isEmpty</span>(Q)){
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">DeQueue</span>(Q, v);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span>(w<span style="color:#f92672">=</span><span style="color:#a6e22e">FisrtNeighbor</span>(G,v);w<span style="color:#f92672">&gt;</span><span style="color:#ae81ff">0</span>;w<span style="color:#f92672">=</span><span style="color:#a6e22e">NextNeighbor</span>(G,v,w)){
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">// 检测v所有邻接点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>visited[w]){ <span style="color:#75715e">// w为v的尚未访问的邻接顶点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#a6e22e">visit</span>(w);  <span style="color:#75715e">// 访问顶点w
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        visited[w] <span style="color:#f92672">=</span> TRUE;<span style="color:#75715e">// 对w做已访问标记
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#a6e22e">EnQueue</span>(Q,w);<span style="color:#75715e">// 顶点w入队列
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>同一个图的邻接矩阵表示方式唯一，因此广度优先遍历序列唯一<br>
同一个图的邻接表表示方式不唯一，因此广度优先遍历序列不唯一</p>
<p>这个算法有一个问题，如果是非连通图，则无法遍历完所有结点，所以可以进行一定的改进</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// 对图G 进项广度优先遍历
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">BFSTraverse</span>(Graph G){
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> (i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span>G.vexnum;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 初始化标记数组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    visited[i] <span style="color:#f92672">=</span> FALSE;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">InitQueue</span>(Q);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span>(i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span>G.vexnum;i<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>visited[i])
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">BFS</span>(G,i);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>对于无向图，调用BFS函数的次数=连通分量数</p>
<p>这边其实还是有一些小问题，但是无伤大雅，比如这个队列Q应该定义为全局变量</p>
<p><strong>广度优先生成树</strong><br>
连通图根据广度优先遍历的过程得到的，保留广度优先遍历时经过的边，即可得到一个广度优先生成树，如果是非连通图则可得到广度优先生成森林</p>
<p>邻接表的表达方式不唯一，因此通过这种方法得到的广度优先生成树不唯一</p>
<h3 id="深度优先遍历">深度优先遍历</h3>
<p>树也有深度优先遍历：先根遍历和后根遍历，图的深度优先算法与树的先根遍历更相似</p>
<p>由于树的特性，访问到的结点一定是之前没有访问过的，因此和广度优先算法一样，也是需要一个visited数组来存储是否有被访问过</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> visited[MAX_VERTEX_NUM]; <span style="color:#75715e">// 访问标记数组
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">DFS</span>(Graph G, <span style="color:#66d9ef">int</span> v) {
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 访问顶点 v
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#a6e22e">visit</span>(v);
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 设已访问标记
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  visited[v] <span style="color:#f92672">=</span> TRUE;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> (w <span style="color:#f92672">=</span> <span style="color:#a6e22e">FirstNeighbor</span>(G,v);w<span style="color:#f92672">&gt;=</span><span style="color:#ae81ff">0</span>;w<span style="color:#f92672">=</span><span style="color:#a6e22e">NextNeighbor</span>(G,v,w)){
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// w 为u的尚未访问的邻接顶点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>visited[w]){
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">DFS</span>(G,w);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>同样的，如果是非连通图，还需要加上</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">DFSTraverse</span>(Graph G) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> (v<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;v<span style="color:#f92672">&lt;</span>G.vexnum; v<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>    visited[v] <span style="color:#f92672">=</span> FALSE;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> (v<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;v<span style="color:#f92672">&lt;</span>G.vexnum; v<span style="color:#f92672">++</span>){
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>visited[v])
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">DFS</span>(G, v);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>与广度优先遍历相同的，如果存储方式是邻接矩阵的话，遍历序列是唯一的，如果存储方式是邻接表的话，遍历序列是不唯一的</p>
<p>深度优先生成树和广度优先生成树类似，深度优先生成森林和广度优先生成森林类似</p>
<p>调用深度优先遍历的次数=连通分量的个数</p>
<h2 id="最小生成树">最小生成树</h2>
<p><strong>连通图</strong>的生成树包含图中全部顶点的一个<strong>极小连通子图</strong>。</p>
<p><strong>最小生成树（最小代价树）</strong><br>
对于一个带权连通无向图G=(V,E) ，生成树不同，每棵树的权（即树中所有边上的权值之和）也可能不同。设R为G的所有生成树的集合，若T为R中边的权值之和最小的生成树，则T称为G的最小生成树（Minimum-Spanning-Tree，MST）</p>
<p>最小生成树可能有多个，但边的权值之和总是唯一且最小的<br>
最小生成树的边数=顶点数-1.砍掉一条则不连通，增加一条则会出现回路</p>
<p>如果一个连通图本身就是一棵树，则其最小生成树就是它本身</p>
<p>只有连通图才有生成树，非连通图只有生成森林</p>
<p>Prim（普里姆）算法：</p>
<ul>
<li>从某一个顶点开始构建生成树</li>
<li>每次将代价最小（指纳入的顶点到没纳入的顶点之间的边权值最小的）的新顶点纳入生成树，直到所有顶点都纳入为止</li>
</ul>
<p>时间复杂度为O(|V|^2) 适用于边稠密图</p>
<p>Kruskal算法：</p>
<ul>
<li>每次挑选权值最小的一条边，使这条边的两头连通（如果选了会产生回路的就不选），直到所有节点都连通</li>
</ul>
<p>时间复杂度为O(|E|log_2|E|) 适用于边稀疏图</p>
<h2 id="最短路径问题">最短路径问题</h2>
<ul>
<li>单源最短路径问题</li>
<li>每对顶点间的最短路径问题</li>
</ul>
<p>最短路径问题：</p>
<ul>
<li>单源最短路径
<ul>
<li>BFS算法（无权图）</li>
<li>Dijkstra算法（带权图、无权图）</li>
</ul>
</li>
<li>各顶点间的最短路径
<ul>
<li>Floyd算法（带权图、无权图）</li>
</ul>
</li>
</ul>
<p>无权图其实可以看做一种特殊的带权图，只是每条边的权值都为1，或者看成相同的权值</p>
<p>求顶点 u 到其他顶点的最短路径</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">BFS_MIN_Distance</span>(Graph G, <span style="color:#66d9ef">int</span> u){
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// d[i] 表示u到i结点的最短路径
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span>G.vexnum; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>    d[i] <span style="color:#f92672">=</span> <span style="color:#960050;background-color:#1e0010">∞</span>;<span style="color:#75715e">//初始化路径长度，无穷只是表意，但是实际上不可以存无穷，实际可以写-1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    path[i] <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;<span style="color:#75715e">//最短路径从哪个顶点过来
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  }
</span></span><span style="display:flex;"><span>  d[u]<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>  visited[u] <span style="color:#f92672">=</span> FALSE;
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">EnQueue</span>(Q, u);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">while</span>(<span style="color:#f92672">!</span><span style="color:#a6e22e">isEmpty</span>(Q)) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 队头元素 u 出队
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">DeQueue</span>(Q, u);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (w<span style="color:#f92672">=</span><span style="color:#a6e22e">FirstNeighbor</span>(G,u);w<span style="color:#f92672">&gt;=</span><span style="color:#ae81ff">0</span>;w<span style="color:#f92672">=</span><span style="color:#a6e22e">NextNeighbor</span>(G,u,w)){
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>visited[w]){
</span></span><span style="display:flex;"><span>        d[w] <span style="color:#f92672">=</span>d[u]<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        path[w] <span style="color:#f92672">=</span> u;
</span></span><span style="display:flex;"><span>        visited[w] <span style="color:#f92672">=</span> TRUE;
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">EnQueue</span>(Q,w);
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="dijkstra算法">Dijkstra算法</h2>
<p>BFS算法的局限性，是默认权相同<br>
带权路径长度：当图是带权图时，一条路径上所有边的权值之和，称为该路径的带权路径长度，简称路径长度</p>
<p><strong>声明</strong>：Dijkstra算法不适用于负权图，后面再举例，现在我们先假设都是正权图</p>
<p>算法：</p>
<ul>
<li>找到起始点v_0</li>
<li>初始化数组
<ul>
<li>final数组：标记各个顶点是否已经找到最短路径</li>
<li>dist数组：最短路径长度</li>
<li>path数组：路径上的前驱</li>
</ul>
</li>
<li>找到final中为false，并且dist最小的点，假设为v_1</li>
<li>更新final，dist，path</li>
<li>重复更新，直到final所有都为true</li>
</ul>
<p>初始化final：v_0对应的final为true，其他为false<br>
初始化dist：从v_0直接到各个点的距离，如果没有直接相连，那么距离为无穷<br>
初始化path：与v_0直接相连的点path记为v_0的索引,v_0对应的path值为0</p>
<p>更新final：v_1的final设为true<br>
更新dist、path：与v_1直接相连，且final为false的点，比较这些点的dict与（v_1到这些点的距离+v_1对应的dict）的大小，如果后者更小，那么将这些连接的点的dict更新成小的，并且将这些点的path更新成v_1的索引，如果后者更大，就不变</p>
<p>每次更新都会将final中的一个点转化为true，因此只需要更新n-1次，就能获得指定点到所有点的最短距离</p>
<p>整个算法的时间复杂度为 O(n^2)</p>
<p>Dijkstra算法不适用于负权图，例子如下</p>
<pre tabindex="0"><code class="language-mermaid" data-lang="mermaid">graph LR
A((A)) --10--&gt; B((B))
B -- -5--&gt; C((C))
A --7--&gt; C
</code></pre><p>假设从A出发，那么</p>
<table>
<thead>
<tr>
<th> </th>
<th>A</th>
<th>B</th>
<th>C</th>
</tr>
</thead>
<tbody>
<tr>
<td>final</td>
<td>true</td>
<td>false</td>
<td>false</td>
</tr>
<tr>
<td>dist</td>
<td>0</td>
<td>10</td>
<td>7</td>
</tr>
<tr>
<td>path</td>
<td>-1</td>
<td>0</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>我们发现dist最小的值为7，对应C，因此进行更新</p>
<table>
<thead>
<tr>
<th> </th>
<th>A</th>
<th>B</th>
<th>C</th>
</tr>
</thead>
<tbody>
<tr>
<td>final</td>
<td>true</td>
<td>false</td>
<td>true</td>
</tr>
<tr>
<td>dist</td>
<td>0</td>
<td>10</td>
<td>7</td>
</tr>
<tr>
<td>path</td>
<td>-1</td>
<td>0</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>因为C不能到B，因此继续选择final为false，dist最小的B，再次更新</p>
<table>
<thead>
<tr>
<th> </th>
<th>A</th>
<th>B</th>
<th>C</th>
</tr>
</thead>
<tbody>
<tr>
<td>final</td>
<td>true</td>
<td>true</td>
<td>true</td>
</tr>
<tr>
<td>dist</td>
<td>0</td>
<td>10</td>
<td>7</td>
</tr>
<tr>
<td>path</td>
<td>-1</td>
<td>0</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>但是实际上，A到C的最短带权路径长度为5,这时候Dijkstra算法失效</p>
<h2 id="floyd算法">Floyd算法</h2>
<p>用于求解每一对顶点之间的最短路径 <br>
使用动态规划思想，将问题的求解分为多个阶段</p>
<p>初始化矩阵A，和path矩阵，初始化时，假设不能再任何点中转，计算两个点之间的距离，A是路径长度，如果两个点之间不能直接相连，那么路径长度为无穷，path存两个点之间的中转点，一开始全是-1</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// 考虑以V_k作为中转点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// 把每个点加入中转点可选项
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> k<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; k<span style="color:#f92672">&lt;</span>n; k<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#960050;background-color:#1e0010">接下来遍历整个矩阵</span>
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; i<span style="color:#f92672">&lt;</span>n; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; j<span style="color:#f92672">&lt;</span>n; j<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> (A[i] [j]<span style="color:#f92672">&gt;</span>A[i][k]<span style="color:#f92672">+</span>A[k][k]){
</span></span><span style="display:flex;"><span>        A[i][j] <span style="color:#f92672">=</span> A[i][k]<span style="color:#f92672">+</span>A[k][j];
</span></span><span style="display:flex;"><span>        path[i][j] <span style="color:#f92672">=</span> k;
</span></span><span style="display:flex;"><span>      }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>时间复杂度为 O(n^3)，空间复杂度为 O(n^2)</p>
<p>Floyd算法可以解决一些带负权值的图，但是无法解决带有“负权回路”的图这种图可能没有最短路径</p>
<pre tabindex="0"><code class="language-mermaid" data-lang="mermaid">graph LR
A((A)) -- -9--&gt; B((B))
B --3--&gt; C((C))
C --5--&gt; A
</code></pre><table>
<thead>
<tr>
<th> </th>
<th>BFS算法</th>
<th>Dijkstra算法</th>
<th>Floyd算法</th>
</tr>
</thead>
<tbody>
<tr>
<td>无权图</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>带权图</td>
<td>×</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>带负权值的图</td>
<td>×</td>
<td>×</td>
<td>√(部分)</td>
</tr>
<tr>
<td>带负权回路的图</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr>
<tr>
<td>时间复杂度</td>
<td>O(|V|^2)或O(|V|+|E|)(看存储方式)</td>
<td>O(|V|^2)</td>
<td>O(|V|^3)</td>
</tr>
<tr>
<td>通常用于</td>
<td>求无权图的单源最短路径</td>
<td>求带权图的单源最短路径</td>
<td>求带权图中个顶点间的最短路径</td>
</tr>
</tbody>
</table>
<h2 id="有向无环图dag">有向无环图(DAG)</h2>
<p><strong>有向无环图</strong>：若一个有向图中不存在环，则称为有向无环图，简称DAG(Directed Acyclic Graph)</p>
<p>在树中有时候会出现完全相同的部分，为了节省空间，我们可以只存一份，两个结点都指向这一份，形成有向无环图，因为结点永远向下指(可能说起来不严谨)，因此永远都不会形成环</p>
<p>例如：<br>
表达式 (x+y)*((x+y)/x)，用树表达为</p>
<pre tabindex="0"><code class="language-mermaid" data-lang="mermaid">graph TD;
A((*)) --&gt; B((+));
A --&gt; C((/));
B --&gt; X((x));
B --&gt; Y((y));
C --&gt; D((+));
C --&gt; X2((x));
D --&gt; X3((x));
D --&gt; Y2((y));
</code></pre><p>我们会发现其中有一些子树是完全一样的，我们可以只保留一份，比如</p>
<pre tabindex="0"><code class="language-mermaid" data-lang="mermaid">graph TD;
A((*)) --&gt; B((+));
A --&gt; C((/));
B --&gt; X((x));
B --&gt; Y((y));
C --&gt; B;
C --&gt; X2((x));
</code></pre><p>其实仔细观察，会发现单独的两个x也是重复的结点，因此我们可以再次改造</p>
<pre tabindex="0"><code class="language-mermaid" data-lang="mermaid">graph TD;
A((*)) --&gt; B((+));
A --&gt; C((/));
B --&gt; X((x));
B --&gt; Y((y));
C --&gt; B;
C --&gt; X;
</code></pre><p>这样就得到了最后的有向无环图</p>
<h2 id="拓扑排序">拓扑排序</h2>
<p>AOV网(Activity On Vertex Network,用顶点表示活动的网)<br>
用DAG图(有向无环图)表示一个工程。顶点表示活动，有向边&lt;V_i, V_j&gt; 表示活动 V_i 必须先于活动 V_j 进行</p>
<p>拓扑排序的定义：在图论中，由一个有向无环图的顶点组成的序列，当且仅当满足下列条件时，成为该图的一个拓扑排序：</p>
<ol>
<li>每个顶点出现且只出现一次</li>
<li>若顶点A在序列中排在顶点B的前面，则在图中不存在从顶点B到顶点A的路径</li>
</ol>
<p>拓扑排序的实现：</p>
<ul>
<li>从AOV网中选择一个没有前驱(入度为0)的顶点并输出</li>
<li>从网中删除该顶点和所有以它为起点的有向边</li>
<li>重复上面两个步骤知道当前AOV网为空或当前网中不存在无前驱的顶点为止</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">TopologicSort</span> (Graph G) {
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 初始化栈，用于存储入度为0的顶点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#a6e22e">InitStack</span>(S);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; i<span style="color:#f92672">&lt;</span>G.vexnum; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (indegree[i]<span style="color:#f92672">==</span><span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">// 将所有入度为0的顶点进栈
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      <span style="color:#a6e22e">Push</span>(S, i);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 计数，记录当前已经输出的顶点数
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">int</span> count <span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 栈不空，则存在入度为0的顶点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">while</span>(<span style="color:#f92672">!</span><span style="color:#a6e22e">isEmpty</span>(S)){
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 栈顶元素出栈
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#a6e22e">Pop</span>(S, i);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 输出顶点i
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    print[count<span style="color:#f92672">++</span>] <span style="color:#f92672">=</span> i;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 这里假设图用邻接表存储
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> (p<span style="color:#f92672">=</span>G.vertices[i].firstarc;p;p<span style="color:#f92672">-&gt;</span>nextarc) {
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">// 将所有i指向的顶点的入度减1，并且将入减为0的顶点压入栈S
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      v <span style="color:#f92672">=</span> p<span style="color:#f92672">-&gt;</span>adjvex;
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>(<span style="color:#f92672">--</span>indegree[v]))
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// 入度为0，则压入栈
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#a6e22e">Push</span>(S, v);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span>(count <span style="color:#f92672">&lt;</span> G.vexnum)
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 排序失败，说明有回路
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">else</span> 
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 拓扑排序成功
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><strong>逆拓扑排序</strong><br>
拓扑排序是删除入度为0的顶点，逆拓扑排序是删除出度为0的顶点，用邻接表实现会比较麻烦，可以考虑逆邻接表或者邻接矩阵</p>
<p>还可以用DFS算法实现逆拓扑排序</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// 对图G进行深度优先遍历
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">DFSTraverse</span> (Graph G) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> v;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> (v<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; v<span style="color:#f92672">&lt;</span>G.vexnum; v<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 初始化
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    visited[v] <span style="color:#f92672">=</span> FALSE;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> (v<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; v<span style="color:#f92672">&lt;</span>G.vexnum; v<span style="color:#f92672">++</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>visited[v])
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">DFS</span>(G, v);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">DFS</span>(Graph G, <span style="color:#66d9ef">int</span> v){
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// 从顶点v出发，深度优先遍历图G
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  visited[v] <span style="color:#f92672">=</span> TRUE;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> (w<span style="color:#f92672">=</span> <span style="color:#a6e22e">FisrtNeighbor</span>(G,v); w<span style="color:#f92672">&gt;=</span><span style="color:#ae81ff">0</span>; w<span style="color:#f92672">=</span><span style="color:#a6e22e">NextNeighbor</span>(G,v,w))
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>visited[w])
</span></span><span style="display:flex;"><span>      <span style="color:#75715e">// w 为 u 尚未访问的邻接顶点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>      <span style="color:#a6e22e">DFS</span>(G, w);
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">print</span>(v); <span style="color:#75715e">// 输出顶点，这里有点不严谨，只是为了表意
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>推出调用栈之前才会输出v，这里事实上没有对回路进行判断</p>
<h2 id="关键路径">关键路径</h2>
<p>AOE网(Activity On Edge Network)<br>
在带权有向图中，以顶点表示事件，以有向边表示活动，以边上的权值表示完成该活动的开销(如：完成活动所需的时间)，称之为用边表示活动的网络，简称AOE网</p>
<p>在AOE网中仅有一个入度为0的顶点，称为开始顶点（源点），表示整个工程的开始，也仅有一个出度为0的顶点，称为结束顶点（汇点），表示整个工程的结束</p>
<p>从源点到汇点的有向路径中可能有多条，所有路径中，具有最大路径长的路径称为<strong>关键路径</strong>，而把关键路径上的活动称为<strong>关键活动</strong></p>
<p>完成整个工程的最短时间就是关键路径的长度，若关键活动不能按时完成，则整个工程的完成时间就会延长</p>
<p>事件v_k的最早发生时间ve(k):决定了所有从v_k开始的活动能够开工的最早时间<br>
活动a_i的最早开始时间e(i)：指该活动弧的起点所表示的时间的最早发生时间</p>
<p>时间v_k的最迟发生时间vl(k):它是指在不推迟整个工程完成的前提下，该时间最迟必须发生的时间<br>
活动a_i的最迟开始时间l(i)：他是指该活动弧的终点缩表四时间的最迟发生时间与该活动所需时间之差</p>
<p>活动a_i的时间余量d(i)=l(i)-e(i)，表示在不增加完成整个工程所需总时间的情况下，活动a_i可以拖延的时间</p>
<p>若一个活动的时间余量为零，则说明该活动必须要如期完成，d(i)=0 即 l(i)=e(i) ，活动a_i 是关键活动，由关键活动组成的路径就是关键路径</p>
<p>自然地，如果关键活动耗时增加，则震哥哥工程的工期将增长<br>
缩短关键活动的时间，可以缩短整个工程的工期<br>
当缩短到一定程度时，关键活动可能会变成非关键活动</p>
<p>在AOE网中可能会存在多条关键路径，值提高一条关键路径上的关键活动速度并不能缩短整个工程的工期，只有加快哪些包括在所有关键路径上的关键活动才能达到缩短工期的目的</p>

    </div>
    <div class="post-footer">
      
    </div>
  </article>

    </main>
  </body>
</html>
