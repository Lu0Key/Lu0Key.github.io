<!doctype html>
<html lang="en-us">

<head>
    
    <title>Leetcode 451 根据字符出现频率排序 // 洛七的摸鱼池塘</title>
    <link rel="shortcut icon" href="%20/favicon.ico%20" />
    <meta charset="utf-8" /> <meta name="generator" content="Hugo 0.80.0" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="洛七" />
    <meta name="description" content="" /> <link rel="stylesheet" href="https://Lu0key.github.io/css/main.min.88e7083eff65effb7485b6e6f38d10afbec25093a6fac42d734ce9024d3defbd.css" />  <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Leetcode 451 根据字符出现频率排序"/>
<meta name="twitter:description" content="根据字符出现频率排序(Sort Characters By Frequency) 给定一个字符串，请将字符串里的字符按照出现的频率降序排列。
示例 1:
输入: &quot;tree&quot; 输出: &quot;eert&quot; 解释: &#39;e&#39;出现两次，&#39;r&#39;和&#39;t&#39;都只出现一次。 因此&#39;e&#39;必须出现在&#39;r&#39;和&#39;t&#39;之前。此外，&quot;eetr&quot;也是一个有效的答案。 示例 2:
输入: &quot;cccaaa&quot; 输出: &quot;cccaaa&quot; 解释: &#39;c&#39;和&#39;a&#39;都出现三次。此外，&quot;aaaccc&quot;也是有效的答案。 注意&quot;cacaca&quot;是不正确的，因为相同的字母必须放在一起。 示例 3:
输入: &quot;Aabb&quot; 输出: &quot;bbAa&quot; 解释: 此外，&quot;bbaA&quot;也是一个有效的答案，但&quot;Aabb&quot;是不正确的。 注意&#39;A&#39;和&#39;a&#39;被认为是两种不同的字符。 char * frequencySort(char * s){ int count[128] = {0}; for (int i = 0; i &lt; strlen(s); &#43;&#43;i) { count[s[i]]&#43;&#43;; } for (int k = 0; k &lt; strlen(s); &#43;&#43;k) { for (int i = 0; i&#43;1 &lt; strlen(s); &#43;&#43;i) { if(count[s[i]] &lt; count[s[i&#43;1]] || count[s[i]] == count[s[i&#43;1]] &amp;&amp; s[i] &gt; s[i&#43;1]){ char temp = s[i]; s[i] = s[i&#43;1]; s[i&#43;1] = temp; } } } return s; } 可以用，但是会TLE，一般遇到排序的时候，如果没有用快排，而是用冒泡排序这种O(n^2)时间复杂度的算法，都很可能会超时"/>
 <meta property="og:title" content="Leetcode 451 根据字符出现频率排序" />
<meta property="og:description" content="根据字符出现频率排序(Sort Characters By Frequency) 给定一个字符串，请将字符串里的字符按照出现的频率降序排列。
示例 1:
输入: &quot;tree&quot; 输出: &quot;eert&quot; 解释: &#39;e&#39;出现两次，&#39;r&#39;和&#39;t&#39;都只出现一次。 因此&#39;e&#39;必须出现在&#39;r&#39;和&#39;t&#39;之前。此外，&quot;eetr&quot;也是一个有效的答案。 示例 2:
输入: &quot;cccaaa&quot; 输出: &quot;cccaaa&quot; 解释: &#39;c&#39;和&#39;a&#39;都出现三次。此外，&quot;aaaccc&quot;也是有效的答案。 注意&quot;cacaca&quot;是不正确的，因为相同的字母必须放在一起。 示例 3:
输入: &quot;Aabb&quot; 输出: &quot;bbAa&quot; 解释: 此外，&quot;bbaA&quot;也是一个有效的答案，但&quot;Aabb&quot;是不正确的。 注意&#39;A&#39;和&#39;a&#39;被认为是两种不同的字符。 char * frequencySort(char * s){ int count[128] = {0}; for (int i = 0; i &lt; strlen(s); &#43;&#43;i) { count[s[i]]&#43;&#43;; } for (int k = 0; k &lt; strlen(s); &#43;&#43;k) { for (int i = 0; i&#43;1 &lt; strlen(s); &#43;&#43;i) { if(count[s[i]] &lt; count[s[i&#43;1]] || count[s[i]] == count[s[i&#43;1]] &amp;&amp; s[i] &gt; s[i&#43;1]){ char temp = s[i]; s[i] = s[i&#43;1]; s[i&#43;1] = temp; } } } return s; } 可以用，但是会TLE，一般遇到排序的时候，如果没有用快排，而是用冒泡排序这种O(n^2)时间复杂度的算法，都很可能会超时" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://Lu0key.github.io/post/leetcode-451-sort-characters-by-frequency/" />
<meta property="article:published_time" content="2021-03-25T18:15:20+08:00" />
<meta property="article:modified_time" content="2021-03-25T18:15:20+08:00" />


</head>

<body>
    <header class="app-header">
        <a href="https://Lu0key.github.io/"><img class="app-header-avatar" src="/avatar.jpg" alt="洛七" /></a>
        <h1>洛七的摸鱼池塘</h1>
        <nav class="app-header-menu">
            <a class="app-header-menu-item" href="/tags/">Tags</a>
        </nav>
        <p>即将没书读的咸鱼</p>
        <div class="app-header-social">
            
        </div>
    </header>
    <main class="app-container">
        
  <article class="post">
    <header class="post-header">
      <h1 class ="post-title">Leetcode 451 根据字符出现频率排序</h1>
      <div class="post-meta">
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar">
  <title>calendar</title>
  <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line>
</svg>
          Mar 25, 2021
        </div>
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock">
  <title>clock</title>
  <circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline>
</svg>
          1 min read
        </div>
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tag">
  <title>tag</title>
  <path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path><line x1="7" y1="7" x2="7" y2="7"></line>
</svg>
              <a class="tag" href="https://Lu0key.github.io/tags/leetcode/">leetcode</a>
        </div>
      </div>
    </header>
    <div class="post-content">
      <h1 id="根据字符出现频率排序sort-characters-by-frequencyhttpsleetcode-cncomproblemssort-characters-by-frequency"><a href="https://leetcode-cn.com/problems/sort-characters-by-frequency/">根据字符出现频率排序(Sort Characters By Frequency)</a></h1>
<p>给定一个字符串，请将字符串里的字符按照出现的频率降序排列。</p>
<p><strong>示例 1:</strong></p>
<pre><code>输入:
&quot;tree&quot;

输出:
&quot;eert&quot;

解释:
'e'出现两次，'r'和't'都只出现一次。
因此'e'必须出现在'r'和't'之前。此外，&quot;eetr&quot;也是一个有效的答案。
</code></pre><p><strong>示例 2:</strong></p>
<pre><code>输入:
&quot;cccaaa&quot;

输出:
&quot;cccaaa&quot;

解释:
'c'和'a'都出现三次。此外，&quot;aaaccc&quot;也是有效的答案。
注意&quot;cacaca&quot;是不正确的，因为相同的字母必须放在一起。
</code></pre><p><strong>示例 3:</strong></p>
<pre><code>输入:
&quot;Aabb&quot;

输出:
&quot;bbAa&quot;

解释:
此外，&quot;bbaA&quot;也是一个有效的答案，但&quot;Aabb&quot;是不正确的。
注意'A'和'a'被认为是两种不同的字符。
</code></pre><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">frequencySort</span>(<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span> s){
    <span style="color:#66d9ef">int</span> count[<span style="color:#ae81ff">128</span>] <span style="color:#f92672">=</span> {<span style="color:#ae81ff">0</span>};
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> strlen(s); <span style="color:#f92672">++</span>i) {
        count[s[i]]<span style="color:#f92672">++</span>;
    }

    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> k <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; k <span style="color:#f92672">&lt;</span> strlen(s); <span style="color:#f92672">++</span>k) {
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;</span> strlen(s); <span style="color:#f92672">++</span>i) {
            <span style="color:#66d9ef">if</span>(count[s[i]] <span style="color:#f92672">&lt;</span> count[s[i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>]] <span style="color:#f92672">||</span>
            count[s[i]] <span style="color:#f92672">==</span> count[s[i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>]] <span style="color:#f92672">&amp;&amp;</span> s[i] <span style="color:#f92672">&gt;</span> s[i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>]){
                <span style="color:#66d9ef">char</span> temp <span style="color:#f92672">=</span> s[i];
                s[i] <span style="color:#f92672">=</span> s[i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>];
                s[i<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> temp;
            }
        }
    }
    <span style="color:#66d9ef">return</span> s;
}
</code></pre></div><p>可以用，但是会TLE，一般遇到排序的时候，如果没有用快排，而是用冒泡排序这种O(n^2)时间复杂度的算法，都很可能会超时</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">// 如果要交换位子，则返回正数
</span><span style="color:#75715e">// 如果不交换位置，则返回负数
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> globalCount;
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">cmp</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> a, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> b){
    <span style="color:#66d9ef">int</span> diff  <span style="color:#f92672">=</span> globalCount[<span style="color:#f92672">*</span>b] <span style="color:#f92672">-</span> globalCount[<span style="color:#f92672">*</span>a];
    <span style="color:#66d9ef">if</span> (diff <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>){
        <span style="color:#66d9ef">return</span> <span style="color:#f92672">*</span>a<span style="color:#f92672">-*</span>b;
    }
    <span style="color:#66d9ef">return</span> diff;
}

<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">frequencySort</span>(<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span> s){
    <span style="color:#66d9ef">int</span> count[<span style="color:#ae81ff">128</span>] <span style="color:#f92672">=</span> {<span style="color:#ae81ff">0</span>};
    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> strlen(s); <span style="color:#f92672">++</span>i) {
        count[s[i]]<span style="color:#f92672">++</span>;
    }
    globalCount <span style="color:#f92672">=</span> count;
    qsort(s,strlen(s),<span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">char</span>), cmp);
    <span style="color:#66d9ef">return</span> s;
}
</code></pre></div><p>这边用到了qsort，这是一种复合的排序方式，有可能会好多种排序方式，根据被排序的东西决定</p>

    </div>
    <div class="post-footer">
      
    </div>
  </article>

    </main>
</body>

</html>