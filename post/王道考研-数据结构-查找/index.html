<!doctype html>
<html lang="en-us">
  <head>
    <title>王道考研 数据结构 查找 // 洛七的摸鱼池塘</title>
    <link rel="shortcut icon" href="/favicon.ico" />
    <meta charset="utf-8" />
    <meta name="generator" content="Hugo 0.115.4">
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="洛七" />
    <meta name="description" content="" />
    <link rel="stylesheet" href="/css/main.min.d08c6ce68432c68a64d84cb426dfdecab702035f91a5d580831f23f76c040a05.css" />

    
    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="王道考研 数据结构 查找"/>
<meta name="twitter:description" content="查找 查找 基本概念 顺序查找 折半查找 分块查找 B树 B树的插入和删除 插入 删除 B&#43;树 散列查找 散列表(Hash Table) 开放定址法 平方探测法 伪随机序列法 再散列法 基本概念 查找：在数据集合中寻找满足某种条件的数据元素的过程称为查找
查找表(查找结构)：用于查找的数据集合称为查找表，它由同一类型的数据元素(或记录组成)
关键字：数据元素中唯一标识该元素的某个数据项的值，使用基于关键字的查找，查找结果应该是唯一的(比如学号)
常见操作
查找符合条件的数据元素 插入、删除某个数据元素 如果只进行操作1——静态查找表即可
也要进行操作2——动态查找表
评价指标
查找长度：在查找运算中，需要对比关键字的次数称为查找长度
平均查找长度(ASL)：所有查找过程中进行关键字的比较次数的平均值
$\displaystyle ASL=\sum_{i=1}^nP_iC_i$
其中n为数据元素个数，C_i为查找第i个元素的查找长度，P_i为查找第i个元素的概率
ASL的数量级放映了查找算法时间复杂度
评价一个查找算法的效率时，通常考虑查找成功/失败两种情况的ASL
顺序查找 顺序查找，又叫“线性查找”，通常用于线性表(顺序表、链表)
算法思想：从头到尾一个一个对比
顺序查找的实现
// 查找表的数据结构(顺序表) typedef struct { // 动态数组的基址(剩下靠偏移量) Elemtypr *elem; // 表的长度 int TableLen; }SSTable; // 顺序查找 int Search_Seq(SSTable ST, ElemType key) { int i; // for循环空语句 for (i=0;i&lt;ST.TableLen &amp;&amp; ST.elem[i] != key; i&#43;&#43;); // 查找成功，则返回元素下标；查找失败，则返回-1 return i==ST."/>

    <meta property="og:title" content="王道考研 数据结构 查找" />
<meta property="og:description" content="查找 查找 基本概念 顺序查找 折半查找 分块查找 B树 B树的插入和删除 插入 删除 B&#43;树 散列查找 散列表(Hash Table) 开放定址法 平方探测法 伪随机序列法 再散列法 基本概念 查找：在数据集合中寻找满足某种条件的数据元素的过程称为查找
查找表(查找结构)：用于查找的数据集合称为查找表，它由同一类型的数据元素(或记录组成)
关键字：数据元素中唯一标识该元素的某个数据项的值，使用基于关键字的查找，查找结果应该是唯一的(比如学号)
常见操作
查找符合条件的数据元素 插入、删除某个数据元素 如果只进行操作1——静态查找表即可
也要进行操作2——动态查找表
评价指标
查找长度：在查找运算中，需要对比关键字的次数称为查找长度
平均查找长度(ASL)：所有查找过程中进行关键字的比较次数的平均值
$\displaystyle ASL=\sum_{i=1}^nP_iC_i$
其中n为数据元素个数，C_i为查找第i个元素的查找长度，P_i为查找第i个元素的概率
ASL的数量级放映了查找算法时间复杂度
评价一个查找算法的效率时，通常考虑查找成功/失败两种情况的ASL
顺序查找 顺序查找，又叫“线性查找”，通常用于线性表(顺序表、链表)
算法思想：从头到尾一个一个对比
顺序查找的实现
// 查找表的数据结构(顺序表) typedef struct { // 动态数组的基址(剩下靠偏移量) Elemtypr *elem; // 表的长度 int TableLen; }SSTable; // 顺序查找 int Search_Seq(SSTable ST, ElemType key) { int i; // for循环空语句 for (i=0;i&lt;ST.TableLen &amp;&amp; ST.elem[i] != key; i&#43;&#43;); // 查找成功，则返回元素下标；查找失败，则返回-1 return i==ST." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://Lu0key.github.io/post/%E7%8E%8B%E9%81%93%E8%80%83%E7%A0%94-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%9F%A5%E6%89%BE/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2021-03-01T08:27:27+08:00" />
<meta property="article:modified_time" content="2021-03-01T08:27:27+08:00" />


  </head>
  <body>
    <header class="app-header">
      <a href="https://Lu0key.github.io/"><img class="app-header-avatar" src="/avatar.jpg" alt="洛七" /></a>
      <span class="app-header-title">洛七的摸鱼池塘</span>
      <nav class="app-header-menu">
          <a class="app-header-menu-item" href="/tags/">Tags</a>
      </nav>
      <p>即将没书读的咸鱼</p>
    </header>
    <main class="app-container">
      
  <article class="post">
    <header class="post-header">
      <h1 class ="post-title">王道考研 数据结构 查找</h1>
      <div class="post-meta">
        <div>
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar">
  <title>calendar</title>
  <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line>
</svg>
          Mar 1, 2021
        </div>
        <div>
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock">
  <title>clock</title>
  <circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline>
</svg>
          3 min read
        </div>
        <div>
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tag">
  <title>tag</title>
  <path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path><line x1="7" y1="7" x2="7.01" y2="7"></line>
</svg>
              <a class="tag" href="https://Lu0key.github.io/tags/%E8%80%83%E7%A0%94/">考研</a>
              <a class="tag" href="https://Lu0key.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a>
        </div>
      </div>
    </header>
    <div class="post-content">
      <h1 id="查找">查找</h1>
<!-- raw HTML omitted -->
<ul>
<li><a href="#%E6%9F%A5%E6%89%BE">查找</a>
<ul>
<li><a href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">基本概念</a></li>
<li><a href="#%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE">顺序查找</a></li>
<li><a href="#%E6%8A%98%E5%8D%8A%E6%9F%A5%E6%89%BE">折半查找</a></li>
<li><a href="#%E5%88%86%E5%9D%97%E6%9F%A5%E6%89%BE">分块查找</a></li>
<li><a href="#b%E6%A0%91">B树</a></li>
<li><a href="#b%E6%A0%91%E7%9A%84%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4">B树的插入和删除</a>
<ul>
<li><a href="#%E6%8F%92%E5%85%A5">插入</a></li>
<li><a href="#%E5%88%A0%E9%99%A4">删除</a></li>
</ul>
</li>
<li><a href="#b%E6%A0%91-1">B+树</a></li>
<li><a href="#%E6%95%A3%E5%88%97%E6%9F%A5%E6%89%BE">散列查找</a>
<ul>
<li><a href="#%E6%95%A3%E5%88%97%E8%A1%A8hash-table">散列表(Hash Table)</a></li>
<li><a href="#%E5%BC%80%E6%94%BE%E5%AE%9A%E5%9D%80%E6%B3%95">开放定址法</a></li>
<li><a href="#%E5%B9%B3%E6%96%B9%E6%8E%A2%E6%B5%8B%E6%B3%95">平方探测法</a></li>
<li><a href="#%E4%BC%AA%E9%9A%8F%E6%9C%BA%E5%BA%8F%E5%88%97%E6%B3%95">伪随机序列法</a></li>
<li><a href="#%E5%86%8D%E6%95%A3%E5%88%97%E6%B3%95">再散列法</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- raw HTML omitted -->
<h2 id="基本概念">基本概念</h2>
<p><strong>查找</strong>：在数据集合中寻找满足某种条件的数据元素的过程称为查找<br>
<strong>查找表(查找结构)</strong>：用于查找的数据集合称为查找表，它由同一类型的数据元素(或记录组成)<br>
<strong>关键字</strong>：数据元素中唯一标识该元素的某个数据项的值，使用基于关键字的查找，查找结果应该是唯一的(比如学号)</p>
<p><strong>常见操作</strong></p>
<ol>
<li>查找符合条件的数据元素</li>
<li>插入、删除某个数据元素</li>
</ol>
<p>如果只进行操作1——静态查找表即可<br>
也要进行操作2——动态查找表</p>
<p><strong>评价指标</strong><br>
<strong>查找长度</strong>：在查找运算中，需要对比关键字的次数称为查找长度<br>
<strong>平均查找长度(ASL)</strong>：所有查找过程中进行关键字的比较次数的平均值</p>
<p>$\displaystyle ASL=\sum_{i=1}^nP_iC_i$<br>
其中n为数据元素个数，C_i为查找第i个元素的查找长度，P_i为查找第i个元素的概率</p>
<p>ASL的数量级放映了查找算法时间复杂度<br>
评价一个查找算法的效率时，通常考虑查找成功/失败两种情况的ASL</p>
<h2 id="顺序查找">顺序查找</h2>
<p>顺序查找，又叫“线性查找”，通常用于线性表(顺序表、链表)<br>
算法思想：从头到尾一个一个对比</p>
<p>顺序查找的实现</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// 查找表的数据结构(顺序表)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 动态数组的基址(剩下靠偏移量)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    Elemtypr <span style="color:#f92672">*</span>elem;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 表的长度
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> TableLen;
</span></span><span style="display:flex;"><span>}SSTable;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 顺序查找
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">Search_Seq</span>(SSTable ST, ElemType key) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> i;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// for循环空语句
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> (i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span>ST.TableLen <span style="color:#f92672">&amp;&amp;</span> ST.elem[i] <span style="color:#f92672">!=</span> key; i<span style="color:#f92672">++</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 查找成功，则返回元素下标；查找失败，则返回-1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> i<span style="color:#f92672">==</span>ST.TaqbleLen<span style="color:#f92672">?</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">:</span> i;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>顺序查找的实现(哨兵)<br>
索引为0空出来存key</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 动态数组的基址(剩下靠偏移量)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    Elemtypr <span style="color:#f92672">*</span>elem;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 表的长度
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> TableLen;
</span></span><span style="display:flex;"><span>}SSTable;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 顺序查找
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">Search_Seq</span>(SSTable ST, ElemType key) {
</span></span><span style="display:flex;"><span>    ST.elem[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> key;<span style="color:#75715e">// 哨兵
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> i;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (i<span style="color:#f92672">=</span>ST.TableLen; ST.elem[i]<span style="color:#f92672">!=</span>key;i<span style="color:#f92672">--</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> i;<span style="color:#75715e">//查找成功，则返回元素下标，查找失败，则返回0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>优点在于无序判断是否越界</p>
<p>上面两种的效率都是O(n)</p>
<p><strong>顺序查找的优化(对有序表)</strong><br>
查找表中元素有序存放</p>
<p>查找判定树(其实就是全部只有右子树的二叉排序树)</p>
<ul>
<li>成功节点的关键字对比次数=结点所在的层次</li>
<li>失败结点的关键字对比次数=其父节点所在层数</li>
</ul>
<p><strong>顺序查找的优化2(被查概率不相等)</strong><br>
被查找概率大的元素放在靠前的位置</p>
<p>顺序查找的时间复杂度都是O(n)</p>
<h2 id="折半查找">折半查找</h2>
<p>折半查找，又称为“二分查找”，仅适用于有序的顺序表。</p>
<p>一开始</p>
<ul>
<li>low=0,high=TableLen-1，得到mid=(low+high)/2向下取整</li>
<li>将key的元素与mid位置进行比较，然后low或者high赋值为mid-1或者mid+1</li>
<li>重复上面的过程，直到low=high</li>
</ul>
<p>折半查找</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">Binary_Search</span>(SSTable L,ElemType key) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> low<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>,high <span style="color:#f92672">=</span> L.TableLen<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>,mid;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span>(low<span style="color:#f92672">&lt;=</span>high){
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">//  取中间位置
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        mid <span style="color:#f92672">=</span> (low<span style="color:#f92672">+</span>high)<span style="color:#f92672">/</span><span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(L.elem[mid]<span style="color:#f92672">==</span>key)
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 查找成功则返回所在位置
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">return</span> mid;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span>(L.elem[mid]<span style="color:#f92672">&gt;</span>key)
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 从前半部分继续查找
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            high <span style="color:#f92672">=</span> mid<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span> 
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// 从后半部分继续查找
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            low <span style="color:#f92672">=</span> mid<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 查找失败，返回-1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>折半查找的查找效率为O(log_2n)<br>
在不考虑失败节点的情况下，折半查找的判定树，右子树结点数-左子树结点数=0或1</p>
<p>折半查找的判定树一定是平衡二叉树<br>
折半查找的判定树中，只有最下面一层是不满的，因此，元素个数为n时树高 $h=\lceil\log_2(n+1)\rceil$</p>
<h2 id="分块查找">分块查找</h2>
<p>特点：块内无序块间有序<br>
比如：
7 10 13 19 16 20 27 22 30 40 36 43 50 48</p>
<p>我们看这个例子看起来无序，但是分成一块一块的确是有序的</p>
<p><strong>索引表</strong>中保存每个分块的最大关键字和分块的存储区间</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// 索引表
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>    ElemType maxValue;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> low , high;
</span></span><span style="display:flex;"><span>}Index;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 顺序表存储实际元素
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>ElemType List[<span style="color:#ae81ff">100</span>];
</span></span></code></pre></div><p>因此上面那个例子的索引表就是</p>
<table>
<thead>
<tr>
<th>10</th>
<th>20</th>
<th>30</th>
<th>40</th>
<th>50</th>
</tr>
</thead>
<tbody>
<tr>
<td>[0,1]</td>
<td>[2,5]</td>
<td>[6,8]</td>
<td>[9,10]</td>
<td>[11,13]</td>
</tr>
</tbody>
</table>
<p>然后先和索引表中每个块的最大值对比，来确定哪一块</p>
<p>分块查找，又称索引顺序查找，算法过程如下：</p>
<ol>
<li>在索引表中确定待查记录所属的分块(可顺序、可折半)</li>
<li>在块内顺序查找</li>
</ol>
<p>折半查找要注意可能会low &lt; high，这时候要查low对应的分块，当low超出索引时，说明查找失败</p>
<h2 id="b树">B树</h2>
<p>二叉排序树</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// 二叉排序树结点
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> BSTNode {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> key;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> BSTNode <span style="color:#f92672">*</span>lchild, <span style="color:#f92672">*</span>rchild;
</span></span><span style="display:flex;"><span>}BSTNode, <span style="color:#f92672">*</span>BSTree;
</span></span></code></pre></div><p>二叉排序树实际上就是通过一个key，把范围分成两份为左右孩子，可以根据这个原理拓展到m叉查找树，例如:5叉查找树</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// 5叉排序树的结点定义
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> Node {
</span></span><span style="display:flex;"><span>    ElemType keys[<span style="color:#ae81ff">4</span>]; <span style="color:#75715e">// 最多4个关键字 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">struct</span> Node <span style="color:#f92672">*</span> child[<span style="color:#ae81ff">5</span>];<span style="color:#75715e">// 最多5个孩子
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> num; <span style="color:#75715e">// 结点中有几个关键字
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>若每个结点内关键字太少，导致树变高，要查找更多层结点，效率低<br>
策略：m叉查找树中，规定除了根节点外，任何结点至少有 $\lceil m/2\rceil$ 个分叉，即至少含有 $\lceil m/2\rceil-1$ 个关键字</p>
<p>B树，又称多路平衡查找树，B树种所有结点的孩子个数的最大值称为B树的阶，通常用m表示。一棵m阶B树或为空树，或为满足如下特性的二叉树：</p>
<ol>
<li>树中每个结点至多有m棵子树，即至多含有m-1个关键字</li>
<li>若根节点不是终端结点，则至少有两棵子树</li>
<li>除根节点外的所有非叶子结点至少有 $\lceil m/2 \rceil$ 棵子树，即至少含有 $\lceil m/2\rceil-1$ 个关键字</li>
<li>所有的叶子节点都出现在同一层次上，并且不带信息，可以认为是外部节点或类似于折半查找判定树的查找失败结点，实际上这些节点不存在，指向这些节点的指针为空</li>
<li>所有非叶子节点的结构如下</li>
</ol>
<table>
<thead>
<tr>
<th>n</th>
<th>P_0</th>
<th>K_1</th>
<th>P_1</th>
<th>&hellip;</th>
<th>K_n</th>
<th>P_n</th>
</tr>
</thead>
</table>
<p>其中K_i(i=1,2,&hellip;,n) 为结点的关键字，且满足K_1&lt; K_2 &lt;&hellip;&lt; K_n,P_i(i=0,1,2,&hellip;,n) 为指向子树根节点的指针，且指针P_{i-1} 所指子树中所有节点的关键字均小于K_i，P_i所指子树中所有结点的关键字均大于K_i,n为结点中关键字的个数。</p>
<p>m阶B树的核心特征：</p>
<ol>
<li>根节点的子树数 $\in[2, m]$，关键字数 $\in[1,m-1]$，其他根节点的子树数 $\in[\lceil m/2\rceil,m]$，关键字数  $\in[\lceil m/2\rceil-1, m-1]$</li>
<li>对任一结点，其所有子树高度都相同</li>
<li>关键字的值：子树0&lt;关键字1&lt;子树1&lt;关键字2&lt;子树2&lt;&hellip;..</li>
</ol>
<p>问题：含有n个关键字的m叉B树，最小高度、最大高度是多少?<br>
最大高度：让每个结点包含的关键字、分叉尽可能的少。记 $k=\lceil m/2\rceil$</p>
<table>
<thead>
<tr>
<th> </th>
<th>最少结点数</th>
<th>最少关键字数</th>
</tr>
</thead>
<tbody>
<tr>
<td>第一层</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>第二层</td>
<td>2</td>
<td>2(k-1)</td>
</tr>
<tr>
<td>第三层</td>
<td>2k</td>
<td>2k(k-1)</td>
</tr>
<tr>
<td>第四层</td>
<td>$2k^2$</td>
<td>$2k^2(k-1)$</td>
</tr>
<tr>
<td>&hellip;</td>
<td>&hellip;</td>
<td>&hellip;</td>
</tr>
<tr>
<td>第h层</td>
<td>$2k^{h-2}$</td>
<td>$2k^{h-2}(k-1)$</td>
</tr>
</tbody>
</table>
<p>h层的m阶B树至少包含关键字总数 $1+2(k-1)(k^0+k^1+\cdots+k^{h-2})=1+2(k^{h-1}-1)$<br>
若关键字总数少于这个值，则高度一定小于h，因此 $n\geqslant 1+2(k^{h-1}-1)$，得 $h\leqslant \log_k\dfrac{n+1}{2}+1=\log_{\lceil m/2\rceil}\dfrac{n+1}{2}+1$</p>
<h2 id="b树的插入和删除">B树的插入和删除</h2>
<h3 id="插入">插入</h3>
<p>这里以5阶B树为例：结点关键字个数 $\rceil m/2\rceil-1\leqslant n\leqslant m-1$，即 $2\leqslant n\leqslant 4$(此处省略失败结点)</p>
<pre tabindex="0"><code>25|38|49|60
</code></pre><p>这个结点已经满了，再插入一个结点80，需要进行一个分裂，变成</p>
<pre tabindex="0"><code>   49|||
   /    \
25|38||  60|80||   
</code></pre><p>在插入key后，若导致原结点关键字字数超过上限，则从中间位置 $(\lceil m/2\rceil)$ 将其中的关键字分为两部分，左部分包含的关键字放在原结点中，右节点部分包含的关键部分放到新结点中，中间位置 $(\lceil m/2\rceil)$ 的结点插入原节点的父节点<br>
若此时导致其父节点的关键字个数也超过了上限，则继续进行这种分裂操作，直到这个过程传到根节点为止，进而导致B树高度增加1</p>
<p>核心要求：</p>
<ul>
<li>对m阶B树：根节点除外，结点关键字个数 $\rceil m/2\rceil-1\leqslant n\leqslant m-1$</li>
<li>子树0 &lt; 关键字1 &lt; 子树1 &lt; 关键字2 &lt;&hellip;</li>
</ul>
<p>新元素一定是插入到最底层“终端结点”，用“查找”来确定插入位置</p>
<h3 id="删除">删除</h3>
<p>若被删除关键字在<strong>终端结点</strong>，则直接删除该关键字(要注意结点关键字个数是否低于下限)</p>
<p>若被删除关键字在<strong>非终端节点</strong>，则直接用前驱或者后继来替代被删除的关键字<br>
<strong>直接前驱</strong>：当前关键字左侧指针所指子树中最右下的元素(其实就是左侧子树中“最大”的元素)<br>
<strong>直接后继</strong>：当前关键字右侧指针所指子树中“最左下”的元素（其实就是右侧子树中“最小”的元素）</p>
<p>若删除关键字所在结点删除后的关键字个数低于下限，且与此结点右(或左)兄弟结点的关键字个数还很宽裕，则需要调整该结点、右(或左)兄弟结点及其双亲结点(父子换位法)(有点像旋转)</p>
<p>例如：</p>
<pre tabindex="0"><code>          49|73||
         /   \
   25|38||   70|71|72|   
</code></pre><p>5阶B树的关键字下限为2，因此删除38后，低于下限，得到</p>
<pre tabindex="0"><code>          49|73||
         /   \
   25|||     70|71|72|   
</code></pre><p>右兄弟结点关键字个数多于下限，因此旋转，父节点左旋到当前结点，兄弟结点左旋到父节点，得到</p>
<pre tabindex="0"><code>          70|73||
         /   \
   25|49||     71|72||   
</code></pre><p>当前结点的后继和后继的后继，借左兄弟关键字类似</p>
<p>兄弟不够借。若删除关键字所在结点删除后的关键字个数低于下限，且此时与该结点相邻的左、右兄弟结点的关键字个数均 $=\lceil m/2 \rceil-1$，则将关键字删除后与左(或右)兄弟结点及双亲结点中的关键字进行合并</p>
<p>在合并过程中，双亲结点中的关键字个数为减1。若其双亲结点是根节点且关键字个数减少至0(根节点关键字个数为1是，有两棵子树)，则直接将根节点删除，合并后的新结点成为根；若双亲结点不是根节点，且关键字个数减少到 $\lceil m/2 \rceil-2$，则又要与它自己的兄弟节点进行调整或合并操作，重复上述步骤，直至符合B树的要求为止。</p>
<h2 id="b树-1">B+树</h2>
<p>B+树和分块查找很类似</p>
<p>一棵m阶的B+树需要满足下列条件：</p>
<ol>
<li>每个分支结点最多有m棵子树（孩子结点）</li>
<li>非叶根结点（不是叶子的根节点，因为只有一层的时候即时根节点又是叶子）至少有两棵子树，其他每个分支节点至少有 $\lceil m/2 \rceil$ 棵子树</li>
<li>结点的子树个数与关键字个数相等</li>
<li>所有叶子结点包含全部关键字及指向相应记录的指针，叶子节点中将关键字按大小顺序排列，并且相邻叶子结点按大小顺序互相链接起来（因此支持顺序查找）</li>
<li>所有分支节点中仅包含它的各个子节点中关键字的最大值及指向其子节点的指针</li>
</ol>
<p>在B+树种，无论查找成功与否，最终都一定要走到最下面一层结点</p>
<p>在B+树中，非叶子结点不含有该关键字对应记录的存储地址。可以使一个磁盘块可以包含更多个关键字，使得B+树的阶更大，树高更小，读磁盘次数更少，查找更快</p>
<p> ||
类比|
关键字与分叉|
结点包含的信息|
查找方式|
相同点|</p>
<!-- raw HTML omitted -->
<h2 id="散列查找">散列查找</h2>
<h3 id="散列表hash-table">散列表(Hash Table)</h3>
<p>散列表(Hash Table)，又称哈希表。是一种数据结构，特点：数据元素的关键字与其存储地址直接关联</p>
<p>如果建立“关键字”与“存储地址”的联系？<br>
通过“散列函数(哈希函数)”：Addr=H(key)</p>
<p>例如：有一对数据元素，关键字分别为{19,14,23,1,68,20,84,27,55,11,10,79}，散列函数为 H(key)= key%13</p>
<p>14%13=1，那14 就存在数组1的位置<br>
如果不同关键字通过散列函数映射到同一个值，则称他们为“<strong>同义词</strong>”<br>
通过散列函数确定的位置已经存放了其他元素，则称这种情况为“<strong>冲突</strong>”</p>
<p>解决冲突的方法：<strong>拉链法</strong>(又称链接法、链地址法)处理“冲突”：把所有“同义词”存储在一个链表中</p>
<p>比如：14%13=1<br>
1%13=1，这样数组1的位置就会冲突，那么就可以，在数组1的位置存储链表的链头</p>
<p>比如数组8的位置没有任何元素，那么查找长度为0(一般当成0，看具体教材)</p>
<p>装填因子=表中记录数、散列表长度<br>
装填因子会直接影响散列表的查找效率</p>
<p>冲突越少，查找的效率越高<br>
常见的散列函数：</p>
<ul>
<li>除留余数法：H(key)=key%p
<ul>
<li>散列表表长为m，取一个不大于m但最接近或等于m的质数p(有可能散列表的有些位置永远用不到)</li>
</ul>
</li>
<li>直接定址法：H(key)=key 或H(key) = a*key+b
<ul>
<li>其中a和b是常数，这种方法计算最简单，且不会产生冲突，适合关键字的分布基本连续的情况，若关键字分布不连续，空位较多，则会造成存储空间的浪费</li>
</ul>
</li>
<li>数字分析法：选取数码分布较为均匀的若干位作为散列地址</li>
<li>平方取中法：取关键字的平方值的中间几位作为散列地址</li>
</ul>
<p>散列查找是典型的“用空间换时间”的算法，只要散列函数设计的合理，则散列表越长，冲突的概率越低</p>
<h3 id="开放定址法">开放定址法</h3>
<p>开放定址法：指可以存放新表项的空闲地址既向它的同义表项开放，又向它的非同义表项开放。其数学递推公式为 $H_i=(H(key)+d) %m$ ,i=0,1,2,&hellip;,k，m表示散列表长，d_i为增量序列,i可理解为第i次发生冲突</p>
<p><strong>线性探测法</strong>：即发生冲突时，每次往后探测相邻的下一个单元是否为空</p>
<p>查找的时候，先计算散列函数，然后从指定位置向后查找，会有两种情况，找到和找到空位置，找到空位置表示查找失败</p>
<p>我们知道查找失败的判定后，知道删除结点不能单纯的将空间置空，而应当做一个删除标记，使得线性探测可以继续下去</p>
<p>线性探测法很容易造成同义词、非同义词的“聚集(堆积)”现象，严重影响查找效率，产生原因：冲突后，再探测一定是放在某个连续的位置</p>
<h3 id="平方探测法">平方探测法</h3>
<p>当 $d_i=0^21^2-1^2,2^2,-2^2,&hellip;,k^2,-k^2$ 时名称为平方探测法，又称二次探测法，其中 $k\leqslant m/2$</p>
<p>平方探测法：比起线性探测法更不容易产生“聚集”问题</p>
<p>坑：散列表长度m必须时可以表示成4j+3的素数，才能探测到所有位置</p>
<h3 id="伪随机序列法">伪随机序列法</h3>
<p>$d_i$ 是一个伪随机序列</p>
<h3 id="再散列法">再散列法</h3>
<p>再散列法：除了原始的散列函数 H(key) 之外，多准备几个散列函数，当散列函数冲突时，用下一个散列函数计算一个新地址，知道不冲突为止</p>

    </div>
    <div class="post-footer">
      
    </div>
  </article>

    </main>
  </body>
</html>
